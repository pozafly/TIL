# Hoisting

<br/>

> 출처 : https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/JavaScript#part-2-2-javascript

- ES6 문법이 표준화 되면서 신경쓰지 않아도 되지만 자바스크립트가 가진 특성을 가장 잘 보여주므로 알아보자.

## 정의

- `hoist` 라는 단어의 사전적 정의는 **끌어올리기**라는 뜻이다. 자바스크립트에서 끌어올려지는 것은 변수임.
- 하지만 코드 단계에서는 어떠한 이동도 발견되지 안고, 함수와 변수 선언부는 컴파일 단계에서 메모리에 추가된다. (https://webruden.tistory.com/137)
- `var` 키워드로 선언된 모든 변수 선언은 **호이스트** 된다. 호이스트란 변수의 정의가 그 범위에 따라 `선언`과 `할당`으로 분리되는 것을 의미함.
- 즉, 변수가 함수 내에 정의되었을 경우, 선언이 함수의 최상위로, 함수 바깥에서 정의되었을 경우, 전역 컨텍스트의 최상위로 변겅 됨.

우선 선언(Declaration)과 할당(Assignment)을 이해해야 한다. 끌어올려지는 것은 선언임.

```javascript
function getX() {
  console.log(x);  // undefined
  var x = 100;
  console.log(x);  // 100
}
getX();
```

- 다른 언어의 경우엔, 변수 x를 선언하지 않고 출력하려 한다면 오류를 발생할 것이다. 하지만 자바스크립트에서는 `undefined` 라고 하고 넘어감. 
- `var x = 100;` 이 구문에서 `var x;` 를 호이스트 하기 때문. 즉, 변수에 할당된 값까지 같이 올리는게 아니라 변수 자체만 올라감.
- 즉, 작동 순서에 맞게 코드를 재구성하면 다음과 같다.

```javascript
function getX() {
  var x;
  console.log(x);
  x = 100;
  console.log(x);
}
getX();
```

선언문은 항시 자바스크립트 엔진 구동 시 가장 최우선으로 해석하므로 호이스팅 되고, **할당 구문은 런타임 과정에서 이루어지기 때문**에 호이스팅 되지 않음.

- 함수가 자신이 위치한 코드에 상관없이, 함수 선언문 형태로 정의한 함수의 유효범위는, 전체 코드의 맨 처음부터 시작한다. 
- 함수 선언이 함수 실행 부분보다 뒤에 있더라도 자바스크립트 엔진이 함수 선언을 끌올 하는 것을 의미함. 함수 호이스팅은 함수를 끌올하지만 변수의 `값`은 끌올 하지 않음.

```javascript
foo();
function foo() {
  console.log('hello');
}

// hello
```

- foo 함수에 대한 선언을 호이스팅하여 global 객체에 등록시키기 때문에 `hello`가 제대로 출력된다.

```javascript
foo();
var foo = function() {
  console.log('hello');
}

// Uncaught TypeError: foo is not a function
```

- 위의 예제 함수 표현은 함수 리터럴을 할당하는 구조이기 때문에 호이스팅 되지 않으며 그렇기 때문에 런타임 환경에서 `Type Error`를 발생시킴.



## 호이스팅 현상 발생 이유

> 출처 : https://2dubbing.tistory.com/68

Javascript는 코드가 실행될 때 `실행 컨텍스트`가 생성된다. 이 때, 실행 컨텍스트 내부 변수 객체에서 현재 컨텍스트에 사용되는 변수 또는 함수를 생성함.

변수가 생성되는 과정은 3단계로 나뉨.

1. 변수 선언
2. 변수 초기화
3. 변수에 사용자가 지정한 값으로 초기화

여기서 **3. 변수에 지정한 값 할당**은 해당 실행 컨텍스트의 변수 객체 생성이 완료된 뒤에 실행됨. 즉, 변수의 선언 + 초기화와 사용자가 지정한 값 초기화가 발생되는 환경이 나뉘어 발생됨.

함수의 경우 **함수 선언문**인지 **함수 표현식**형태인지 따라 생성과정에 차이가 있음.

- 함수 선언문 
  - 변수 객체가 만들어지는 과정에서 함수 선언, 초기화, 사용자 지정 값으로 초기화 3단계 모두 발생함.
  - 즉, 실행 단계에서 함수 선언문보다 함수 호출이 먼저 발생해도 에러가 나지 않고 정상적으로 실행됨.
- 함수 표현식
  - 익명함수를 생성하여 변수에 할당하는 방식(변수 호이스팅 적용).
  - 즉, 실행 단계에서 함수 표현식보다 함수 호출이 먼저 발생하게 되면 TypeError가 발생.