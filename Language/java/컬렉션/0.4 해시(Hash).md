# 해시(Hash)

<img width="687" alt="image" src="https://github.com/user-attachments/assets/70655865-5382-4c2e-aff6-8c1a30680df6" />

- 정의: 세트(셋)는 유일한 요소들의 컬렉션. 세트보다는 셋으로 많이 불림.
- 특징
  - **유일성**: 셋에는 중복된 요소가 존재하지 않음. 셋에 요소를 추가할 때, 이미 존재하는 요소면 무시됨.
  - **순서 미보장**: 대부분의 셋 구현에서는 요소들의 순서를 보장하지 않음. 즉, 요소를 출력할 때 입력 순서와 다를 수 있음.
  - **빠른 검색**: 셋은 요소의 유무를 빠르게 확인할 수 있도록 최적화되어 있음. 이는 데이터의 중복을 방지하고 빠른 조회를 가능하게 함.
- 예시
  - List: 장바구니 목록, 순서가 중요한 일련의 이벤트 목록.
  - Set: 회원 ID 집합, 고유한 항목의 집합.

---

- `add(value)`: 셋에 값을 추가한다. 중복 데이터는 저장하지 않는다.
- `contains(value)`: 셋에 값이 있는지 확인한다.
- `remove(value)`: 셋에 있는 값을 제거한다.

add는 중복 값 체크를 위해 for 문을 돌려야 하므로 성능이 O(n)으로 좋지 않다. 전체를 검색을 한번 해야하기 때문임. `contains()` 로 데이터를 찾을 때 배열에 있는 모든 데이터를 찾고 비교해야 하므로 마찬가지로 O(n)임.

이걸 어떻게 개선할 수 있을까?

<br/>

## 해시 알고리즘

데이터를 찾는 검색 성능을 평균 O(1)으로 비약적으로 끌어올릴 수 있음.

### Index 사용

배열은 인덱스의 위치를 사용해 데이터를 찾을 때 O(1)로 매우 빠른 특징을 가지고 있음. 데이터의 값 자체를 배역의 인덱스와 맞추어 저장하면 어떨까? 데이터의 값 자체를 배열의 인덱스로 사용하는 것.

<img width="802" alt="image" src="https://github.com/user-attachments/assets/777e6dae-380f-49ca-97e1-22c1ad4e18ad" />

- 데이터 1을 찾으려면 `array[1]` 을 입력하면 된다.
- 데이터 2를 찾으려면 `array[2]` 을 입력하면 된다.
- 데이터 5를 찾으려면 `array[5]` 을 입력하면 된다.
- 데이터 8를 찾으려면 `array[8]` 을 입력하면 된다.

데이터의 값 자체를 배열의 인덱스로 사용했다. 배열에서 인덱스로 데이터를 찾는 것은 매우 빠르다. 그 덕분에 O(n)의 검색 성능을 O(1)로 획기적으로 개선할 수 있었다.

하지만, 문제는 입력 값의 범위 만큼 큰 배열을 사용해야 함. 따라서 배열에 낭비되는 공간이 많이 발생.

### 메모리 낭비

0~99 까지 사용한다고 해보자. 하나만 넣고 뺀다면 다른 메모리는 모두 null이다.

만약 입력 값의 범위를 `0~99` 를 넘어 `int` 숫자의 모든범위를 입력할 수 있도록 하려면 배열의 크기를 얼마로 잡아야 할까?

- 0~99 까지 범위 입력
  - 사이즈 100의 배열이 필요: 4byte * 100 (단순히 값의 크기로만 계산)
- int 범위 입력
  - `int` 범위: -2,147,483,648 ~ 2,147,483,647
  - 약 42억 사이즈의 배열 필요 (+- 모두 포함)
  - 4byte * 42억 = 약 17기가바이트 필요 (단순히 값의 크기로만 계산)

### 나머지 연산

공간도 절약하면서, 넓은 범위의 값을 사용할 수 있는 방법이 있는데, 나머지 연산을 사용하는 것. 저장할 수 있는 배열의 크기(CAPACITY)를 10이라 가정한다. 그 크기에 맞추어 나머지 연산을 사용하면 된다.

- 1 % 10 = 1
- `2 % 10 = 2`
- `5 % 10 = 5`
- `8 % 10 = 8`
- `14 % 10 = 4`
- `99 % 10 = 9`

여기서 14, 99는 10보다 큰 값이다. 따라서 일반적인 방법으로는 크기가 10인 배열의 인덱스로 사용할 수 없다. 하지만 나머지 연산의 결과를 사용하면 14는 4로, 99는 9로 크기가 10인 배열의 인덱스로 활용할 수 있다. 나머지 연산의 결과는 절대로 배열의 크기를 넘지 않는다. 예를 들어 나머지 연산에 10을 사용하면 결과는 `0~9` 까지만 나온다. 절대로 10이 되거나 10을 넘지 않는다. 따라서 연산 결과는 배열의 크기를 넘지 않으므로 안전하게 인덱스로 사용할 수 있다.

예)

- `9 % 10 -> 9`
- `10 % 10 -> 0`
- `11 % 10 -> 1`

#### 해시 인덱스

이렇게 배열의 index로 사용할 수 있도록 원래 값을 계산한 인덱스를 해시 인덱스(hashIndex) 라 함. 14의 해시 인덱스는 4이고, 99의 해시 인덱스는 9.

<img width="795" alt="image" src="https://github.com/user-attachments/assets/a8378c9b-1a4f-4beb-b7f4-a801ba99e918" />

그럼 O(1)로 저장.

### 해시 인덱스와 데이터 조회

<img width="796" alt="image" src="https://github.com/user-attachments/assets/3d7368c8-604b-4dd8-9361-04ddabf2e3c9" />

조회할 때도 O(1) 이다.

### 한계 - 해시 충돌

- `1 % 10 = 1`
- `11 % 10 = 1`

1과 11 둘다 해시인덱스가 1이다.

<img width="799" alt="image" src="https://github.com/user-attachments/assets/79050b5d-85b8-43f0-931f-84d51ad76d71" />

해결법은, 해시 충돌은 낮은 확률로 일어날 수 있다고 가정하는 것. 해시 충돌이 일어났을 때, 단순하게 같은 해시 인덱스의 값을 같은 인덱스에 함께 저장해버리는 것이다.

<img width="785" alt="image" src="https://github.com/user-attachments/assets/9da45660-7084-4dbd-991b-136c770bd601" />

**배열 안에 배열을 만들면 된다**.

<img width="799" alt="image" src="https://github.com/user-attachments/assets/9d36f424-1d7f-4c7e-ba7a-be415aa2ea83" />

그리고 조회할 때는 해시인덱스가 9인 곳을 찾아가서 값을 꺼내고, 그 중 조회하고자 하는 값이 있는지 `equals` 비교로 확인하면 된다.

### 최악의 경우

<img width="792" alt="image" src="https://github.com/user-attachments/assets/aced31bf-aae5-4196-a370-29a7c62811fd" />

해시인덱스로 찾은 값이 많은 경우 O(n) 으로 다시 찾아야 하므로 성능이 좋지 ㅇ낳아진다.

### 정리

해시 인덱스를 사용하는 방식은 최악의 경우 O(n)의 성능을 보인다. 하지만 확률적으로 보면 어느 정도 넓게 퍼지기 때 문에 평균으로 보면 대부분 O(1)의 성능을 제공한다. 해시 충돌이 가끔 발생해도 내부에서 값을 몇 번만 비교하는 수준 이기 때문에 대부분의 경우 매우 빠르게 값을 찾을 수 있다.
