# 클래스 vs 함수 컴포넌트

<br/>

리액트 `컴포넌트`란 웹어플리케이션, 웹페이지에서 독립적이고 재사용이 가능한 단위로(박스 단위로) 나뉘어진 블럭을 말함. 최대한 독립적이고 재사용이 가능한 작은 단위가 좋다.

컴포넌트를 만들기 위해서 클래스를 이용해도 되고, 함수형으로 만들 수 있다.

<br/>

## 클래스형

```jsx
import React from 'react';

class LikeButton extends Component {
  state = {
    numberOfLikes: 0,
  };
  render() {
    return <button>{this.state.numberOfLikes}</button>;
  }
}
```

- 클래스 형은 리액트에서 제공하는 `React.Component` 를 상속하여 만든다.
- UI가 어떻게 표기 될 것인지 정의하는 `render() 함수를 구현`해 주어야 함.
- 컴포넌트 자체에 계속 기억 되어져야 하는, UI를 표기 하기 위한 데이터가 있다면 `this.state` 멤버 변수에 오브젝트 형태로 데이터를 저장할 수 있다.
- 클래스 특성상, 클래스의 인스턴스(오브젝트)가 생성이 되면 클래스의 메소드(함수)를 아무리 많이 호출해도 **클래스의 멤버 변수를 직접 적으로 수정하지 않는 한 멤버 변수는 한번 만들어 지면 계속 그 값이 유지가 되어진다.**
- 따라서 render 함수가 아무리 많이 호출 되어져도(부모 컴포넌트로 부터 전달받은 props가 변경되는 경우 컴포넌트 자체적인 데이터, this.state가 변경되지 않아도 render 함수가 계속 호출될 수 있다.), this.state에 들어있는 데이터는 변하지 않기 때문에, 컴포넌트에서 가지고 있던 데이터를 잃어 버리지 않고 일정하게 데이터를 사용자에게 보여줄 수 있다.
- 컴포넌트에서 데이터를 변경해서 UI를 업데이트 해주고 싶다면 간단하게 this.state 만 업데이트 해주면 리액트가 알아서 render 함수를 다시 호출해주고 브라우저에 업데이트를 해주게 된다.
- 컴포넌트에 state가 있고, 그 상태에 따라 컴포넌트가 주기적으로 업데이트 되어야 한다면 클래스 컴포넌트를 쓰는게 좋다.
- 라이프사이클 메서드 존재함.

정리를 해보면, 클래스 형 컴포넌트는 React.Component 클래스 상속, 데이터는 this.state에서 관리, render() 함수에 HTML과 같은 JSX 문법을 이용해 UI 표현.

📌 중요 포인트

- 리액트는 변경사항이 한 가지의 방향으로만 흘러간다.
  - 데이터가 변경이 되면 -> UI가 업데이트 된다.
  - 즉, 데이터(State)가 변경이 되면 -> 리액트가 render() 함수를 호출해서 UI가 업데이트 된다.

<br/>

## 함수형

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

- JSX를 리턴하는 함수를 정의한다.
- state가 없다. 따라서 정적으로 데이터가 표기 된다면 함수형으로 하는게 좋다.
- 컴포넌트 자체에 데이터(State)가 없는 경우, 외부에서 전달받은 데이터(Props)만 보여주면 되거나, state, props 둘 다 없는 아주 **정적인 컴포넌트인 경우** 굳이 클래스를 정의 하지 않고 이렇게 함수 만으로 리액트 컴포넌트를 만들 수 있다.
- 위의 class 형과는 반대로 함수의 특성상, 함수를 호출 할 때마다 함수의 코드 블럭이 다시 실행되고, 그 안에 선언한 모든 로컬 변수들은 함수의 실행 컨텍스트 안에서 재정의, 값이 할당 됨.
- 따라서 함수 안에서 state를 보관해 일관적으로 사용자에게 보여줄 수 있는 방법이 없기 때문에(함수가 호출 될 때 모든 로컬 변수들의 값이 초기화 되어 기존의 데이터 들이 다 초기화 됨.) 일반 함수형 컴포넌트에서는 컴포넌트만의 자체적인 데이터(state)를 가질 수 없다.
- 라이프사이클 메서드도 없음.
- 하지만 react 16.8 부터는 React Hook 이 도입되었음. 라이프사이클 메서드, state 도 Hook으로 처리 가능함.
- Hook이 도입된 이유
  - class 형태가 어렵기 때문.
  - this. 으로 스코프가 존재해 this. 로 떡칠 되었기 때문.

