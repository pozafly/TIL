# redux-saga

> 출처 : https://react.vlpt.us/redux-middleware/10-redux-saga.html

## 소개

[redux-saga](https://github.com/redux-saga/redux-saga)는 redux-thunk 다음으로 가장 많이 사용되는 라이브러리.

[참고할만한 곳](https://ui.toast.com/weekly-pick/ko_20171124) 나중에 꼭 정리해보자.

redux-thunk는 함수를 디스패치 할 수 있게 해주는 미들웨어였다. redux-saga의 경우엔, 액션을 모니터링 하고 있다가, 특정 액션이 발생하면 이에 따라 특정 작업을 하는 방식으로 사용한다. 여기서 특정 작업이란, 특정 자바스크립터를 실행하는 것일 수도 있고, 다른 액션을 디스패치 하는 것일 수도 있고, 현재 상태를 불러오는 것일 수도 있다.

redux-saga는 redux-thunk로 못하는 다양한 작업들을 처리할 수 있다. 예를들면

1. 비동기 작업을 할 때 기존 요청을 취소 처리 할 수 있다.
2. 특정 액션이 발생했을 때 이에 따라 다른 액션이 디스패치 되게끔 하거나, 자바스크립트 코드를 실행할 수 있다.
3. 웹소켓을 사용하는 경우 Channel 이라는 기능을 사용해 더욱 효율적으로 코드를 관리할 수 있다.
4. API 요청이 실패했을 때 재요청하는 작업을 할 수 있다.

이외에도 다양한 까다로운 비동기 작업들을 saga를 통해 처리할 수 있다.

redux-saga는 다양한 상황에 쓸 수 있는 만큼, 제공되는 기능도 많고, 사용방법도 진입장벽이 크다. 자바스크립트 초심자라면 생소할 만한 [Generator](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Generator) 문법을 사용하는데, 이 문법을 이해하지 못하면 redux-saga를 배우는 것이 매우 어려움.

<br/>

## Generator 문법

이 문법의 핵심 기능은 함수를 작성할 때 함수를 특정 구간에 멈춰놓을 수도 있고, 원할 때 다시 돌아가게 할 수도 있다. 그리고 결과값을 여러번 반환할 수도 있다.

```js
function weirdFunction() {
  return 1;
  return 2;
  return 3;
  return 4;
  return 5;
}
```

함수에서 값을 여러번에 걸쳐 반환하는 것은 불가능하다. 이 함수는 호출할 때마다 무조건 `1`을 반환하게 됨. 하지만, 제네레이터 함수를 사용하면 함수에서 값을 순차적으로 반환할 수 있다. 함수의 흐름을 도중에 멈춰놓았다가 나중에 이어서 진행 할 수도 있다.

크롬 개발자 도구의 콘솔에서 다음 함수를 한번 작성해보자.

```js
function* generatorFunction() {
  console.log('안녕하세요?');
  yield 1;
  console.log('제너레이터 함수');
  yield 2;
  console.log('function*');
  yield 3;
  return 4;
}
```

제너레이터 함수를 만들 때는 `function*` 이라는 키워드를 사용한다. 제너레이터 함수를 호출 했을 때는 한 객체가 반환된다. 이를 제너레이터라고 부른다.

```js
const generator = generatorFunction();
```

제너레이터 함수를 호출한다고 해서 해당 함수 안의 코드가 바로 시작되지는 않는다. `generator.next()` 를 호출해야만 코드가 실행되며, `yield` 를 한 값을 반환하고 코드의 흐름을 멈춘다.

코드의 흐름이 멈추고 나서 `generator.next()` 를 다시 호출하면 흐름이 이어서 다시 시작된다.

제너레이터 함수의 또 다른 예시를 보자. `next`를 호출할 때 인자를 전달하여 이를 제너레이터 함수 내부에서 사용할 수도 있다.

```js
function* sumGenerator() {
  console.log('sumGenerator이 시작됐습니다.');
  let a = yield;
  console.log('a값을 받았습니다.');
  let b = yield;
  console.log('b값을 받았습니다.');
  yield a + b;
}
```

```js
const sum = sumGenerator();
아래 명령어를 통해 단계를 밟아갈 수 있음.
sum.next();
sum.next(1);
sum.next(4);
```

<br/>

## Generator로 액션 모니터링 하기

redux-saga는 액션 모니터링 할 수 있다라고 소개했다. Generator를 통해 모니터링이 어떻게 이루어지는지 예시 코드를 작성해보면서 배워보자.

크롬 개발자 도구 콘솔에 적어보자.

```js
function* watchGenerator() {
  console.log('모니터링 시작!');
  while(true) {
    const action = yield;
    if (action.type === 'HELLO') {
      console.log('안녕하세요?');
    }
    if (action.type === 'BYE') {
      console.log('안녕히가세요.');
    }
  }
}
```

```js
const watch = watchGenerator()
하고 밑에를 찍어보자.
watch.next();
watch.next({ type: 'HELLO' });
watch.next({ type: 'BYE' });
```

redux-saga에서는 이러한 원리로 액션을 모니터링 하고, 특정 액션이 발생했을 때, 우리가 원하는 자바스크립트 코드를 실행시켜 준다.

<br/>

## 리덕스 사가 설치 및 비동기 카운터 만들기

thunk를 사용해 구현했던 비동기 카운터 기능을 redux-saga를 사용해 구현해보자. 설치부터.

```sh
$ yarn add redux-saga
```

그 다음에는, counter.js 리덕스 모듈을 열어 기존 `increaseAsync`, `decreaseAsync` thunk 함수를 지우고, 일반 액션 생성 함수로 대체시키자.

```jsx
// modules/counter.js

// 액션 타입
const INCREASE = 'INCREASE';
const DECREASE = 'DECREASE';
const INCREASE_ASYNC = 'INCREASE_ASYNC';   // 추가
const DECREASE_ASYNC = 'DECREASE_ASYNC';   // 추가

// 액션 생성 함수
export const increase = () => ({ type: INCREASE });
export const decrease = () => ({ type: DECREASE });
export const increaseAsync = () => ({ type: INCREASE_ASYNC });   // 추가
export const decreaseAsync = () => ({ type: DECREASE_ASYNC });   // 추가

// 초깃값 (상태가 객체가 아니라 그냥 숫자여도 상관 없음)
const initialState = 0;

export default function counter(state = initialState, action) {
  switch (action.type) {
    case INCREASE:
      return state + 1;
    case DECREASE:
      return state - 1;
    default:
      return state;
  }
}
```

다음엔, `increaseSaga`와 `decreaseSaga` 를 다음과 같이 만들어주자. redux-saga 에서는 제너레이터 함수를 '사가' 라고 부름.

```js
// modules/counter.js
import { delay, put } from 'redux-saga/effects';

...

// 리덕스-사가
function* increaseSaga() {
  yield delay(1000); // 1초를 기다린다.
  yield put(increase()); // put은 특정 액션을 디스패치 해줌.
}
function* decreaseSaga() {
  yield delay(1000);
  yield put(decrease());
}
```

요렇게 추가해준다. `redux-saga/effets` 에는 다양한 유틸 함수들이 들어 있다. 여기서 사용한 `put`이란 함수가 매우 중요한데, 이 함수를 통하여 새로운 액션을 디스패치 할 수 있다.

그 다음에는 `takeEvery`, `takeLastest` 라는 유틸 함수들을 사용해보겠다. 이 함수들은 액션을 모니터링 하는 함수.

- takeEvery
  - 특정 액션 타입에 대해 디스패치되는 모든 액션들을 처리하는 것.
- takeLastest
  - 특정 액션 타입에 대해 디스패치된 가장 마지막 액션만 처리하는 함수.
  - 예를들어 특정 액션을 처리하고 있는 동안 동일한 타입의 새로운 액션이 디스패치 되면 기존에 하던 작업을 무시 처리하고 새로운 작업을 시작함. 마치 lodash의 debounce 같구만...

`counterSaga` 라는 함수를 만들어 두 액션을 모니터링 해보자.

```js
// modules/counter.js
import { delay, put, takeEvery, takeLatest } from 'redux-saga/effects';

...

export function* counterSaga() {
  yield takeEvery(INCREASE_ASYNC, increaseSaga); // 모든 INCREASE_ASYNC 액션을 처리
  yield takeLatest(DECREASE_ASYNC, decreaseSaga); // 가장 마지막으로 디스패치 된 DECREASE_ASYNC 액션만을 처리
}
```

`counterSaga` 함수의 경우 다른 곳에서 불러와서 사용해야되므로 export를 붙여준다.

이제 루트 사가를 만들어주어야 함. 프로젝트에서 여러 개의 사가를 만들게 될텐데, 이를 모두 합쳐서 루트 사가를 만든다.

```js
// modules/index.js
import { all } from '@redux-saga/core/effects';
import { combineReducers } from 'redux';
import counter, { counterSaga } from './counter';
import posts from './posts';

const rootReducer = combineReducers({ counter, posts });
export function* rootSaga() {
  yield all([counterSaga()]); // all 은 배열 안의 여러 사가를 동시에 실행한다.
}

export default rootReducer;
```

이제 리덕스 스토어에 redux-saga 미들웨어를 적용해보자.

```jsx
// index.js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import { applyMiddleware, createStore } from 'redux';
import rootReducer, { rootSaga } from './modules';   // 루트 사가 임포트
import { Provider } from 'react-redux';
import logger from 'redux-logger';
import { composeWithDevTools } from 'redux-devtools-extension';
import ReduxThunk from 'redux-thunk';
import { Router } from 'react-router-dom';
import { createBrowserHistory } from 'history';
import createSagaMiddleware from 'redux-saga'; // 사가 임포트

const customHistory = createBrowserHistory();
const sagaMiddleware = createSagaMiddleware(); // 사가 미들웨어를 만든다.

const store = createStore(
  rootReducer,
  // logger를 사용하는 경우, logger가 가장 마지막에 와야 한다.
  composeWithDevTools(
    applyMiddleware(
      ReduxThunk.withExtraArgument({ history: customHistory }),
      sagaMiddleware, // 사가 미들웨어 적용하고,
      logger
    )
  )
);

sagaMiddleware.run(rootSaga); // 루트 사가를 실행해주자.
// 주의 : 스토어 생성이 된 다음에 위 코드를 실행해야 함.

ReactDOM.render(
  <React.StrictMode>
    <Router history={customHistory}>
      <Provider store={store}>
        <App />
      </Provider>
    </Router>
  </React.StrictMode>,
  document.getElementById('root')
);
```

그 다음엔 App 컴포넌트에서 CounterContainer를 렌더링 해보자.

```jsx
// App.js
import React from 'react';
import { Route } from 'react-router-dom';
import PostListPage from './pages/PostListPage';
import PostPage from './pages/PostPage';
import CounterContainer from './container/CounterContainer';

const App = () => {
  return (
    <>
      <CounterContainer />
      <Route path='/' component={PostListPage} exact />
      <Route path='/:id' component={PostPage} />
    </>
  );
};

export default App;
```

![9DmSehR](https://user-images.githubusercontent.com/59427983/110723743-dc04cd80-8257-11eb-8d3e-b8335f26d3c6.gif)

- +1 버튼을 여러번 누르면, INCREASE_ASYNC 액션이 누른 만큼 1초 뒤에 실행된다.
- -1 버튼을 여러번 누르면, DECREASE_ASYNC 액션이 여러번 누른 만큼 다 씹히고 마지막 녀석만 1초 뒤에 1번 실행됨.

카운터가 잘 작동하는 것을 확인했다면 App에서 CounterContainer를 지우자.