# redux-thunk

## 소개

redux-thunk는 리덕스에서 비동기 작업을 처리 할 때 가장 많이 사용하는 미들웨어. 이 미들웨어를 사용하면 **액션 객체가 아닌 함수를 디스패치 할 수 있다.** redux-thunk는 리덕스의 창시자인 Dan Abramov가 만들었다. 리덕스 공식 메뉴얼에도 비동기 작업을 처리하기 위해 미들웨어를 사용하는 예시를 보여줌.

<br/>

## Thunk란?

Thunk는 특정 작업을 나중에 할 수 있도록 미루기 위해 함수 형태로 감싼 것을 의미함. 예를 들어 주어진 파라미터에 1을 더하는 함수를 만들고 싶다면 다음과 같이 작성할 것이다.

```js
const addOne = x => x + 1;
addOne(1);   // 2
```

이 코드를 실행하면 addOne 을 호출했을 때 바로 1 + 1이 연산된다. 그런데 이 연산 작업을 나중에 하도록 미루고 싶다면 어떻게 하나?

```js
const addOne = x => x + 1;
function addOneThunk(x) {
  const thunk = () => addOne(x);
  return thunk;
}

function fn = addOneThunk(1);

setTimeout(() => {
  const value = fn();   // fn이 실행되는 시점에 연산
  console.log(value);
}, 1000);
```

이렇게 하면 특정 작업을 나중에 하도록 미룰 수 있다. 여기서 addOneThunk 라는 함수를 호출 했을 때, addOneThunk는 콜백함수로, addOne()이라는 함수를 계산한 값을 return 해주는 콜백 함수이기 때문에 fn이 실행되는 시점에 연산되는 것이다. 콜백에 대한 자세한 것은 여기 [비동기와 콜백에 대한 정리](https://github.com/pozafly/TIL/blob/main/Javascript/%EB%B9%84%EB%8F%99%EA%B8%B0%20%EC%B2%98%EB%A6%AC%EC%99%80%20%EC%BD%9C%EB%B0%B1%20%ED%95%A8%EC%88%98.md)에서 확인해보자.

만약 addOneThunk 를 화살표 함수로만 사용한다면 다음과 같이 사용할 수 있다.

```js
const addOne = x => x + 1;
const addOneThunk = x => () => addOne(x);

const fn = addOneThunk(1);

setTimeout(() => {
  const value = fn();  // fn이 실행되는 시점에 연산
  console.log(value);
}, 1000);
```

redux-thunk 라이브러리를 사용하면 thunk 함수를 만들어 디스패치 할 수 있다. 그러면 리덕스 미들웨어가 그 함수를 전달받아 store의 dispatch와 getState를 파라미터로 넣어 호출해준다.

다음은 redux-thunk에서 사용할 수 있는 예시 thunk 함수다.

```js
const smapleThunk = () => (dispatch, getState) => {
  // 현재 상태를 참조할 수 있고,
  // 새 액션을 디스패치 할 수도 있다.
}
```

<br/>

thunk와 비슷한 형태를 보자.

```js
const thunk = store => next => action => 
  typeof action === 'function'
    ? action(store.dispatch, store.getState)
    : next(action)
```

실제로 redux-thunk의 코드는 위와 비슷함. 열어보면 겨우 14줄 밖에 안됨. 그런데 그런 라이브러리가 Weekly 다운 수가 140만대다.

이 미들웨어를 사용하면 함수를 디스패치 할 수 있다고 했는데, 함수를 디스패치할 때에는, 해당 함수에서 `dispatch`와 `getState`를 파라미터로 받아와주어야 함. 이 함수를 **만들어주는 함수**를 thunk라고 부름.

예시를 보자.

```js
const getComments = () => (dispatch, getState) => {
  // 이 안에서는 액션을 dispatch할 수도 있고
  // getState를 사용해 현재 상태도 조회할 수 있다.
  const id = getState().post.activeId;
  
  // 요청이 시작했음을 알리는 액션
  dispatch({ type: 'GET_COMMENTS' });
  
  // 댓글을 조회하는 프로미스를 반환하는 getComments가 있다고 가정하자.
  api
    .getComments(id)  // 요청을 하고,
    .then(comments => dispatch({ type: 'GET_COMMENTS_SUCCESS', id, comments }));  // 성공시
    .catch(e => dispatch({ type: 'GET_COMMENTS_ERROR', error: e }));  // 실패시
};
```

thunk 함수에서 async / await를 사용해도 상관 없음.

```js
const getComments = () => async (dispatch, getState) => {
  const id = getState().post.activeId;
  dispatch({ type: 'GET_COMMENTS' });
  
  try {
    const comments = await api.getComments(id);
    dispatch({ type: 'GET_COMMENTS_SUCCESS', id, comments });
  } catch (e) {
    dispatch({ type: 'GET_COMMENTS_ERROR', error: e });
  }
};
```

<br/>

## redux-thunk 설치 및 적용

```bash
$ yarn add redux-thunk
```

redux-thunk를 index.js에서 불러와 `applyMiddlewares` 를 통해 적용해보자.

```js
// index.js
import ReduxThunk from 'redux-thunk';

const store = createStore(
  rootReducer,
  // logger를 사용하는 경우, logger가 가장 마지막에 와야 한다.
  composeWithDevTools(applyMiddleware(ReduxThunk, logger))
); // 여러개의 미들웨어를 적용할 수 있다.
```

<br/>

## Thunk 생성함수 만들기

redux-thunk는 액션 생성함수에서 일반 액션 객체를 반환하는 대신에 함수를 반환한다. 카운터 값을 비동기적으로 변경시켜보자.

### 카운터 딜레이하기

기본적인 것부터 해보자. thunk 함수를 만들고, `setTimeout` 을 사용하여 액션이 디스패치 되는 것을 1초 씩 딜레이 시켜보자.

```jsx
// modules/counter.js
// 액션 타입
const INCREASE = 'INCREASE';
const DECREASE = 'DECREASE';

// 액션 생성 함수
export const increase = () => ({ type: INCREASE });
export const decrease = () => ({ type: DECREASE });

// getState를 쓰지 않는다면 굳이 파라미터로 받아올 필요 없다.
export const increaseAsync = () => (dispatch) => {
  setTimeout(() => dispatch(increase()), 1000);
};
export const decreaseAsync = () => (dispatch) => {
  setTimeout(() => dispatch(decrease()), 1000);
};

// 초깃값 (상태가 객체가 아니라 그냥 숫자여도 상관 없음)
const initialState = 0;

export default function counter(state = initialState, action) {
  switch (action.type) {
    case INCREASE:
      return state + 1;
    case DECREASE:
      return state - 1;
    default:
      return state;
  }
}
```

기존의 js에서 increaseAsync, decreaseAsync 두개만 추가했다. 이 함수가 thunk 함수임. 이제 컨테이너 컴포넌트를 다음과 같이 수정해보자.

```jsx
// container/CounterContainer.js
import React from 'react';
import { useDispatch, useSelector } from 'react-redux';
import Counter from '../components/Counter';
import { increaseAsync, decreaseAsync } from '../modules/counter';  // 임포트 바뀜

const CounterContainer = () => {
  const number = useSelector((state) => state.counter);
  const dispatch = useDispatch();

  const onIncrease = () => {
    dispatch(increaseAsync());   // increase() => increaseAsync()
  };
  const onDecrease = () => {
    dispatch(decreaseAsync());   // decrease() => decreaseAsync()
  };

  return (
    <Counter number={number} onIncrease={onIncrease} onDecrease={onDecrease} />
  );
};

export default CounterContainer;
```

이렇게 하면 1초 뒤에 실행되는 것을 볼 수 있다.

