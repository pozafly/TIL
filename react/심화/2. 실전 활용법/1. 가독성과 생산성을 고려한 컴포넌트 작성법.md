# 가독성과 생산성을 고려한 컴포넌트 작성법

같은 기능을 하는 컴포넌트라도 다양한 방식으로 작성될 수 있다. 되도록 컴포넌트를 작성하는 사람 입장에서는 유지 보수하기 쉬운 코드를, 컴포넌트를 사용하는 사람 입장에서는 컴포넌트의 인터페이스를 쉽게 파악할 수 있는 코드를 작성하는게 좋다.

<br/>

## 추천하는 컴포넌트 파일 작성법

컴포넌트 파일에는 다양한 종류의 함수와 변수가 등장함. 그로 인해 코드의 가독성이 떨어지고 관리가 힘들어질 수 있다. 가독성과 생산성을 높이기 위해 코드를 어떻게 배치하면 좋을지 알아보자.

### 컴포넌트 파일 작성 순서

```jsx
MyComponent.propType = {  // ☄️
  // ...
}

export default function MyComponent({ prop1, prop2 }) {  // 🌊
  // ...
}

// 🚀
const COLUMNES = [
  { id: 1, name: 'phoneNumber', width: 200, color: 'white' },
  { id: 2, name: 'city', width: 100, color: 'grey' },
  // ...
];

const URL_PRODUCT_LIST = '/api/products';
function getTotalPrice({ price, total }) {
  // ...
}
```

- ☄️ : 파일의 최상단에는 `propTypes(속성값 타입)`를 정의. 속성값 타입이 가장 먼저 오는 이유는 컴포넌트를 사용하는 입장에서 생각하면 쉽게 이해된다. 컴포넌트를 사용하기 위해서는 그 컴포넌트의 propType을 알아야 하므로 파일을 열었을 때, propType이 가장 먼저 보이는게 좋음. 또 작성자 입장에서도 propType은 아주 중요. 따라서 propType 위에는 import 구문만 오게 하자.
- 🌊 : 컴포넌트 함수의 매개변수는 명명된 매개변수로 정의하는게 좋다.(props 말고 `{val1, val2}` 요런식.) `props.` 을 입력하지 않아도 됌. 그리고 컴포넌트 이름을 꼭 작성. function() 처럼 이름이 없는 컴포넌트로 만들면 리액트 개발자 도구에서 디버깅이 힘들다.
- 🚀 : 컴포넌트 바깥의 변수와 함수는 파일의 가장 밑에 정의. 변수는 상수 변수(`const`)로 정의. 그리고 상수 변수의 이름은 대문자가 좋음. 컴포넌트 내부에서 커다란 객체를 생성하는 코드가 있을 때, 가능하면 컴포넌트 외부에서 상수 변수로 정의해서 사용하도록 하자. 그래야 렌더링 시 불필요한 객체 생성을 피할 수 있어 성능상 이점이 있음.

---

### 서로 연관된 코드를 한 곳으로 모으기

여러 가지 기능이 섞여 있는 코드르 ㄹ어떻게 배치하면 좋을지 다음 코드를 통해 알아보자.

```jsx
function Profile({ userId }) {
  const [user, setUser] = useState(null);  // 🌈
  const [width, setWidth] = useState(window.innerWidth);  // 🌈
  useEffect(() => {
    getUserApi(userId).then(data => setUser(data));
  }, [userId]);
  useEffect(() => {
    const onResize = () => setWidth(window.innerWidth);
    window.addEventListener('resize', onResize);
    return () => {
      window.removeEventListener('resize', onResize);
    };
  }, []);
  // ...
}
```

- 🌈 : 모든 state 값을 컴포넌트 함수 상단에서 정의함. 그리고 모든 useEffect 훅을 state 코드 밑에 정의하고 있다.

위의 코드에는 사용자 정보를 가져오는 기능과 창의 너비를 가져오는 기능이 섞여있음. 다음은 각 기능별로 코드를 모아놓은 코드다.

```jsx
function Profile({ userId }) {
  const [user, setUser] = useState(null);  // 👻
  useEffect(() => {
    getUserApi(userId).then(data => setUser(data));
  }, [userId]);
  
  const [width, setWidth] = useState(window.innerWidth);  // 🚀
  useEffect(() => {
    const onResize = () => setWidth(window.innerWidth);
    window.addEventListener('resize', onResize);
    return () => {
      window.removeEventListener('resize', onResize);
    };
  }, []);
  // ...
}
```

- 👻 : 사용자 정보를 가져오는 기능을 한 곳으로 모았다.
- 🚀 : 마찬가지로 창의 너비를 가져오는 기능을 한 곳으로 마았다.

즉, 이렇게 기능 단위로 코드를 모아두면 가독성이 좋아진다. 훅의 종류별로 모으기 보다, 연관된 코드끼리 모으는게 좋다. 만약 컴포넌트 코드가 복잡하다고 느껴진다면 각 기능을 커스텀 훅으로 분리하는 것도 좋은 방법이다. 분리해보자.

```jsx
function Profile({ userId }) {
  const user = useUser(userId);    // 📌
  const width = useWindowWidth();  // 📌
  // ...
}

function useUser(userId) {  // 💧
  const [user, setUser] = useState(null);
  useEffect(() => {
    getUserApi(userId).then(data => setUser(data));
  }, [userId]);
  return user;
}

function useWindowWidth() {  // 💧
  const [width, setWidth] = useState(window.innerWidth);
  useEffect(() => {
    const onResize = () => setWidth(window.innerWidth);
    window.addEventListener('resize', onResize);
    return () => {
      window.removeEventListener('resize', onResize);
    };
  }, []);
  return width;
}
```

- 📌 : 각 기능을 커스텀 훅으로 분리하면 Profile 컴포넌트 코드는 가독성이 좋아짐.
- 💧 : 각 기능을 커스텀 훅으로 분리함.

기능을 커스텀 훅으로 분리하면 같은 기능을 다른 곳에서도 사용하기 좋다. 기능을 재사용하는 곳이 없다고 하더라도 컴포넌트 코드가 복잡해지면 커스텀 훅으로 분리하자. 다만 컴포넌트 코드가 복잡하지 않은 경우네는 커스텀 훅이 오히려 가독성을 떨어뜨릴 수 있으니 필요하다고 판단되는 경우에만 분리하도록 하자.

<br/>

## 속성값 타입 정의하기: prop-types

prop-types 는 속성값 타입 정보를 정의할 때 사용하는 리액트 공식 패키지. 타입 정보는 컴포넌트 코드의 가독성을 위해 필수로 작성하는 게 좋다. Javascript는 동적 타입 언어. 간단 프로그램을 작성할 때는 생산성이 좋다. 하지만 파일이 50개가 넘어가는 규모의 프로그램을 작성할 때는 오히려 생산성이 떨어짐. 그래서 가능하면 정적 타입언어(예. typescript) 를 사용하는게 좋다.

prop-types를 사용할 경우 컴포넌트 사용시 속성 값에 잘못된 타입이 입력되면 콘솔에 에러메세지가 출력됨. 이는 리액트가 렌더링하는 과정에서 잘못된 속성값타입을 검사해주기 때문에 가능함. 물론 속성값 타입을 검사하기 위해 별도의 연산이 필요하므로 타입 검사는 개발 모드에서만 동작함.

또다른 장점은 타입 정의 자체가 훌륭한 문서가 된다는 점. 만약 속성값 타입 정보가 없다면 컴포넌트를 사용하는 사람 입장에서는 속성값의 정보를 파악하기 위해 코드를 일일이 들여다봐야함.

다음은 속성값 타입 정보를 입력하지 않은 컴포넌트다.

```js
function User({ type, age, male, onChangeName, onChangeTitle }) {
  function onClick1() {
    const msg = `type: ${type}, age: ${age ? age : '알 수 없음'}`;
    log(msg, { color: type === 'gold' ? 'red' : 'black' });
    // ...
  }
  
  function onClick2(name, title) {
    if (onChangeName) {
      onChangeName(name);
    }
    onChangeTitle(title);
    male ? goMalePage() : goFemalePage();
    // ...
  }
  // ...
}
```

각 속성 값의 타입이 무엇인지는 코드를 자세히 들여다보기 전까지 알기 힘듦.

다음은 prop-types 를 이용해 위의 코드에 타입 정보를 추가한 코드. 컴포넌트의 로직을 이해하지 않고도 속성값의 타입 정보를 한눈에 파악할 수 있다.

```js
User.propTypes = {
  male: PropTypes.bool.isRequired,     // 📌 1
  age: PropTypes.number,     // 📌 2
  type: PropTypes.oneOf(['gold', 'silver', 'bronze']),     // 📌 3
  onChangeName: PropTypes.func,     // 📌 4
  onChangeTitle: PropTypes.func.isRequired,
}
```

- 📌 1 : male 속성 값은 필숫값이기 때문에 부모 컴포넌트에서 이 값을 주지 않으면 에러 메세지 출력.
- 📌 2 : 반대로 age 속성 값은 노필수값. 안줘도 에러 발생 노.
- 📌 3 : type 속성 값에는 gold, silver, bronze 중의 하나만 입력가능.
- 📌 4 : 여기서 한 가지 부족한 타입 정보는 onChangeName 과 같은 함수 타입이다. prop-types 에서 함수의 매개변수와 반환 값에 대한 타입 정보는 정의할 수 없음. 이 경우에는 문서화를 위해 타입 정보를 주석으로 자세히 적기를 추천.

---

### prop-types로 정의할 수 있는 타입

```jsx
MyComponent.propTypes = {
  // 리액트 요소
  // <div>hello<div> => 참
  // <SomeComponent /> => 참
  // 123 => 거짓
  menu: PropTypes.element,
  
  // 컴포넌트 함수가 반환할 수 있는 모든 것
  // number, string, array, element, ...
  // <SomeComponent /> => 참
  // 123 => 참
  description: PropTypes.node,
  
  // Message 클래스로 생성된 모든 객체
  // new Messages() => 참
  // new Car() => 거짓
  message: PropTypes.instanceOf(Message),
  
  // 배열에 포함된 값 중에서 하나를 만족
  // 'jone' => 참
  // 'messy' => 거짓
  name: PropTypes.oneOf(['jone', 'hst']),
  
  // 배열에 포함된 타입 중에서 하나를 만족
  // 123 => 참
  // 'messy' => 참
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  
  // 특정 타입만 포함하는 배열
  // [1, 5, 7] => 참
  // ['a', 'b'] => 거짓
  ages: PropTypes.arrayOf(PropTypes.number),
  
  // 객체의 속성값 타입을 정의
  // { color: 'red'. weight: 123 } => 참
  // { color: 'red'. weight: '123kg' } => 거짓
  info: PropTypes.shape({
    color: PropTypes.string,
    weight: PropTypes.number
  }),
  
  // 객체에서 모든 속성값의 타입이 같은 경우
  // { prop1: 123, prop2: 456 } => 참
  // { prop1: 'red', prop2: 123 } => 거짓
  infos: PropTypes.objectOf(PropTypes.number)
}
```

이처럼 prop-types 가 제공하는 타입 정의 함수를 이용하면 웬만한 타입 정보는 표현할 수 있다. 그리고 다음과 같이 본인만의 타입 함수를 작성할 수도 있다.

```js
MyComponent.propTypes = {
  age: function(props, propName, componentName) {
    const value = props[propName];
    if (value < 10 || value > 20) {   // 🚀
      return new Error(   // 🔥
        `Invalid prop ${propName} supplied to ${componentName}.
         It must be 10 <= value <= 20`
      );
    }
  }
};
```

- 🚀 : age 속성 값의 타입은 10 이상, 20 이하인 숫자로 정의.
- 🔥 : 조건에 맞지 않는 값이 들어오면 에러 반환.

<br/>

## 가독성을 높이는 조건부 렌더링 방법

