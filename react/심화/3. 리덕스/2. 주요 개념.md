# 주요 개념

- 액션 -> 미들웨어 -> 리듀서 -> 스토어 -> 뷰 -> 액션

뷰는 리액트 컴포넌트라고 생각할 수 있다. 상탯값을 변경하는 과정에서 거치는 네가지 요소(액션, 미들웨어, 리듀서, 스토어)를 순서대로 보자.

<br/>

## 액션

액션은 `type` 속성값을 가진 자바스크립트다. 액션 객체를 `dispatch` 함수에 넣어 호출하면 리덕스는 상탯값을 변경하기 위해 위의 과정을 거친다. 액션 객체에는 type 값 외에도 원하는 속성값을 얼마든지 넣을 수 있음.

```js
store.dispatch({ type: 'ADD', title: '영화보기', priority: 'high' });  // 🔥
store.dispatch({ type: 'REMOVE', id: 123 });
store.dispatch({ type: 'REMOVE_ALL' });
```

- 🔥 : 각 액션은 고유한 type을 사용해야하는데, `ADD` 라는 단어 하나만으로는 중복 가능성이 높다. type 이름 충돌을 피하기 위해 다음과 같이 접두사를 붙이는 방법을 많이 사용함.

```js
store.dispatch({ type: 'todo/ADD', title: '영화보기', priority: 'high' });
store.dispatch({ type: 'todo/REMOVE', id: 123 });
store.dispatch({ type: 'todo/REMOVE_ALL' });
```

dispatch 메서드를 호출할 때 직접 액션 객체를 입력하는 방법은 사용하지 않는게 좋다. 'todo/ADD' 액션의 경우 title, priority 라는 두 속성 값이 **항상 존재하도록 강요할 필요가 있다**. 이는 다음과 같이 액션 생성자 함수를 이용해 해결할 수 있다.

```js
// 🌈
function addTodo({ title, priority }) {
  return { type: 'todo/ADD', title, priority };
}
function removeTodo({ id }) {
  return { type: 'todo/REMOVE', id };
}
function removeAllTodo() {
  return { type: 'todo/REMOVE_ALL' };
}

// 🌊
store.dispatch(addTodo({ title: '영화보기', priority: 'high' }));
store.dispatch(removeTodo({ id: 123 }));
store.dispatch(removeAllTodo({ id: 123 }));
```

- 🌈 : 세개의 액션 생성자 함수를 정의함. 액션 생성자 함수를 필요한 인수와 함께 호출하면 항상 같은 구조의 액션 객체가 만들어짐. 나중에 액션 객체의 구조를 변경할 때는 액션 생성자 함수만 수정하면 된다.
- 🌊 : dispatch 메서드를 호출할 때는 액션 생성자 함수를 이용한다.

type 값은 리듀서에서 액션 객체를 구분할 때도 사용되기 때문에 상수 변수로 만드는게 좋다.

```js
// 🔥
export const ADD = 'todo/ADD';
export const REMOVE = 'todo/REMOVE';
export const REMOVE_ALL = 'todo/REMOVE_ALL';

// 👻
export function addTodo({ title, priority }) {
  return { type: 'ADD', title, priority };
}
export function removeTodo({ id }) {
  return { type: 'REMOVE', id };
}
export function removeAllTodo() {
  return { type: 'REMOVE_ALL' };
}
```

- 🔥 : type 이름을 상수 변수로 만들었음. 이 변수는 리듀서에서도 필요하기 때문에 `export` 로 외부에 노출한다.
- 👻 : 액션 생성자 함수도 외부에서 호출해야 하므로 외부로 노출한다.

앞에서 살펴본 리덕스 세 가지 원칙에 위배되지 않으므로 액션 생성자 함수에서는 부수 효과를 발생시켜도 괜찮다. 예를 들어 addTodo 함수에서 새로운 할 일을 서버에 저장하기 위해 API 호출을 할 수 있다. 액션 생성자 함수에서 API 호출과 같은 비동기 코드를 제어할 수 있다.

<br/>

## 미들웨어

미들웨어(middleware)는 리듀서가 액션을 처리하기 전에 실행되는 함수다. 디버깅 목적으로 상탯값 변경 시 로그를 출력하거나, 리듀서에서 발생한 예외를 서버로 전송하는 등의 목적으로 미들웨어를 활용할 수 있다. 리덕스 사용 시 특별히 미들웨어를 설정하지 않는다면 발생한 액션을 곧바로 리듀서로 보내진다.

```js
const myMiddleware = store => next => action => next(action);
```

위 구조로 되어있다. 함수 세개가 중첩된 구조. 화살표 함수가 연속으로 표현된 코드가 익숙지 않다면 헷갈릴 수 있음.

```js
const myMiddleware = function(store) {
  return function(next) {
    return function(action) {
      return next(action);
    };
  };
};
```

미들웨어는 스토어와 액션 객체를 기반으로 필요한 작업을 수행할 수 있다. `next` 함수를 호출하면 다른 미들웨어 함수가 호출되면서 최종적으로 리듀서 함수가 호출된다. 위 코드는 아무런 작업도 하지 않고 next 함수를 호출할 때문에 무의미한 미들웨어 함수다.

다음은 미들웨어를 사용하기 위해 리덕스를 설정하는 코드임.

```jsx
import { createStore, applyMiddleware } from 'redux';
// 🔥
const middleware1 = store => next => action => {
  console.log('middleware1 start');
  const result = next(action);
  console.log('middleware1 end');
  return result;
}
const middleware2 = store => next => action => {
  console.log('middleware2 start');
  const result = next(action);
  console.log('middleware2 end');
  return result;
}

const myReducer = (state, action) => {  // 💧
  console.log('myReducer');
  return state;
}
const store = createStore(myReducer, applyMiddleware(middleware1, middleware2));  // 🌈
store.dispatch({ type: 'someAction' });  // 🚀
```

- 🔥 : 간단한 두 개의 미들웨어를 정의함.

- 💧 : 아무일도 일어나지 않는 리듀서 정의.

- 🌈 : applyMiddleware 함수를 이용, 미들웨어가 입력된 스토어를 생성했다.

- 🚀 : 이 코드에 의해 출력되는 로그를 순서대로 나열하면 다음과 같다.

  ```js
  middleware1 start
  middleware2 start
  myReducer
  middleware2 end
  middleware1 end
  ```

middleware1 에서 호출한 next 함수는 middleware2 함수를 실행한다. middleware2 에서 호출한 next 함수는 스토어가 원래 갖고 있던 dispatch 메서드를 호출한다. 최종적으로 스토어의 dispatch 메서드는 리듀서를 호출한다. 각 미들웨어에서는 리듀서 호출 전 후에 필요한 작업을 정의할 수 있다.

📌 리덕스의 `applyMiddleware` 함수

다음 간소화된 코드를 살펴보자.

```js
const applyMiddleware = (...middlewares) => createStore => (...args) => {
  const store = createStore(...args);  // 👻
  const funcsWithStore = middlewares.map(middleware => middleware(store));  // 🚀
  const chainedFunc = funcsWithStore.reduce((a, b) => next => a(b(next)));  //💧
  
  return { 
    ...store, 
    dispatch: chainedFunc(store.dispatch),  // 🌈
  };
};
```

- 👻 : 입력된 createStore 함수를 호출해서 스토어를 생성한다.
- 🚀 : 생성된 스토어와 함께 모든 미들웨어의 첫 번째 함수를 호출한다. 첫 번째 함수를 호출하면 next 매개변수를 갖는 두 번째 함수가 만들어진다. funcWithStore의 모든 함수는 클로저를 통해서 store 객체에 접근할 수 있다.
- 💧 : 모든 미들웨어의 두번째 함수를 체인으로 연결했다. 만약 미들웨어가 세개였다면 chainedFunc 함수는 next => a(b(c(next)))
- 🌈 : 외부에 노출되는 스토어의 dispatch 메서드는 미들웨어가 적용된 버전으로 변경된다. 만약 미들웨어가 두개였다면, a(b(store.dispatch))와 같다. 따라서 사용자가 dispatch 메서드를 호출하면 첫 번째 미들웨어 함수부터 실행된다. 그리고 마지막 미들웨어가 store.dispatch 메서드를 호출한다.

다음은 리덕스 스토어의 dispatch 메서드를 간소화한 코드다.

```js
function dispatch(action) {
  currentState = currentReducer(currentState, action);  // 🔥
  for(let i = 0; i < listeners.length; i++) {
    listeners[i]();  // 🌔
  }
  return action;
}
```

- 🔥 : 리듀서 함수를 호출해서 상탯값을 변경한다.
- 🌔 : dispatch 메서드가 호출될 때마다 등록된 모든 이벤트 처리 함수를 호출한다. 상탯값이 변경되지 않아도 이벤트 처리 함수를 호출하는 것을 주목하자. 상탯값 변경을 검사하는 코드는 각 이벤트 처리 함수에서 구현해야 한다. 참고로 react-redux 패키지의connect 함수에서는 자체적으로 상탯값 변경을 검사한다.

