# 원인 분석

다음과 같은 상황에서 리렌더링이 발생한다.

1. 자신이 전달받은 props가 변경될 때
2. 자신의 state가 바뀔 때
3. 부모 컴포넌트가 리렌더링될 때
4. forceUpdate 함수가 실행될 때

<br/>

## React.memo

컴포넌트의 리렌더링을 방지할 때는 `shouldComponentUpdate` 라는 라이프사이클을 사용하면 됨. 그런데 함수형 컴포넌트에서는 `React.memo` 라는 함수를 사용함. 컴포넌트의 props가 바뀌지 않았다면 리렌더링하지 않도록 설정하여 함수형 컴포넌트의 리렌더링 성능을 최적화해 줄 수 있다.

컴포넌트를 만들고 나서 감싸 주기만 하면 됨.

```jsx
import React from 'react';
...

const TodoListItem = ({ todo, onRemove, onToggle }) => {
  ...
};

export default React.memo(TodoListItem);   // 여기
```

이렇게.

```jsx
import React, { memo } from 'react';   // 여기
...

const TodoListItem = memo(({ todo, onRemove, onToggle }) => {   // 여기
  ...
});

export default TodoListItem;
```

이렇게 해줘도 됨. todo, onRemove, onToggle이 바뀌지 않으면 리렌더링 하지 않음. 그러면 onRemove, onToggle 을 새롭게 바뀌지 않게 하려면 어떻게 해야할까?

<br>

## 함수가 계속 만들어지는 상황 방지

1. useState의 함수형 업데이트 기능 사용
2. useReducer 사용

### 1. useState의 함수형 업데이트 기능 사용

기존에 setTodos 함수를 사용할 때는 새로운 상태를 파라미터로 넣어주었다. setTodos를 사용할 때 새로운 상태를 파라미터로 넣는 대신, 상태 업데이트를 어떻게 할지 정의해주는 업데이트 함수를 넣을 수도 있다. 이를 함수형 업데이트라 함.

```jsx
const [number, setNumber] = useState(0);

// prevNumbers는 현재 number를 가리킨다.
const onIncrease = useCallback(
  () => setNumber(prevNumber => prevNumber + 1),
  [],
);
```

`setNumber(number + 1)` 을 하는 것이 아니라, 어떻게 업데이트 해주어야 할지 정의해주는 업데이트 함수를 넣어준다. 그러면 useCallback 을 사용할 때 두번째 파라미터로 넣는 배열에 number를 넣지 않아도 됨.

