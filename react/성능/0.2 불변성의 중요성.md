# 불변성의 중요성

```jsx
const [todos, setTodos] = useState(createBulkTodos);

const onToggle = useCallback((id) => {
  setTodos((todos) =>
    todos.map((todo) =>
      todo.id === id ? { ...todo, checked: !todo.checked } : todo,
    ),
  );
}, []);
```

이걸 보자. 기존 데이터를 수정할 때 직접 수정하지 않고, 새로운 배열을 만든 다음에 새로운 객체를 만들어서 필요한 부분을 교체해주는 방식으로 구현했음. 업데이트가 필요한 곳에서는 아예 새로운 배열 혹은 새로운 객체를 만들기 때문에 React.memo를 사용했을 때 props가 바뀌었는지 혹은 바뀌지 않았는지를 알아내서 리렌더링 성능을 최적화해 줄 수 있다.

이렇게 기존 값을 직접 수정하지 않으면서 새로운 값을 만들어 내는 것을 **불변성을 지킨다**고 표현함. 예시를 보자.

```javascript
const array = [1, 2, 3, 4, 5];

const nextArrayBad = array;   // 배열 복사가 아니라 똑같은 배열을 가리킴.
nextArrayBad[0] = 100;
console.log(array === nextArrayBad);   // 완전히 같은 배열을 가리키고 있기 때문에 true.

const nextArrayGood = [...array];   // 배열 내부의 값을 모두 복사한다.
nextArrayGood[0] = 100;
console.log(array === nextArrayGood);  // 다른 배열이기 때문에 false.
```

```javascript
const obj = { foo: 'bar', value: 1 };

const nextObjBad = obj;   // 객체가 복사되지 않고, 똑같은 객체를 가리킴.
nextObjBad.value = nextObjBad.value + 1;
console.log(obj === nextObjBad);   // 같은 객체이기 때문에 true.

const nextObjGood = { 
  ...obj,   // 기존에 있던 내용을 모두 복사해서 넣는다.
  value: obj.value + 1   // 새로운 값을 덮어쓴다.
};
console.log(obj === nextObjGood);   // 다른 객체이기 때문에 false.
```

- Bad : 불변성이 지켜지지 않음. 기존 객체를 재사용했기 때문.
- Good : 불변성이 지켜짐. 새로운 객체를 넣어줬기 때문.

불변성이 지켜지지 않으면 객체 내부의 값이 새로워져도 바뀐 것을 감지 하지 못함. 그러면 React.memo 에서 서로 비교해서 최적화하는 것이 불가능해짐.

추가로 전개 연산자( ... 문법 )를 사용해 객체나 배열 내부의 값을 복사할 때는 얕은 복사(shallow copy)를 하게 된다. 즉, 내부의 값이 완전히 새로 복사되는 것이 아니라 가장 바깥쪽에 있는 값만 복사됨. 따라서 내부의 값이 객체 혹은 배열이라면 내부의 값 또한 따로 복사해주어야 함. 📌 [Object 가변성(Spread Operator)정리](https://github.com/pozafly/TIL/blob/main/react/%EA%B8%B0%EB%B3%B8/99.0%20Object%20%EA%B0%80%EB%B3%80%EC%84%B1(Spread%20Operator).md) 여길 보자.

```javascript
const todos = [{ id: 1, checked: true }, { id: 2, checked: true }];
const nextTodos = [...todos];   // 배열 껍데기는 바뀌었지만, {} 객체는 같은 값을 가리키고 있다.

nextTodos[0].checked = false;
console.log(todos[0] === nextTodos[0]);   // 아직까지는 똑같은 객체를 가리키고 있기 때문에 true.

nextTodos[0] = {
  ...nextTodos[0],
  checked: false,
};
console.log(todos[0] === nextTodos[0]);   // 새로운 객체를 할당해 주었기에 false
```

만약 객체 안에 있는 객체라면 불변성을 지키면서 새 값을 할당해야 하므로 아래와 같이 해줘야 함.

```javascript
const nextComplexObj = {
  ...complexObj,
  objInside: {
    ...complexObj.ojbInside,
    enabled: false,
  }
};
console.log(complexObj === nextComplexObj);   // false
console.log(complexObj.objInside === nextComplexObj.objInside);   // false
```

배열 혹은 객체의 구조가 이렇게 복잡해지면 불변성을 유지하면서 업데이트 하는 것도 까다로워짐. 이렇게 복잡한 상황일 경우 immer라는 라이브러리의 도움을 받으면 편하게 작업할 수 있다.