# 코드 분할

## 번들링

대부분 React 앱들은 `Webpack`, `Rollup`, 또는 `Browserify` 같은 툴을 사용해 여러 파일을 하나로 병합한 '번들 된' 파일들을 웹 페이지에 포함해 한 번에 전체 앱을 로드할 수 있다.

### 예시

- App

```js
// app.js
import { add } from './math.js';

console.log(add(16, 26));  // 42
```

```js
// math.js
export function add(a, b) {
  return a + b;
}
```

- Bundle

```js
function add(a, b) {
  return a + b;
}
console.log(add(16, 26));  // 42
```

실제 번들은 위 코드와 많이 다름.

Create React App 이나, Next.js, Gatsby 혹은 비슷한 툴을 사용하면 설치한 앱에서 Webpack이 같이 설치될 것임.

<br/>

## 코드 분할

번들링은 훌륭하지만 앱이 커지면 번들도 커짐. 특히 큰 규모의 서드 파티 라이브러리를 추가할 때 실수로 앱이 커져 로드 시간이 길어지는 것을 방지하기 위해 코드를 주의 깊게 살펴야 함.

번들이 거대해지는 것을 방지하기 위한 좋은 해결법은 번들을 '나누는' 것임. **코드 분할**은 런타임에 여러 번들을 동적으로 만들고 불러오는 것으로, `Webpack`, `Rollup`, 또는 `Browserify` 같은 번들러가 지원하는 것이다.

코드 분할은 앱을 `지연 로딩` 하게 도와주고, 앱 사용자에게 획기적인 성능 향상을 하게 함. 앱의 코드 양을 줄이지 않고도 사용자가 필요하지 않은 코드를 불러오지 않게 하며 앱의 초기화 로딩에 필요한 비용을 줄여줌.

<br/>

## import()

앱에 코드 분할을 도입하는 가장 좋은 방법은 동적 `import()` 문법을 사용하는 방법임.

### Before

```js
import { add } from './math.js';

console.log(add(16, 26));  // 42
```

### After

```js
import("./math").then(math => {
  console.log(math.add(16, 26));
});
```

Webpack이 이 구문을 만나게 되면 앱의 코드를 분할한다. CRA를 사용한다면 이미 Webpack의 구성이 되어있기 때문에 [사용](https://create-react-app.dev/docs/code-splitting/)할 수 있음. [Next.js](https://nextjs.org/docs/advanced-features/dynamic-import) 역시 지원함.

[코드 분할 가이드](https://webpack.js.org/guides/code-splitting/)를 참조. Webpack 설정은 [가이드](https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269)에 있다.

[Babel](http://babeljs.io/)을 사용할 때는 Babel이 동적 import를 인식할 수 있지만 변환하지는 않도록 한다. 이를 위해 [babel-plugin-syntax-dynamic-import](https://yarnpkg.com/en/package/babel-plugin-syntax-dynamic-import)를 사용해야함.

<br/>

## React.lazy

---

📌 주의점 (작성시점 : 2021/3/24)

`React.lazy` 와 Suspens는 아직 SSR을 사용할 수 없음. SSR된 앱에서 코드 분할을 하기 원하면, [Loadable Components](https://github.com/gregberge/loadable-components)를 추천. 이는 [서버 사이드 렌더링과 번들 스플리팅에 대한 좋은 가이드](https://loadable-components.com/docs/server-side-rendering/)임.

---

`React.lazy` 함수를 사용하면 동적 import를 사용해 컴포넌트를 렌더링할 수 있음.

### Before

```js
import OtherComponent from './OtherComponent';
```

### After

```js
const OtherComponent = React.lazy(() => import('./OtherComponent'));
```

component가 처음 렌더링 될 때, `OtherComponent` 를 포함한 번들을 자동으로 불러온다.

`React.lazy` 는 동적 `import()` 를 호출하는 함수를 인자로 가진다. 이 함수는 React 컴포넌트를 포함하여 `default` export 를 가진 모듈로 결정되는 `Promise` 로 반환 해야한다.

lazy 컴포넌트는 `Suspense` 컴포넌트 하위에서 렌더링 되어야 하며, `Suspense` 는 lazy 컴포넌트가 로드 되길 기다리는 동안 로딩 화면과 같은 예비 컨텐츠를 보여줄 수 있게 해준다.

```jsx
import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>  // 🚀
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```

- 🚀 : `fallback` prop은 컴포넌트가 로드될 때까지 기다리는 동안 렌더링 하려는 React 엘리먼트를 받아들인다. `Suspense` 컴포넌트는 lazy 컴포넌트를 감싼다. 

하나의 Suspense 컴포넌트로 여러 lazy 컴포넌트를 감쌀 수 있다.

```jsx
import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));
const AnotherComponent = React.lazy(() => import('./AnotherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <section>
          <OtherComponent />
          <AnotherComponent />
        </section>
      </Suspense>
    </div>
  );
}
```

### Error boundaries

네트워크 장애 같은 이유로 다른 모듈을 로드에 실패할 경우 에러를 발생시킬 수 있다. 이때, `Error Boundaries` 를 이용하여 사용자의 경험과 복구 관리를 처리할 수 있다. Error Boundary를 만들고 lazy 컴포넌트를 감싸면 네트워크 장애가 발생했을 때 에러를 표시할 수 있다.

```jsx
import React, { Suspense } from 'react';
import MyErrorBoundary from './MyErrorBoundary';

const OtherComponent = React.lazy(() => import('./OtherComponent'));
const AnotherComponent = React.lazy(() => import('./AnotherComponent'));

const MyComponent = () => (
  <div>
    <MyErrorBoundary>
      <Suspense fallback={<div>Loading...</div>}>
        <section>
          <OtherComponent />
          <AnotherComponent />
        </section>
      </Suspense>
    </MyErrorBoundary>
  </div>
);
```

