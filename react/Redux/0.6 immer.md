# immer

리듀서에서 상태를 업데이트 할 때 불변성을 지켜야 하기 때문에 immer를 쓰기 전에는 spread 연산자와 배열의 내장 함수를 이용했다. 그러나 모듈의 상태가 복잡해질 수록 불변성을 지키기가 까다로워짐.

```sh
$ yarn add immer
```

redux-actions 가 적용되어 있는 todos 모듈에 적용해보자.

```js
// modules/todos.js

//...

const todos = handleActions(
  {
    [CHANGE_INPUT]: (state, { payload: input }) =>
      // ({ ...state, input })
      produce(state, (draft) => {
        draft.input = input;
      }),
    [INSERT]: (state, { payload: todo }) =>
      // ({
      //   ...state,
      //   todos: state.todos.concat(todo),
      // }),
      produce(state, (draft) => {
        draft.todos.push(todo);
      }),
    [TOGGLE]: (state, { payload: id }) =>
      // ({
      //   ...state,
      //   todos: state.todos.map((todo) =>
      //     todo.id === id ? { ...todo, done: !todo.done } : todo,
      //   ),
      // }),
      produce(state, (draft) => {
        const todo = draft.todos.find((todo) => todo.id === id);
        todo.done = !todo.done;
      }),
    [REMOVE]: (state, { payload: id }) =>
      // ({
      //   ...state,
      //   todos: state.todos.filter((todo) => todo.id !== id),
      // }),
      produce(state, (draft) => {
        const index = draft.todos.findIndex((todo) => todo.id === id);
        draft.todos.splice(index, 1);
      }),
  },
  initialState,
);
```

immer를 사용한다고 해서 모든 업데이트 함수에 immer를 적용할 필요는 없음. 일반 자바스크립트로 처리하는 것이 더 편할 때는, immer를 적용하지 않아도 됨. 예를 들어 위 코드에서 TOGGLE을 제외한 업데이트 함수들을 immer를 쓰지 않는 코드가 오히려 더 짧기 때문에 이전 형태를 유지하는 것도 무방함.