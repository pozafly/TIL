# TCP

- Transmission Control Protocol
- 신뢰성 중심
- 데이터를 전송 전 TCP 커넥션이라는 논리적 통신 경로를 만들어 통신 환경 구축함.

보냅니다!, 받았습니다! 서로 확인하면서 데이터를 전송함.

![[Pasted image 20260120005856.png]]

- 어플리케이션 데이터를 TCP 페이로드로, TCP 헤더를 붙이고, TCP 세그먼트로 만듦.

## TCP 패킷 형식

![[Pasted image 20260120005956.png]]

### 발신자/목적지 포트 번호

- 발신자 포트 번호: OS가 무작위로 할당된 값
- 목적지 포트 번호: 어플리케이션 포트 번호

### 시퀀스 번호

- TCP 세그먼트를 올바른 순서로 정렬하는데 사용되는 4바이트 필드.
- 발신 단말은 어플리케이션으로부터 받은 데이터 각 바이트에 '초기 시퀀스 번호'(ISN, Initial Sequence Number) 부터 차례로 일련번호 부여함.
- 수신 단말은 TCP 세그먼트 시퀀스 번호 확인 후 순서대로 정렬 후 어플리케이션에 전달.

![[Pasted image 20260120134836.png]]

- 시퀀스 번호는 3방향 핸드셰이크 시 임의의 값이 초기 시퀀스 번호로 설정
- TCP 세그먼트를 전송한 바이트 수만큼 추가.
- 4바이트로 관리할 수 있는 데이터 양을 초과하면 0으로 돌아가 카운트 업 됨.

![[Pasted image 20260120134948.png]]

### 확인 응답 번호

- '확인 응답 번호'(ACK 번호, Acknowledge 번호)는 다음 데이터를 보내주세요라고 상대에게 전달하는 4바이트 필드.
- 제어 비트의 ACK 플래그가 1일 때만 활성화되는 필드.
- 수신한 데이터의 `시퀀스 번호(마지막 바이트의 시퀀스 번호) + 1`, 즉 '시퀀스 번호 + 어플리케이션 데이터의 길이'가 설정되어 있다.
- TCP는 시퀀스 번호와 확인 응답 번호(ACK 번호)를 연동해 데이터의 신뢰성을 보장함.

![[Pasted image 20260120135156.png]]

### 데이터 오프셋

- TCP 헤더의 길이를 나타내는 4비트 필드.

### 제어 비트

- 연결 상태를 제어하는 필드.

![[Pasted image 20260120135312.png]]

### 윈도으 크기

- 수신할 수 있는 데이터 크기를 알려주는 필드.
- 이 정도까지는 받을 수 있다는 식.
- 0은 더이상 수신할 수 없음을 나타냄.

### 체크섬

- 손상 여부 확인 2바이트 필드
- 1의 보수 연산이 사용됨.

### 비상 포인터

- 제어 비트의 URG 플래그가 '1'일 때만 유효한 2바이트
- 긴급 데이터가 있을 때 긴급 데이터를 나태내는 마지막 바이트의 시퀀스 번호가 설정

### 옵션

- 확장 기능을 서로에게 알리기 위해 사용
- 종류에 따라 몇 옵션을 목록으로 나열하는 성태
- OS와 그 버전에 따라 달라짐
- MSS, SACK가 중요함.

![[Pasted image 20260120135536.png]]

#### MSS (Maximum Segment Size)

- TCP 페이로드(애플리케이션 데이터)의 최대 크기

![[Pasted image 20260120135636.png]]

#### SACK(Selective Acknowledgment)

- 사라진 TCP 세그먼트만 재전송하는 기능.
- ACK으로 판단하는데 TCP 세그먼트가 손실된 경우 손실 데이터 이후 모든 세그먼트를 재전송해야 하는 비효율성을 갖고 있음.
- SACK을 지원하면 부분적으로 '어디서부터 어디까지 받았는지' 범위를 옵션 필드로 알려주게 됨.

![[Pasted image 20260120135813.png]]

## TCP의 상태 전이

![[Pasted image 20260120135907.png]]

### 커넥션 시작 단계

- 3방향 핸드셰이크로 커넥션을 여는 것으로 시작
- 서로가 지원하는 기능과 시퀀스 번호를 결정하고 '오픈'이라는 사전 준비
	- 액티브 오픈: 오픈 처리에서 커넥션을 만들러가는 쪽 (클라이언트)의 처리
	- 패시브 오픈: 커넥션을 받아들이는 쪽(서버)의 처리

1. 3방향 핸드셰이크를 시작하기 전에 클라이언트는 `CLOSED`, 서버는 `LISTEN` 상태다. `CLOSED`는 커넥션이 완전히 닫힌 상태, 즉 아무것도 하지 않는 상태이고, `LISTEN`은 클라이언트의 커넥션을 기다리는 상태다.
   예를 들어, 웹 브라우저(웹 클라이언트)에서 웹 서버에 HTTP로 접속하는 경우, 웹 브라우저는 웹 서버에 접속하지 않는 한 `CLOSED` 상태다. 이에 반해 웹 서버는 기본적으로 80번을 `LISTEN`으로 설정하여 커넥션을 받을 수 있도록 하고 있다.

2. 클라이언트는 SYN 플래그를 `1`로, 시퀀스 번호에 임의의 값(그림의 x)을 설정한 SYN 패킷을 전송하고 오픈 처리에 들어간다.
   이 과정을 통해 클라이언트는 `SYN-SENT` 상태로 전환하여 다음 SYN/ACK 패킷을 기다리게 된다.

3. SYN 패킷을 수신한 서버는 패시브 오픈(Passive Open)을 처리한다.
   SYN 플래그와 ACK 플래그가 `1`로 설정된 SYN/ACK 패킷을 반환하고, `SYN-RECEIVED` 상태로 전환한다.
   이때 시퀀스 번호는 무작위(그림의 y), 확인 응답 번호는 SYN 패킷의 시퀀스 번호에 `1`을 더한 값(x+1)이 된다.

4. SYN/ACK 패킷을 수신한 클라이언트는 ACK 플래그를 `1`로 설정한 ACK 패킷을 반환하고, `ESTABLISHED` 상태로 전환한다.
   `ESTABLISHED`는 커넥션이 확립된 상태다. 이 상태가 되어야만 실제 애플리케이션 데이터를 송수신할 수 있게 된다.

5. ACK 패킷을 받은 서버는 `ESTABLISHED` 상태로 전환한다.
   이 상태가 되어야 비로소 실제 애플리케이션 데이터를 송수신할 수 있게 된다. 지금까지의 시퀀스 번호와 확인 응답 번호를 주고받음으로써 애플리케이션 데이터의 최초에 부여되는 시퀀스 번호가 각각 확정된다.

### 커넥션 설정 단계

3방향 핸드셰이크 완료 후 어플리케이션 데이터 교환이 시작됨.

#### 흐름 제어

- 수신 측 단말이 수행하는 유량 조정.
	- 윈도우 크기 필드를 사용해 자신이 수신할 수 있는 데이터 양 알림.
- 발신측은 윈도우 크기까지 확인응답(ACK)을 기다리지 않고 TCP 세그먼트를 계속 보내지만, 그 이상의 데이터는 보내지 않음.
- 수신측 단말이 수신할 수 있도록 배려하면서 가능한 많은 데이터를 보내도록 함.
- 이 동작이 '슬라이딩 윈도우'

#### 혼잡 제어

- 발신 측 단말이 수행하는 유량 조정.
- 트래픽이 몰릴때 느려지는 현상 같은것.
- 혼잡해지지 않도록 '혼잡 제어 알고리즘'을 통해 패킷 전송 횟수를 제어 함.
- 전송 횟수를 '혼잡 윈도우'(cwnd, congestion window)라고 함.

![[Pasted image 20260120140751.png]]

### 재전송 제어

- 패킷 손실 발생 시 수행하는 패킷 재전송 기능.
- TCP는 ACK 패킷을 통해 패킷 손실 감지 후 패킷을 재전송.
- 재전송 제어가 발동되는 타이밍은
	- 수신측 단말이 트리거하는 '중복 ACK'(Duplicate ACK)와
	- 발신 측 단말이 트리거하는 '재전송 타임아웃'(Retransmission Time Out, RTO) 두 가지가 있음.

### 커넥션 종료 단계

- '클로즈'라고 불리는 TCP 커넥션 종료 처리에 들어감.
- 커넥션 클로즈에 실패하면 불필요한 커넥션이 단말에 계속 쌓여 단말의 리소스를 압박.
- FIN 패킷(FIN 플래그가 '1'인 TCP 세그먼트)과 RST 패킷(RST 플래그가 '1' 인 TCP 세그먼트)를 주고 받으며 닫음.
	- FIN: 더 이상 전송할 어플리케이션 데이터가 없다.
	- RST: 오류 발생으로 커넥션 강제로 끊고 싶다.

#### 4방향 핸드셰이크

1. 클라이언트 애플리케이션은 예정된 애플리케이션 데이터 교환이 끝나면 클라이언트 OS에 클로즈 요청을 한다.
   클라이언트 OS는 이 클로즈 요청에 따라 액티브 클로즈 처리를 시작하며, FIN 플래그와 ACK 플래그를 1로 설정한 FIN/ACK 패킷을 전송하고, 서버의 FIN/ACK 패킷을 기다리는 FIN-WAIT-1 상태로 전환한다.
2. FIN/ACK 패킷을 받은 서버 OS는 패시브 클로즈 처리를 시작한다.
   서버 애플리케이션에 클로즈 처리를 요청하고, FIN/ACK 패킷에 대한 ACK 패킷을 전송한다. 또한 동시에 서버 애플리케이션의 클로즈 요청을 기다리는 CLOSE-WAIT 상태로 전환한다.
3. ACK 패킷을 받은 클라이언트 OS는 서버의 FIN/ACK 패킷을 기다리는 FIN-WAIT-2 상태로 전환한다.
4. 서버 OS는 서버 애플리케이션에서 클로즈 처리 요청이 있으면 FIN/ACK 패킷을 전송하고, 자신이 전송한 FIN/ACK 패킷에 대한 ACK 패킷,
    즉 클로즈 처리의 마지막 ACK 패킷을 기다리는 LAST-ACK 상태로 전환한다.
5. 서버 OS로부터 FIN/ACK를 받은 클라이언트 OS는 이에 대한 ACK 패킷을 전송하고 TIME-WAIT 상태로 전환한다.
    TIME-WAIT는 혹시나 늦게 도착할지도 모르는 ACK 패킷을 기다리는 보험과 같은 상태다.
6. ACK 패킷을 받은 서버 OS는 CLOSED 상태로 전환하여 TCP 커넥션을 삭제한다.
    동시에 이 TCP 커넥션을 위해 확보했던 리소스를 해제한다. 이것으로 패시브 클로즈 처리가 완료된다.
7. TIME-WAIT 상태로 전환된 클라이언트 OS는 설정된 시간(타임아웃)을 기다렸다가 CLOSED 상태로 전환하여 커넥션을 삭제한다.
    동시에 이 커넥션을 위해 확보했던 리소스를 해제한다. 이것으로 액티브 클로즈 처리가 종료된다.

![[Pasted image 20260120141225.png]]

#### 3방향 핸드셰이크

1. 처음에는 4방향 핸드셰이크와 동일하다.
   클라이언트 OS는 클라이언트 애플리케이션에서 클로즈 요청이 들어오면 액티브 클로즈 처리를 시작하고 FIN/ACK 패킷을 전송한다. 또한 동시에 `FIN-WAIT-1` 상태로 전환한다.
2. FIN/ACK 패킷을 받은 서버 OS는 패시브 클로즈 처리를 시작하고 서버 애플리케이션에 클로즈 처리를 요청한다.
   클로즈 처리 요청을 받은 서버 애플리케이션은 즉시 처리하여 서버 OS가 ACK를 반환하기 전에 서버 OS에 클로즈 처리를 요청한다.
   클로즈 처리 요청을 받은 서버 OS는 FIN/ACK 패킷을 전송하고, 이에 대한 ACK 패킷을 기다리는 `LAST-ACK` 상태로 전환한다.
   이 FIN/ACK 패킷은 4방향 핸드셰이크에서 ②의 ACK 패킷과 ④의 FIN/ACK 패킷을 합친 것이라고 생각하면 된다.
3. 서버로부터 FIN/ACK 패킷을 받은 클라이언트 OS는 이에 대한 ACK 패킷을 전송하고 `TIME-WAIT` 상태로 전환한다.
4. 여기서부터는 4방향 핸드셰이크 때와 마찬가지로 ACK 패킷을 받은 서버는 `CLOSED` 상태로 전환하여 커넥션을 삭제한다.
   동시에 이 TCP 커넥션을 위해 확보해 두었던 리소스를 해제한다. 이것으로 패시브 클로즈 처리가 끝난다.
5. `TIME-WAIT` 상태로 전환된 클라이언트 OS는 설정된 시간(타임아웃)을 기다렸다가 `CLOSED` 상태로 전환하여 커넥션을 삭제한다.
   동시에 이 커넥션을 위해 확보했던 리소스를 해제한다. 이것으로 액티브 클로즈 처리가 종료된다.

![[Pasted image 20260120141527.png]]
