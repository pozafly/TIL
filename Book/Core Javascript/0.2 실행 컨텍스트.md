# 실행 컨텍스트

실행 컨텍스트는 실행할 코드에 제공할 환경정보들을 모아놓은 객체. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행.

<br/>

동일한 환경에 있는 코드들을 실행할 때, 필요한 환경 정보를 모아 컨텍스트를 구성하고 이를 '**콜스택**(call stack)'에 쌓아 관련있는 코드를 하나하나 실행함. 여기서 동일한 환경 즉, 하나의 실행 컨텍스트를 구성할 수 있는 방법으로 `전역공간`, `eval함수`, `함수` 등이 있다.
자동으로 생성되는 전역공간과 악마로 취급받는 eval을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 '함수'를 실행하는 것 뿐.

```js
var a = 1;

function outer() {
  function inner() {
    console.log(a); // undefined
    var a = 3;
  }
  inner();
  console.log(a); // 1
}

outer();
console.log(a); // 1
```

<br/>

1. 처음 JS가 시작하는 순간 전역 컨텍스트가 콜스택에 담김. 최상단 공간은 코드 내부에서 별도의 실행 명령 없이도 브라우저에서 자동으로 실행하므로 JS 파일이 열리는 순간 **전역 컨텍스트**가 활성화 된다고 이해하면 된다.
2. 전역 컨텍스트와 관련된 코드를 실행하다가, outer 함수의 호출. outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성 후 콜 스택에 담는다. outer 실행 컨텍스트가 콜스택 맨 위이므로 전역 컨텍스트 실행을 일시 중단, outer의 실행 컨텍스트와 관련된 코드를 실행함.
3. inner 함수의 실행. 
	- inner 함수 내부 a에 3을 할당, inner 종료 후 inner 실행 컨텍스트 종료, 콜스택에서도 제거됨.
4. outer 컨텍스트가 콜 스택 맨 위이므로 이어서 실행.
	- 변수 a 의 값을 출력 후 outer 실행 컨텍스트 종료. 콜스택에서도 제거 됨.
5. 마지막 전역의 a 변수 값 출력. 전역 공간에 아무것도 남지 않은 상태로 종료된다. 전역 컨텍스트도 종료

<br/>

스택 구조를 잘 보면, 한 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점. 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장한다.

<br/>

- **VariableEnvironment**: 현재 컨텍스트 내의,
	- 식별자들에 대한 정보 + 외부 환경 정보
	- 선언 시점의 LexicalEnvironment의 스냅샷
- **LexicalEnvironment**: 처음의 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨.
- **ThisBinding**: this 식별자가 바라봐야할 대상 객체.

<br/>
<br/>

## VariableEnvironment
실행 컨텍스트를 생성할 때 VariableEnvironment 정보를 먼저 담고, 이를 복사해 LexicalEnvironment를 만들고, 이후에는 LexicalEnvironment를 주로 이용하게 된다.
VariableEnvironment, LexicalEnvironment의 내부는 environmentRecord와 outer-environmentReference로 구성되어 있다. 

<br/>

## LexicalEnvironment
'어휘적 환경', '정적 환경'이라고 불리지만, 별로고, 필자는 '사전적인'이라는 단어가 더 어울리는 것 같다고 함. '현재 실행 컨텍스트 내부에는 a, b, c 와 같은 식별자가 있고 그 외부 정보는 D를 참조하도록 구성되어 있다' 와 비슷한 느낌.

<br/>

## environmentRecord와 호이스팅
environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.
※ 식별자 정보
- 함수에 지정된 매개변수 식별자
- 함수 자체
- var로 선언된 변수의 식별자

호이스팅이란, '끌어올리다'라는 의미의 hoist에 ing를 붙여 만든 동명사. 변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 **가상의 개념**.


```js
function a(x) {
  console.log(x);  // (1)
  var x;
  console.log(x);  // (2)
  var x = 2;
  console.log(x);  // (3)
}
a(1);
```

(1), (2), (3)은 어떤 값이 출력될까?
1, undefined, 2가 출력된다고 예상할 수 있지만 1, 1, 2가 출력된다. 왜?
인자(arguments)는 함수 내부의 다른 코드보다 먼저 선언 및 할당이 이루어진 것으로 간주할 수 있다. 아래 코드와 같다.
※ arguments 역시 실행 컨텍스트 생성시 함께 만드는 정보임.

```js
function a() {
  var x = 1;
  console.log(x);  // (1)
  var x;
  console.log(x);  // (2)
  var x = 2;
  console.log(x);  // (3)
}
a();
```

이 상태에서 호이스팅을 처리해보자. environmentRecord는 현재 실행될 컨텍스트의 대상 코드 내 **어떤 식별자들**이 있는지에만 관심이 있음. 할당에는 관심이 없다.

```js
function a() {
  var x;
  var x;
  var x;
  
  x = 1;
  console.log(x);  // (1)
  console.log(x);  // (2)
  x = 2;
  console.log(x);  // (3)
}
a();
```

따라서, 1,1,2가 출력되는 것임. 이번엔 함수 호이스팅을 살펴보자.

```js
function a() {
  console.log(b);  // (1)
  var b = 'bbb';
  console.log(b);  // (2)
  function b() {}
  console.log(b);  // (3)
}
a();
```

어떻게 출력될까?
undefined, bbb, \[function: b\] 이 아닐까? 아님. **함수 선언은 전체를 끌어올린다**.

```js
function a() {
  var b;
  function b() {}
  
  console.log(b);  // (1)
  
  b = 'bbb';
  console.log(b);  // (2)
  console.log(b);  // (3)
}
a();
```
이렇게. 그리고 호이스팅이 끝난 상태에서의 함수 선언문은 함수명으로 선언한 변수에 함수를 할당한 것처럼 여길 수 있다.

```js
function a() {
  var b;
  var b = function b() {}
  
  console.log(b);  // (1)
  
  b = 'bbb';
  console.log(b);  // (2)
  console.log(b);  // (3)
}
a();
```

\[function: b\], bbb, bbb 가 출력된다.

### 함수 선언문과 함수 표현식
- 함수 선언문 : function a () {}
- 함수 표현식 : var a = function () {}
함수 선언문의 경우 반드시 함수명이 정의돼 있어야하는 반면, 함수 표현식은 없어도 된다. 함수명을 정의한 함수 표현식은 '기명 함수 표현식', 함수명을 정의하지 않은 표현식은 '익명 함수 표현식' 이라하고 함.
- 기명 함수 표현식 : var a = function a () {}
- 익명 함수 표현식 : var a = function () {}
일반적으로 함수 표현식이라 하면, 익명함수 표현식을 말함.

```js
console.log(sum(1, 2));
console.log(multi(3, 4));

function sum(x, y) {  // 함수 선언문
  return x + y;
}

var multi = function (x, y) {  // 함수 표현식
  return x * y;
};
```

호이스팅 과정을 살펴보자. 여기서 함수 선언문만 함수 전체가 호이스팅 된다.

```js
function sum(x, y) {  // 함수 선언문은 전체를 호이스팅 함.
  return x + y;
}
var multi;  // 변수는 선언부만 끌어올림.

console.log(sum(1, 2));
console.log(multi(3, 4));

multi = function (x, y) {  // 변수 할당부는 원래 자리에 남겨둠.
  return x * y;
};
```

실행하면 'multi is not a function' 이라는 error가 출력된다. 혼란이 초래됌. 함수 선언문이 혼란스러운 개념이라는 건 선언되기 전에 실행되는 것 같이 거부감 때문은 아님.
거대 Javascript 파일에서 sum function이 여러번 선언되었다고 가정하면, 오류 없이 함수들이 가장 마지막에 선언된 함수 선언식의 함수가 실행될테고, 아무런 에러를 뱉지 않는다. 이 오류를 잡을 때 시간이 많이 걸릴 수 밖에 없다.
하지만, 함수 표현식으로 함수를 나타내었다면, 개발 과정에서 오류가 났을 것이고 그러면 개발자들이 오류를 쉽게 찾을 수 있었을 것임.