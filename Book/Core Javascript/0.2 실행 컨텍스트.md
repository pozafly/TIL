# 실행 컨텍스트

실행 컨텍스트는 실행할 코드에 제공할 환경정보들을 모아놓은 객체. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행.

<br/>

동일한 환경에 있는 코드들을 실행할 때, 필요한 환경 정보를 모아 컨텍스트를 구성하고 이를 '**콜스택**(call stack)'에 쌓아 관련있는 코드를 하나하나 실행함. 여기서 동일한 환경 즉, 하나의 실행 컨텍스트를 구성할 수 있는 방법으로 `전역공간`, `eval함수`, `함수` 등이 있다.
자동으로 생성되는 전역공간과 악마로 취급받는 eval을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 '함수'를 실행하는 것 뿐.

```js
var a = 1;

function outer() {
  function inner() {
    console.log(a); // undefined
    var a = 3;
  }
  inner();
  console.log(a); // 1
}

outer();
console.log(a); // 1
```

<br/>

1. 처음 JS가 시작하는 순간 전역 컨텍스트가 콜스택에 담김. 최상단 공간은 코드 내부에서 별도의 실행 명령 없이도 브라우저에서 자동으로 실행하므로 JS 파일이 열리는 순간 **전역 컨텍스트**가 활성화 된다고 이해하면 된다.
2. 전역 컨텍스트와 관련된 코드를 실행하다가, outer 함수의 호출. outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성 후 콜 스택에 담는다. outer 실행 컨텍스트가 콜스택 맨 위이므로 전역 컨텍스트 실행을 일시 중단, outer의 실행 컨텍스트와 관련된 코드를 실행함.
3. inner 함수의 실행.
	- inner 함수 내부 a에 3을 할당, inner 종료 후 inner 실행 컨텍스트 종료, 콜스택에서도 제거됨.
4. outer 컨텍스트가 콜 스택 맨 위이므로 이어서 실행.
	- 변수 a 의 값을 출력 후 outer 실행 컨텍스트 종료. 콜스택에서도 제거 됨.
5. 마지막 전역의 a 변수 값 출력. 전역 공간에 아무것도 남지 않은 상태로 종료된다. 전역 컨텍스트도 종료

<br/>

스택 구조를 잘 보면, 한 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점. 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장한다.

<br/>

- **VariableEnvironment**: 현재 컨텍스트 내의,
	- 식별자들에 대한 정보 + 외부 환경 정보
	- 선언 시점의 LexicalEnvironment의 스냅샷
- **LexicalEnvironment**: 처음의 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨.
- **ThisBinding**: this 식별자가 바라봐야할 대상 객체.

<br/>
<br/>

## VariableEnvironment

실행 컨텍스트를 생성할 때 VariableEnvironment 정보를 먼저 담고, 이를 복사해 LexicalEnvironment를 만들고, 이후에는 LexicalEnvironment를 주로 이용하게 된다.
VariableEnvironment, LexicalEnvironment의 내부는 environmentRecord와 outer-environmentReference로 구성되어 있다.

<br/>

## LexicalEnvironment

'어휘적 환경', '정적 환경'이라고 불리지만, 별로고, 필자는 '사전적인'이라는 단어가 더 어울리는 것 같다고 함. '현재 실행 컨텍스트 내부에는 a, b, c 와 같은 식별자가 있고 그 외부 정보는 D를 참조하도록 구성되어 있다' 와 비슷한 느낌.

<br/>

## LexicalScope

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

실행 결과는 함수 bar의 상위 스코프가 무엇인지에 따라 결정된다. 두가지 패턴을 예측할 수 있다.
1. 함수를 어디서 호출했는지에 따라 상위 스코프를 결정하는 것.
2. 함수를 어디에 선언했는지에 따라 상위 스코프를 결정하는 것.
첫번째 방식으로 함수의 상위 스코프를 결정한다면 함수 bar의 상위 스코프는 함수 foo와 전역일 것이고,
두번째 방식으로 함수의 스코프를 결정한다면 함수 bar의 스코프는 전역일 것.

3. 첫번째 방식을 '동적 스코프(Dynamic scope)'라 하고,
4. 두번째 방식을 렉시컬 스코프(Lexical scope)또는 정적 스코프(Static scope)라 함.
자바스크립트는 렉시컬 스코프를 따른다.
렉스컬 스코프는 **함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다**. 자바스크립트는 렉시컬 스코프를 따르므로 함수를 선언한 시점에 상위 스코프가 결정된다. 함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않는다. 위 예제의 함수 bar는 전역에 선언되었다. 따라서 함수 bar의 상위 스코프는 전역 스코프이고 위 예제는 전역 변수 x의 값 1을 두 번 출력한다.

<br/>
<br/>
<br/>

## 질문

1. 실행 컨텍스트란 무엇인가?
2. 실행 컨텍스트를 구성할 수 있는 방법은 뭔가?
3. 실행 컨텍스트에 담기는 환경 정보는 뭐가 있나?
4. environmentRecord가 뭔가? 내부에 저장되는 것들은?
5. 호이스팅이란?
6. 함수 선언문과 함수 표현식은 무엇이고 어떤 차이가 있나? 어떤 것을 쓰는게 권장되는가?
7. 스코프란 무엇인가?
8. 스코프 체인이란 무엇인가?
9. 렉시컬 스코프란 무엇인가?

<br/>

## 답

1. 실행할 코드에 제공할 환경정보를 모아놓은 객체다. 동일 환경에 있는 코드들을 실행할 때 필요 정보를 모아 컨텍스트를 구성하고 '콜스택'에 쌓아 코드를 실행한다. 실행 컨텍스트가 활성화 되는 시점에 수행하는 것.
	- 호이스팅
	- 외부 환경 정보를 구성
	- this 값을 설정
   - 전역 공간
   - eval() 함수
   - 함수
   - VariableEnvironment: 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경정보, 선언 시점의 LexicalEnvironment의 스냅샷
   - LexicalEnvironment: 처음에는 VariableEnvironment와 같지만, 변경 사항이 실시간으로 변함
   - ThisBinding: 식별자가 바라봐야 할 대상 객체
그리고, VariableEnvironment, LexicalEnvironment 내부에는 `evironmentRecord`와 `outerEnvironmentReference`가 있다.
4. 현재 컨텍스트와 관련된 코드의 식별자 정보가 저장된다.
   - 함수에 지정된 매개변수 식별자
   - 선언한 함수가 있을 경우 그 함수 자체
   - var로 선언된 변수의 식별자
5. 끌어올리다라는 의미를 가지고 있다. var로 선언된 식별자가 위로 올라가는 것처럼 보이는 가상의 개념. environmentRecord에서 식별자들에 대한 정보를 이미 수집했기 때문에 접근은 가능하기 때문이다.
   - 함수 선언문: function 정의부만 존재함
   - 함수 표현식: 정의한 function을 별도의 변수에 할당함.
함수 선언문은 반드시 함수명이 정의되어 있어야하고, 함수 표현식은 함수명이 없어도 된다.
함수 표현식을 사용하는것이 권장된다. 이유는 호이스팅 때문인데, 함수 선언문은 그 함수 자체를 전부 호이스팅하지만, 함수 표현식은 함수를 담기 전 변수 선언부 먼저 호이스팅 하고 추후에 함수를 할당하기 때문이다. 그 전에 함수 표현식의 변수를 불러다 쓰면 오류가 난다. 개발자에게 아직 할당되지 않았고, 사용할 수 없다고 명시적으로 오류로 알려주기 때문에 실수를 줄일 수 있다.
7. 식별자에 대한 유효범위다. 유효 범위 안에 선언된 변수는 유효범위 안에서만 유효하다는 뜻. ES5까지는 함수 스코프가 생성되고 let, const, class, strict mode 등의 ES6 부터는 블록 스코프가 생성된다.
   - 식별자를 결정할 때 활용하는 스코프들의 연결리스트
   - 자바스크립트 엔진이 식별자를 찾을 때 자신이 속한 스코프에서부터 찾아보고, 없으면 상위 스코프를 타고 올라가며 찾아 나가는 행위. 가장 가까운 요소부터 차례대로 접근할 수 있고 다른 순서는 불가능하다.
9. 함수를 어디서 호출했는지가 아니라 함수가 어디에 선언 되었는지에 따라 상위 스코프가 결정되는 것을 말함.
