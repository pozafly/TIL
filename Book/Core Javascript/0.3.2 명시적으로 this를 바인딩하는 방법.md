# 명시적으로 this를 바인딩하는 방법

### call 메서드
call 메서드는 메서드의 호출 주체인 함수를 즉시 실행하도록 함. 이때 call 첫번째 인자를 this로 바인딩하고, 이후 인자들을 호출할 함수의 매개변수로 함.

```js
var fun = function (a, b, c) {
  console.log(this, a, b, c);
};

fun(1, 2, 3);  // Window {...} 1 2 3
fun.call({ x: 2 }, 1, 2, 3); // {x:2} 1 2 3
```

이는 함수 뿐 아니라 메서드도 동일하게 this를 바인딩 시킬 수 있다.

<br/>
<br/>

### apply 메서드
call 메서드와 동일. 단 두번째 인자로 배열을 받는데, 배열은 순서대로 각 매개변수로 들어가게 된다.

<br/>
<br/>

### call/apply 메서드의 활용
call이나, apply 메서드를 잘 활용하면 JS를 더욱 다채롭게 사용할 수 있다.

#### 유사배열객체(array-like object)에 배열 메서드를 적용
```js
var obj = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3,
};
Array.prototype.push.call(obj, 'd');
console.log(obj);  // { '0': 'a', '1': 'b', '2': 'c', '3': 'd', length: 4 }

var arr = Array.prototype.slice.call(obj);
console.log(arr);  // [ 'a', 'b', 'c', 'd' ]
```

객체에는 배열 메서드를 직접 적용할 수 없다. 그러나 키가 0 또는 양의 정수인 프로퍼티가 존재하고 length 프로퍼티의 값이 0 또는 양의 정수인 객체, 즉 배열의 구조와 유사한 객체의 경우(유사배열객체) call, apply 메서드를 이용해 배열 메서드를 차용할 수 있다.
slice는 시작 인덱스, 마지막 인덱스를 받아 배열 요소를 추출하는 메서드이지만, 아무것도 넘기지 않았을 경우 원본 배열의 얕은 복사본을 반환함. 위는 복사본을 배열로 반환하게 되었다.
함수 내부에서 접근할 수 있는 arguments 객체도 유사배열객체이므로 위의 방법으로 배열로 전환해 활용할 수 있다. `querySelectorAll`, `getElementsByClassName` 등의 Node 선택자로 선택한 결과인 NodeList도 마찬가지.

```js
function a() {
  var argv = Array.prototype.slice.call(arguments);
  argv.forEach(function (arg) {
    console.log(arg); // 1 2 3
  });
}
a(1, 2, 3);

document.body.innerHTML = '<div>a</div><div>b</div><div>c</div>';
var nodeList = document.querySelectorAll('div');
var nodeArr = Array.prototype.slice.call(nodeList);
nodeArr.forEach((node) => {
  console.log(node); // <div>​a​</div>​ <div>​b​</div>​ <div>​c​</div>​
});
```

※ ES6에서 유사배열객체 또는 순회 가능한 모든 종류의 데이터 타입을 배열로 전환하는 `Array.from()` 메서드를 새로 도입했다.

<br/>

#### 생성자 내부에서 다른 생성자를 호출
생성자 내부에 다른 생성자와 