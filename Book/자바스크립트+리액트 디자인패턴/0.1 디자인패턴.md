# 디자인패턴

## 패턴

패턴이란, 소프트웨어 설계에서 반복되는 문제와 주제에 적용할 수 있는 재사용 가능한 템플릿.

1. 검증되었다.
2. 쉽게 재사용할 수 있다.
3. 알아보기 쉽다.
   - 패턴은 정해진 구조와 **공통 표현**을 사용하여 광범위한 문제에 대해 정교한 솔루션을 제공할 수 있다.
4. 개발 과정에서 사소한 실수로 안해 생길 수 있는 큰 문제를 방지한다.
5. 특정 문제에 국한되지 않은 종합적인 해결책을 제시.
6. 반복을 피함으로써 전체 코드의 양을 줄일 수 있다. (DRY)
7. 공통된 어휘를 사용하여 의사소통이 원활해진다.
8. 인기 있는 디자인 패턴은 커뮤니티의 선순환을 유발한다.

### 프로토 패턴

아직 '패턴성' **검증을 모두 통과하지 않은 미숙한 패턴**을 말한다. 프로토 패턴은 개인의 뛰어난 작업물로부터 비롯될 수 있지만, 이제 막 새롭게 나타난 패턴은 커뮤니티의 충분한 검토를 받을 기회가 없었을 것이다. 그 대신 간단 설명을 덧붙여 공개하는 경우도 있는데 이런 설명이나 코드 조각들을 패틀릿(**patlet**) 이라고 함.

하지만, 다음과 같은 특징을 가지고 있으면 '좋은' 패턴으로 간주한다.

- 특정 문제를 해결할 수 있다.
- 명쾌한 해결책이 없다.
- 확실한 기능만을 말한다.
- 관계를 설명한다.

### 세 가지 법칙

좋은 패턴이 되기 위해서는 반복되는 현상, 또는 문제에서 지속적으로 사용되어야 한다. 반복성을 입증하려면 세 가지 법칙이라고 불리는 다음 질문에 답할 수 있어야 한다.

1. 목적 적합성
   - 좋은 패턴은 어떻게 판단하는가?
2. 유용성
   - 좋은 패턴이라고 할 수 있는 이유가 무엇인가?
3. 적용 가능성
   - 넓은 적용 범위를 가지고 있어 패턴이 될 가치가 있나? 만약 그렇다면 왜 그런지 설명해야 한다.

<br/>

## 패턴 구조화 및 작성

### 패턴의 구조

패턴 작성장는 패턴의 설계, 구현 방법 및 목적을 설명해야 함. 다음의 **관계성을 생각해 규칙의 형태로 패턴을 제시한다**.

- 컨텍스트: 패턴이 적용되는 상황
- 집중 목표: 패턴을 적용할 때 고려해야 하는 목표
- 구성: 제시된 상황과 고려해야 하는 점들을 해결하는 구성

<br/>

## 안티 패턴

겉으로만 해결책처럼 생긴 패턴을 뜻한다.

- 문제 상황에 대한 잘못된 해결책
- 문제 상황에서 벗어나 올바른 해결책에 이르는 방법

안티 패턴을 아는건 디자인 패턴을 아는 것 만큼이나 중요함. 어플을 만들때 플젝 라이프사이클은 개발과 함께 시작된다. 이 단계에서 어떤 **좋은** 디자인 패턴이 프로젝트적합할지 선택하게 될 것이다. 그러나 초기 설장 단계는 금방 지나고, 어느새 유지보수 단계가 오게 된다.

운영 중 어플 유지보수하기란 특히 어려운 일이다. 운영 중인 어플리케이션에 익숙하지 않은 개발자가 실수로 **나쁜** 디자인 패턴을 도입할 수 있음. 안티 패턴이라는 것을 빠르게 인지할 수 있다면 개발자는 패턴을 잘못 도입하는 실수를 피할 수 있을 것이다.

어플 품질은 팀의 기술 레벨과 투자한 시간에 따라 좋아질 수도, 나빠질 수도 있다. 여기서 **좋고 나쁨**은 상황에 따라 결정되며, 소위 '완벽한' 설계도 잘못된 상황에서 사용된다면 안티 패턴이 될 수 있다.

요약하면, 안티 패턴은 반면교사로 활용하기 위해 문서화하여 기록해야 하느 나쁜 디자인 패턴.

### JS 안티 패턴

신속한 구현을 위해 임시방편을 선택하기도 한다. 그러나 이런 임시방편은 영구적으로 이어지는 경향이 있고, 결국 기술 부채가 되어 안티 패턴이 되곤 한다. JS는 느슨한 타입 언어이기 때문에 특히 이런 경향이 두드러진다.

- 전역 컨텍스트에서 수많은 변수를 정의해 전역 네임스페이스를 오염시키기
- setTimeout이나, setInterval에 함수가 아닌 문자열을 전달해 내부적으로 eval() 실행되게 하기
- Object의 클래스의 프로토타입을 수정하기(특히 나쁜 안티패턴)
- 자바스크립트를 인라인으로 사용하여 유연성 떨어뜨리기
- document.createElement대신 document.write 사용하기.
  - document.write는 오랫동안 잘못 사용되어 왔으며, 여러 단점을 가지고 있다. 만약 페이지가 로드된 후 실행된다면 기존 페이지의 내용을 덮어씌우기 때문에 document.createElement가 더 적합하다. 또 XHTML에서는 작동하지 않음
