## 4장 코드 이해

p.77

> 다이어그램을 그릴 때 유의사항
>
> 모든 상세한 내용을 표시하면 안 된다. 의도에 맞게 필요한 요소만 표시하고 불 필요한 요소는 생략해야 한다. 시퀀스 다이어그램을 다 표시하면 다이어그램만 복잡해지고 의도한 정보를 제공하는데 방해가 될 뿐.

이 부분이 참 어렵다. 이전 회사에서는 모든 부분을 거의 다 그렸었는데 확실히 지금 돌아보면 코드의 흐름을 따라가기가 무척 어렵다. 큰 맥락을 파악하는 능력이 중요해보인다.

이번에 레거시를 개편하면서, 큰 틀에서 정리를 하고 있는데 시퀀스 다이어그램을 이용해 코드 파악이 쉽도록 흐름을 그려봐야겠다.

- [diagram.codes](https://playground.diagram.codes/)
- [mermaid.js](https://mermaid.js.org/)

두 가지 툴이 마음에 드는데 잘 활용하면 좋은 도구가 될 수 있을 것 같다.

p.81

> 스크래치 리팩터링
>
> 코드 분석을 목적으로 하는 리팩터링. 구조나 의미를 이해하는 과정. 변수 이름 변경, 메서드 추출, 클래스 추출, 파라미터 타입 변경과 같은 수정을 하게 되는데 이런 작업을 진행하면서 코드 동작을 깊이 이해할 수 있게 된다. 그리고, 다시 원래대로 되돌린다. 코드 개선이 아니기 때문에.

맞다. 변수 명 수정 같은 것을 통해 코드 구조를 파악하게 되고 깊이 있게 알 수 있는 것 같다. 코드 개선이 아닌, 코드 이해가 목적이기 때문에 온보딩 하는 분들에게 코드를 한 번 훑게 하면서 이해시킬 때 좋을 것 같다. 지금 내가 하고 있는 단계이기도 하고.

p.83

> 이해하기 좋은 코드.
>
> 툴을 이용해 분석하는데 도움이 되기도 하지만, 코드 자체를 이해하기 쉽게 만드는 게 더 좋다. 가독성이 좋은 코드를 만들어야 한다.
>
> 이름을 잘 지어야 함.

우리 코드는 bx-0000 이런 식의 이름이 굉장히 많은데, 마음 같아서는 모두 다 의미를 가지고 파악이 가능한 이름으로 전부 변경하고 싶다.

p.91

> 다음과 같은 규칙으로 변수 사용 법위를 정할 수 있다.
>
> - 시용되기 직전에 정의
> - 짧은 루프 불록 안으로 한정
> - 짧은 if-else 블록 안으로 한정
> - 짧은 메서드로 한정

p.99

> 길지 않은 코드와 메서드 추출
>
> 짧은 코드가 분석하기 쉽다. 구현의 일부를 별도 메서드나 객체로 분리해야 한다.

JavaScript에서도 긴 함수를 좋게 보지 않는다. 함수를 기능 단위로 나누고, 쪼개는 작업을 통해 추상화를 제공하면 가독성이 훨씬 좋아진다. 내부 구현을 몰라도 추상화 된 이름으로 추측할 수 있기 때문에 함수를 읽는데 context를 유지할 수 있기 때문이다.

<br/>

## 5장 응집도와 결합도

p.112

> 응집도를 왜 높여야 할까? 응집도는 결국 수정 비용과 관련있다. 관련 코드가 한 곳에 모여있게 되고 역할에 따라 클래스가 분리되면서 자연스럽게 클래스 길이기 줄고, 메서드 단위로 작성되기 때문에 가독성이 좋아진다. 코드 분석 시간을 줄여준다.

p.113

> 응집도가 높아지면 구성 요소가 역할에 따라 알맞게 분리될 가능성이 커진다. 구성 요소가 역할에 따라 분리될 수록 SW 변경 범위가 좁혀진다.

신기하네. 응집도가 높아지면 역할에 맞게 분리될 가능성이 높아진다니. 변경 범위가 좁혀진다는 것은 좋은 것 같다.

p.118

> 결합도. 한 요소를 수정할 때 다른 요소도 함께 수정해야 하면 두 요소 간 결합도가 높다고 표현한다. 반대로 한 모듈을 수정할 때 다른 모듈을 수정하지 않아도 되면 결합도가 낮다고 말한다. 수정할 대상이 많아지면 코드 분석과 ㅈ수정에 드는 시간이 증가한다.

-> css가 하나의 파일로 되어있을 경우 그렇게 된다. 나누지 않고 하나의 의존 css 파일을 사용하면 css를 수정하면 다른 곳이 깨질 가능성이 매우 높아지기 때문임. 따라서 컴포넌트 하나에 알맞은 css를 사용하는 것이 좋다. 그리고 vanilla-extract 같은 경우도 마찬가지다. 다른 곳에서 사용하지 못하게 의존 관계를 없애 조금은 불편하지만 하나의 요소에 하나의 className을 할당할 수 있도록 한 것임.

<br/>

## 6장 리팩터링

p.131

> 레거시 코드
>
> - 긴 클래스, 긴 메서드
> - 복잡한 코드
> - 이상한 이름
> - 많은 중복
> - 테스트 코드 없음

테스트 코드없음???? 마음이 어렵구먼.. 테스트 코드 익숙해져야할텐데...

> 레거시 코드 수정과 악순환.
>
> - 레거시 코드 이해하는데 많은 노력 필요
> - 이해부족 상태에서 코드 수정해야 함
> - 변경에 대한 두려움
> - 코드 덧대기로 두려움 회피

이 과정이 반복된다. 완전 이해가 간다. 특히 남이 짠 코드를 빠른 시간 안에 해결해야 할 때, 이런 일을 손쉽게 하는 것 같다. 전혀 노력을 들이지 않고 쉽게 가려고 할 경우. 하지만, 한 번에 드러내기 어렵다면 점진적으로 코드를 이해하고 수정하는 과정이 필요하지 않을까?

p.133

> 레거시는 폄하 대상이 아니다.
>
> 가끔 레거시 코드를 무시하는 개발자를 만날 때가 있다. 회사 코드가 최악이라거나 다시 만들면 그거보다 더 잘만들 수 있다는 식으로. 틀린 말이 아닐 수 있지만, 이런 말을 하는 개발자 중 기존 코드를 더 낫게 개선할 수 있는 사람은 많지 않았다. 더 좋게 개선하지도 못하는데 새로 잘 만들 수 있을까?
>
> 복잡하고 수정하기 힘든 레거시 코드를 만나면 투덜댈 수 있다. 하지만 폄하 대상이 아니다. 레거시가 있었기에 서비스가 굴러가고 수익이 난 것이다. 그리고 모든 코드에는 나름의 사정이 있다. 그러니 다음처럼 생각해보자.
>
> '개선할 거리가 있다. 해보자!'

긍정적이신 것 같다. 나도 긍정적인 생각을 가지고 개선할 거리가 있다고 여겨야겠다. 폄하하기만 하면 쉽긴 한 것 같다. 하지만 내 것으로 만들고 다시 개선하는데에 더 에너지가 많이 필요하니 쉽게 할 수 있는 방향을 자꾸만 택하게 되는 것 같다. 그러지 말자. 쉽게 쉽게만 가려고 하지 말자.

p.134

> 리팩토링은 외부로 드러나는 동작이나 기능을 변경하지 않고 내부 구조를 변경해 재구성하는 기법이다. 리팩토링은 새로운 기능을 추가하거나 기존 기능을 개선하지 않는다. 겉으로 드러나는 이점이 없다. 리팩토링을 하고 나면 장기적 관점에서 이점이 생긴다. 구현 변경과 확장이 용이해진다. 단기적으로는 수정 비용을 낮춰주고 장기적으로는 개발 비용을 낮춰준다.

맞다. 이번에 하는 리팩토링 과정도, 외부 구현이 변경되는게 아니라 내부 구조를 재구성 하는 것이다. 장기, 단기 이점을 얻어가기 위해, 개발 비용을 낮추기 위해 수행하는 것이다.

p.135

> 주석 처리된 코드를 삭제하기 두렵다면 TODO 주석을 추가한다. 주석에 적힌 일자가 6개월이 지났다면 그 동안 사용되지 않은 게 확실하다보니, 과감하게 삭제할 수 있다.

오 좋은 방법이다! 나도 써먹어봐야지. 그런 의미로 eslint는 정말 좋은 도구인 것 같다. 변수를 참조하고 있지 않을 경우, warning을 내주기 때문이다.

p.139

> 매직 넘버(문자열)도 상수나 열거 타입을 사용해 이름을 부여해 사용하자.

우리가 사용하고 있는, 알 수 없는 property 명도 전부 마음 같아서는 알 수 있는 의미의 프로퍼티 명으로 변경하고 싶다. 과연 가능할까? `언젠가는 가능할까요?`

p.156

> 하나의 for문에서 여러 가지 작업을 실행하면 서로 다른 목적을 가진 코드가 뒤섞일 수 있다. 다른 목적의 코드가 뒤섞이면 코드 복잡도가 증가하고 코드를 히해하기 어려워진다. for 루프가 1개의 일만 하도록 수정하는 것이다.
>
> 하지만 이제 추상화 수준에 따라 메서드를 추출할 수 있다. 논리적 단위로 분리한 덕분에 이점이 생긴다.
>
> - 코드가 복잡해지지 않고 논리적인 단위로 구분된다.
> - 논리적인 단위로 구분되어 코드를 이해하기 쉽다.
> - 메서드 추출과 같은 리팩터링이 용이하다.
> - 다른 로직을 추가하기가 용이하다.

이렇게 생각해본적 없다. 그냥 for 문 하나에서 여러 일을 해야 효율적이라고 생각했는데, 필요하다면 for 문을 같은 level의 2가지로 나눠 테스트하기 용이하고, 논리 단위로 코드 파악이 쉽도록 변경하면 좋을 것 같다! 좋은데!

p.159

> 새로 만든다고 코드가 좋아진다는 법은 없다. 좋은 코드를 만드는 방법을 알아야 코드 품질이 좋아진다. 이 사실을 꼭 기억하자.

맞다! 연습, 연습!

