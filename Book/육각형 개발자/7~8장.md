# 7~8장

## 7장. 테스트코드

p.163

> QA 담당자를 기다릴 필요 없다. 개발자가 직접 실행하면 된다.

우리 회사 상황. 즉 사람이 많지 않을 경우 테스트 코드가 좋구나.

p.166

> 개발자는 항상 압박속에 산다. 코드를 잘못만지면 심각한 문제가 발생할 수도 있기 때문이다. 민감한 기능일수록 코드를 수정하는데 부담이 커진다. 이런 부담을 줄일 방법의 하나가 테스트 작성이다.

맞다. 항상 압박 속에 사는 것 같다. 상대적으로 프론트 개발자보다는 백엔드 개발자가 압박이 더 심한 것 같다. 프론트는 잘못하면 심각한 장애를 발생시키지는 않은데, 백엔드 개발자는 장애를 낼 수도 있기 때문에.. 물론 데브옵스 개발자도 마찬가지..

프론트에서 테스트 코드를 잘 작성하는 방법은 무엇일까?

p.167

> 정상적인 상황 뿐 아니라 예외적인 상황에 대한 대처가 필요한데, TDD는 테스트 코드를 작성할 때부터 이점을 고려한다.

예외적인 상황을 고려하는게 참 잘 안되는 것 같다. 현재 구현되어 있는 코드도 예외상황 처리가 무척 미흡하게 되어있다. TDD 방식으로 개발한다면 먼저 예외상황부터 고려할 수 있도록 사고를 전환한다는 관점에서 참 좋은 것 같다.

그런데, 참 좋은 것 같다에서 끝나는 것도 많은 것 같다. ㅠㅜㅠ

p.169

> TDD가 기능을 설계하는데 도움을 주기 때문이다. 테스트 하려면 대상의 기능을 실행할 수 있어야하고, 인터페이스를 먼저 만들어야 한다.

마치 typescript를 도입했을 때와 같다. 함수를 정의할 때 먼저 네이밍부터 신경쓰고, 그 다음 들어갈 파라미터에 타입을 명시해주면서 어떤 기능을 만들 것인지 생각을 하게 해 정리된 기능을 만들게 한다. test도 마찬가지구나.

p.171

> 생산성. 오히려 테스트 코드를 작성하면 시간이 더 오래 걸린다고 생각하기 쉽다. 하지만 `전체 개발 관점` 에서 보면 이야기는 달라짐. ㅋ컨트롤러, 서비스, 모델, DB, SQL에 대한 코드를 한 번에 작성한 후 테스트를 진행하는데, 역할 단위로 테스트가 좁혀지기 때문에 한 번에 모두 개발하지 않아도 테스트가 가능하다.
>
> 이 과정을 반복해야 하는데, 한 번에 되기가 쉽지 않다.

맞다. 복잡한 과정이 존재하고 단위를 나누어 테스트와 함께 코드를 친다면 모든 것이 구현되고 테스트하지 않아도 된다. 그러면 전체적인 측면에서 봤을 경우 생산성이 늘 수도 있겠다는 생각이 드네.

p.175

> TDD는 리팩토링을 포함한다. 나중에 하게 될 코드 수정과 추가 작업을 쉽게할 수 있게 된다. 즉 미래의 디버깅 시간과 코딩 시간을 줄여준다.

-> 리팩토링을 하게 되기 때문에 미래의 시간도 줄여준다고 하긴 하는데 테스트 코드를 정식으로 도입해본적이 없어 체감이 어렵다. 테스트 코드를 빨리 도입해봐야 하나…

p.178

> 테스트를 위해 외부 시스템과 연동할 필요 없다. mock을 만들면 된다. 방화벽 등의 리소스 소모가 큰 쪽

<br/>

## 8장 아키텍처/패턴

p.188

> 품질 속성에서 최대 트래픽 규모와 패턴에 따라 아키텍처도 단순하거나 복잡해진다.

-> FE 같은 경우 생각보다 그렇게 복잡한 로직은 많지 않음. 다만, 변경이 많다보니 어떻게 하면 가독성이 좋게 만들것인가에 대한 고민이 있음. 트래픽 측면에서는 BFF가 있다보니, 어떻게 캐싱으로 이걸 서버 요금을 아낄 수 있을지를 고민하는게 좋은 방향이라는 생각.

p.190

> 품질 속성 중 하나가 유지보수성이다.

품질 속성을 높이는 것은, 잘 드러나지는 않는다. 품질 속성을 관리하지 않으면 결국 나중에는 비용증가로 이어진다. 품질을 높이는 것을 포기해서는 안된다는 생각.

> 하지만, 품질 속성을 높이면 시스템 복잡도가 높아진다.

오잉? 아! 관리 포인트가 늘어나는 구나. 요소가 늘어나고, 아키텍처가 복잡해지는 것.

> '트레이드오프' 그때그때 다르다(It depends on) 관점에서 생각해야 한다. 항상 이것이 제일 어렵고 지금 선택이 추후 어떤 영향을 줄지 모르기 때문이다. '모든게 완벽한 아키텍처가 아닌 가장 나쁘지 않은 아키텍처를 선택해야 한다.'

나는 완벽하게 모든 것을 만드는 것을 지향하는데, 어쩌면 잘못 생각하고 있었겠다 싶다. 왜냐하면 처음부터 사용하지 않을 수도 있는 모든 것을 고려해 완벽하게 하려다보면 비용증가와 관리 포인트 증가로 인해 더 어려운 아키텍쳐가 될 수도 있겠다는 생각이 들기 때문이다. 완급조절을 잘해야겠다.

p.195

> 모두 MSA로 만들었다.

지금 현재 필요하지 않는 것들까지 모두 만들어버려 오히려 유지보수 비용이 증가, 복잡성 증가. 우리 회사에 필요한 아키텍처응 어떻게 해야하나? 미러링은 우리 회사에 적절히 필요한 기능. 하지만, FSD와 같은 아키텍처는 직관적이지 않고, 구성원이 학습이 되어있어야만 적용할 수 있는 부분. 잘 생각해야 한다.

p.197

> 모든 것을 갈아 엎는다. 다시 처음부터 개발한다. -> 빅뱅 방식. 문제점은 기존 시스템에 새 기능이 추가되거나 기존시스템과 새로 만드는 시스템 간 기능 구현을 지속해서 동기화 해야한다는 것. 그리고 기능 누락이 있을 수 있다는 점.
>
> 결국 '점진적' 인 방법으로 마이그레이션 해야 한다.

점진적으로 마이그레이션 하려면 쪼개야 한다. -> 수평 확장. DB, 서비스, 기능 등 모두 수평 확장이 되어야 한다. 그러면 서비스의 독립성이 증가하고 각기 문제가 생기더라도 각 부분에서의 문제만 발생하게끔 한다.

p.199

> 아키텍처 변경은 반드시 '필요성'에 기반에 이루어져야 한다.

함부로 변경하면 안된다. 많은 노력과 시간이 따르기 때문.

p.201

> 같은 문제를 해결하려 한다면 복잡한 구조보다 단순한 구조가 더 좋다는 사실을 항상 명심.

맞다! 단순한 구조. 일부러 어렵게 할 필요가 없다는 이야기를 계속 들어왔다. 어떻게 하면 더 쉽게 문제를 풀 수 있을지 고민하기.
