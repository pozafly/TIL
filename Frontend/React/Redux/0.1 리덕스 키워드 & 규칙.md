# 리덕스 키워드 & 규칙

<br/>

## 리덕스의 키워드

리덕스에서 사용하는 키워드는 `useReducer`에서 사용하는 키워드와 비슷하다.

### 액션(Action)

상태에 어떠한 변화가 필요하게 될 땐, 액션이란 것을 발생시킨다. 액션은 하나의 객체로 표현되는데, 액션 객체는 다음과 같은 형식으로 되어있다.

```json
{
  type: "TOGGLE_VALUE"
}
```

액션 객체는 `type` 필드를 **필수적**으로 가지고 있어야하고 그 외의 값들은 마음대로 넣어줄 수 있다.

```js
{
  type: "ADD_TODO",
  data: {
    id: 0,
    text: "리덕스 배우기"
  }
}
```

```js
{
  type: "CHANGE_INPUT",
  text: "안녕하세요"
}
```

<br/>

### 액션 생성함수 (Action Creator)

액션 생성함수는, 액션을 만드는 함수다. 단순히 파라미터를 받아와서 액션 객체 형태로 만들어줌.

```jsx
export function addTodo(data) {
  return {
    type: "ADD_TODO",
    data,
  };
}

// 화살표 함수로도 만들 수 있다.
export const changeInput = text => ({
  type: "CHANGE_INPUT",
  text,
});
```

이런 액션 생성함수를 만들어 사용하는 이유는 나중에 컴포넌트에서 더욱 쉽게 액션을 발생시키기 위해서임. 그래서 보통 함수 앞에 `export` 키워드를 붙여 다른 파일에서 불러와 사용.

리덕스를 사용할 때 액션 생성함수를 사용하는것이 필수적이지는 않음. 액션을 발생시킬 때마다 직접 액션 객체를 작성할 수도 있음.

<br/>

### 리듀서(Reducer)

리듀서는 변화를 일으키는 함수다. 2가지 파라미터를 받아옴.

```javascript
function reducer(state, action) {
  // 상태 업데이트 로직
  return alteredState;
}
```

현재의 상태(state), 전달받은 액션(action)을 참고하여 새로운 상태를 만들어 반환한다. 이 리듀서는 `useReducer` 를 사용할 때 작성하는 리듀서와 똑같은 형태를 가지고 있다.

만약 카운터를 위한 리듀서를 작성한다면 아래와 같이 작성할 수 있음.

```jsx
function counter(state, action) {
  switch (action.type) {
    case 'INCREASE':
      return state + 1;
    case 'DECREASE':
      return state - 1;
    default:
      return state;
  }
}
```

`useReducer` 에선 일반적으로 `default:` 부분에 `throw new Error('Unhandled Action')` 과 같이 에러를 발생시키도록 처리하는게 일반적인 반면, 리덕스의 리듀에서는 기존 `state` 를 그대로 반환하도록 작성해야 함.

리덕스를 사용할 때는 여러개의 리듀서를 만들고 이를 합쳐 **루트 리듀서(Root Reducer)**를 만들 수 있다. (루트 리듀서 안의 작은 리듀서들은 서브 리듀서라고 부른다.)

<br/>

### 스토어(Store)

리덕스에서는 한 어플당 하나의 스토어를 만들게 된다. 스토어 안에는, 현재의 앱 상태와, 리듀서가 들어가있고, 추가적으로 몇가지 내장 함수들이 있다.

<br/>

### 디스패치(dispatch)

디스패치는 스토어의 내장함수 중 하나. 디스패치는 액션을 발생 시키는 것이라고 이해하면 됨. dispatch라는 함수에는 액션을 파라미터로 전달한다. dispatch(action) 이런 식으로. 그렇게 호출하면 스토어는 리듀서 함수를 실행시켜 해당 액션을 처리하는 로직이 있다면 액션을 참고하여 새로운 상태를 만들어준다.

<br/>

#### 구독(Subscribe)

구독 또한 스토어의 내장함수중 하나. subscribe 함수는, 함수 형태의 값을 파라미터로 받아옴. subscribe 함수에 특정 함수를 전달해주면, 액션이 디스패치 되었을 때마다 전달해준 함수가 호출됨.

리액트에서 리덕스를 사용하게 될 때 보통 이 함수를 직접 사용할 일은 별로 없음. 그 대신 react-redux 라는 라이브러리에서 제공하는 `connect` 함수 또는 `useSelector` Hook을 사용해 리덕스 스토어의 상태에 구독한다.

<br/>

## 3가지 규칙

리덕스를 프로젝트에서 사용하게 될 때 꼭 지켜야할 3가지 규칙이 있다.

### 1. 하나의 어플리케이션 안에는 하나의 스토어가 있다.

하나의 어플에서는 단 한개의 스토어를 만들어 사용한다. 어러개의 스토어를 사용하는 것은 사실 가능하지만 권장 안함. 특정 업데이트가 너무 빈번하게 일어나거나, 어플의 특정 부분을 완전히 분리시키게 될 때 여러개의 스토어를 만들 수도 있다. 하지만 그렇게 하면, 개발 도구를 활용하지 못하게 됨.

<br/>

### 2. 상태는 읽기 전용

리액트에서 state를 업데이트 해야할 때, setState를 사용하고, 배열을 업데이트 해야할 때는 배열 자체에 push 를 직접 하지 않고, concat 같은 함수를 사용하여 기존의 배열은 수정하지 않고 새 배열을 만들어 교체하는 방식으로 업뎃함. 엄청 깊은 구조로 되어있는 객체를 업데이트할 때도 마찬가지로, 기존 객체는 건드리지 않고 `Object.assign` 을 사용하거나, spread 연산자 (`...`)를 사용하여 업뎃함.

리덕스에서도 마찬가지. 기존의 상태는 건들이지 않고 새로운 상태를 생성하여 업뎃 해주면 개발자 도구를 통해 뒤로 돌릴 수 있고 다시 앞으로 돌릴 수 있다.

⭐️ 리덕스에서 불변성을 유지해야하는 이유는 내부적으로 데이터가 변경되는 것을 감지하기 위해 shallow equality(얕은 비교) 검사를 하기 때문. 이를 통해 객체의 변화를 감지 할 때 객체 깊숙한 안쪽까지 비교하는 것이 아니라 겉핥기 식으로 비교를 해 좋은 성능을 유지할 수 있는 것.

<br/>

### 3. 변화를 일으키는 함수, 리듀서는 순수한 함수여야 한다.

순수한 함수란,

- 리듀서 함수는 이전 상태와, 액션 객체를 파라미터로 받는다.
- 파라미터 외의 값에는 의존하면 안된다.
- 이전 상태는 절대 건들이지 않고, 변화를 일으킨 새로운 상태 객체를 만들어 반환한다.
- 똑같은 파라미터로 호출된 리듀서 함수는 `언제나` 똑같은 결과값을 반환해야만 한다.

동일한 인풋이라면 언제나 동일한 아웃풋이 있어야함. 그런데 일부 로직들 중에는 실행할 때마다 다른 결과값이 나타날 수 있다. 예를 들면 new Date() 같은 함수라던지 랜덤 숫자를 생성한다던지. 혹은, `네트워크에 요청을 한다던지`. 그러한 작업은 결코 순수하지 않은 작업이므로, 리듀서 함수의 바깥에서 처리해주어야 한다. 그런 것을 하기 위해 [리덕스 미들웨어](https://velopert.com/3401)를 사용하곤 한다.