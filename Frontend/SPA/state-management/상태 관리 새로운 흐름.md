# 상태 관리 새로운 흐름

> [출처](https://medium.com/@yujso66/%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC%EC%9D%98-%EC%83%88%EB%A1%9C%EC%9A%B4-%ED%9D%90%EB%A6%84-6e5ed0022e39)

일반적 접근 방식은, 유명한 것을 사용하는 것. 초창기 Redux가 필요하지 않았는데도 불구하고 Redux를 사용한 것에서 확인할 수 있다.

## 전역 상태 관리가 해결하고자 하는 문제

1. 저장된 상태를 컴포넌트 트리 어디서든 읽어올 수 있는 기능. (props drilling)
2. 저장된 상태를 수정하는 기능.
3. 렌더링을 최적화.
   - 수동 최적화와 자동 최적화가 있다.
     - 수동 최적화는 selector 함수를 통해 저장된 상태를 구독하는 것이다. selector를 통해 상태를 읽는 컴포넌트는 특정 상태가 업데이트될 때만 다시 렌더링 된다.
     - 자동 최적화는 수동으로 해주지 않아도 알아서 최적화 해주는 것이다. `Valtio` 같은 라이브러리. 이는 내부적으로 `Proxy` 를 사용하고 있다.
4. 메모리 사용을 최적화하는 메커니즘 제공
   - 컴포넌트가 마운트 해제될 때 자동 가비지 컬렉션을 더 쉽게 활용할 수 있다.
   - Redux와 같은 경우 이를 직접 관리해야 한다.

### 해결해야 할 문제

- 동시성 모드와 호환성.
  - 동시성 모드는 렌더링 도중 '중단'하고 우선 순위를 변경하는 것을 가능하게 한다. 예전엔 항상 동기적으로 진행되었다. recoil은 동시성 모드를 지원한다.
- 등등..

<br/>

## 역사

### Redux

- Flux 패턴. 항상 리렌더링하는 리액트 모델과 일치하는 단방향 데이터 흐름과 예측 가능한 업데이트에 적합.
- 따라서 Redux가 flux 패턴 구현체이므로 부상.
- 작은 규모 앱에서 문제.
  - 보일러 플레이트가 크고, Flux를 적용하기에 여러 단계가 있기 때문에 과하다고 느껴진다.
- 큰 규모 앱에서 문제.
  - 로컬 UI 상태, 원격 서버 캐시 상태, URL 상태, 전역 공유 상태, 그리고 수많은 상태들.
  - Redux는 단일 저장소이기 때문에, 런타임 성능 최적화를 악화시킴
    - 다시 말하면, 단일 저장소이기 때문에 **code splitting**이 안된다. -> 후에는 가능해지긴 함.

### Context API

- 간단한 접근 방식이며, 소규모 어플리케이션이 이 방법으로 문제 해결
- 하지만, 규모가 커지면 문제
  - Redux 다시 만들기. -> 특정 엣지 케이스 대응 불가능. 따라서 Redux로 회귀하는 모습.
  - 런타임 성능 최적화 -> 리렌더링 최적화가 힘들다. memo 등을 매번 붙여주어야 하고, 성능을 일일이 판단해 넣을지 말지 고민해야 함.

### React Query, SWR, Apollo, Relay

- 네트워크 요청과 관련된 상태 값
- 백엔드의 fetch 및 mutaion에 특화.

<br/>

## 새로운 흐름 및 패턴

### 상향식 패턴의 부상

- Redux는 하향식(중앙 집중식). 컴포넌트 트리의 맨 위에서 모든 상태를 빨아들임. 아래 컴포넌트는 selector를 통해 필요 상태를 끌어내림.
- 하지만 조합(컴폰지트 패턴)을 사용해 상향식 패턴이 부상하게 된다.
- 변화에 유연하고, 유지보수에 용이하게 된다. 또한, 직관적으로 받아들일 수 있다. ([링크](https://frontendmastery.com/posts/building-future-facing-frontend-architectures/))
- 마찬가지로 상태관리에서도 이런 atomic 패턴이 적용된 것이다. hook도 마찬가지다. 결합되는 원리를 이용한 것.
- Recoil, Jotai 같은 라이브러리는 원자(atomic) 상태 개념으로 상향식 접근 방식을 보여준다.
  - 원자는 최소 단위이지만 스스로 완전하다. 조각들은 그래프를 형성하게 되고 점진적으로 크게 만들어갈 수 있다.
  - 이점은, 리렌더링 최소화(원자 구독 하는 곳만 리렌더링 하면 되므로), 점진적 구축 가능.

<br/>

## 현대 라이브러리가 핵심 문제를 해결하는 방법

### 하위 트리 내 어디서나 저장된 상태를 읽을 수 있는 기능

![image](https://github.com/pozafly/TIL/assets/59427983/cc5caf4f-d3a0-4f45-a10b-ebcbe523766a)

### 저장된 상태를 쓰고 변경하는 기능

![image](https://github.com/pozafly/TIL/assets/59427983/10679e82-892a-46ad-85b5-69b071e1426c)

### 런타임 성능을 위한 리렌더링 최적화

- 수동 최적화
  - 상태 구독하는 selector 함수의 생성.
  - 세밀하게 제어 가능.
  - 하지만 수동 프로세스, 휴먼 에러 발생 가능성 높음.
- 자동 최적화
  - 사용 간편 및 개발에 집중할 수 있게 해줌.
  - 하지만 마술처럼 느껴짐

![image](https://github.com/pozafly/TIL/assets/59427983/5afdce93-a640-403e-9f98-13ab12e4689f)

### 메모리 최적화

매우 큰 규모의 어플에서 문제가 된다. 라이브러리가 모듈 수준에서 또는 리액트 런타임 내 상태를 저장하는지 여부에 달려있다. 작은 독립 저장소의 이점은 모든 구독 컴포넌트가 마운트 해제될 때 자동으로 가비지 컬렉션 될 수 있다는 것이다. 반면 대규모 모놀리식 저장소는 적절한 메모리 관리가 없다면 메모리 누수가 발생하기 쉽다.

![image](https://github.com/pozafly/TIL/assets/59427983/73fed334-309b-47a9-84ef-0ca40cd1c2d8)

<br/>

## 결론

정답은 없다. 요구 사항과 어플리케이션 개발하는 사람에 따라 달라진다.

상태 관리 라이브러리가 해결해야 하는 근본적이고 변하지 않는 문제를 이해하면 현재의 라이브러리와 미래 라이브러리를 모두 평가하는데 도움이 될 수 있다.


