# Object 가변성(Spread Operator)

<br/>

## 오브젝트 할당

### 기본 정리

- 변수에 문자열, 숫자와 같은 원시형 데이터를 할당하게 되면 데이터 자체가 변수에 할당되지만,
- 오브젝트 변수에 할당하면 변수에는 오브젝트가 메모리에 들어있는 주소인, **참조값**이 할당 되어짐.

```javascript
const num = 2;
const numObj = { num: 2 };
```

num 변수에는 숫자 2 자체가 들어가 있지만, numObj에는 { num: 2 } 오브젝트가 메모리에 들어 있는 주소인 **참조값**이 들어있다. 예를들어 주소가 x1234라고 한다면, x1234가 할당 되어짐.

<br/>

### 오브젝트를 가리키는 변수를 다른 변수에 할당하면?

```javascript
const a = { id: '1', count: 0 };
const b = { id: '2', count: 0 };
const c = b;
```

- 이 코드는 총 몇개의 오브젝트가 메모리에 생성 되었을까? => 2개
- 총 몇개의 변수가 메모리에 생성 되었을까? => 3개
- `const c = b;` 에서는 b 변수를 c에 할당하니, b 변수에 들어있던 **참조값 x234**가 c 변수에 **복사되어 할당됨**. 즉, c 변수에는 b 변수와 마찬가지로 x234 의 참조값이 들어있는 것임.
- 참조 값이 같으므로 b와 c 변수는 id: 2 인 동일한 오브젝트를 바라보고 있다.

```javascript
b.count = 1;
console.log(b);   // {id: "2", count:1}
console.log(c);   // {id: "2", count:1}
```

- 이 코드를 보면 b 변수를 이용해 b 변수가 가리키고 있는 오브젝트의 count 값을 변경하고, b와 c변수를 출력하면, 동일한 id: 2 인 그리고 count: 1 인 오브젝트를 출력함. 
- b와 c는 동일한 오브젝트를 가리키고 있기 때문에 b, c를 통해서 수정하게 되면 b, c 둘다 수정된 내용을 바로 적용받게 되는 것임.

이렇게 되는 이유는 오브젝트는 값(value) 자체가 변수에 저장되는 것이 아니라, 참조값(Reference)이 저장되기 때문.

그래서 아무리 오브젝트 변수를 const 라고 상수 변소로 저장해 두어도, 참조 값 자체는 바꿀 수 없지만(다른 오브젝트로 다시 대체할 수 없지만) 오브젝트 자체의 데이터는 수정이 가능한 이유.

또, 오브젝트 변수를 함수 인자로 전달해서 함수 안에서 오브젝트를 변경해도, 함수 밖에서 다시 그 오브젝트의 변경사항을 볼 수 있다.

<br/>

### 배열로 연결해서 생각해보면

```javascript
const array = [
  { id: '1', count: 0 },
  { id: '2', count: 0 },
];
```

- 여기서 생성된 오브젝트는 몇개? => 3개
- id: 1인 오브젝트, id: 2 인 오브젝트, `배열 자체의 오브젝트` 까지. 총 3개.

```javascript
const array = [   // x567
  { id: '1', count: 0 },  // x123
  { id: '2', count: 0 },  // x234
];
const array2 = array;
const array3 = [...array];
```

array2와 array3 각각의 변수에는 어떤 값이 할당 되어 있을까?

```javascript
const array = [   // x567
  { id: '1', count: 0 },  // x123
  { id: '2', count: 0 },  // x234
];
const array2 = array;  // x567
const array3 = [...array];  // x999
```

- array2
  - array2 에는 단순히 array 변수를 할당하니, array에 있던 참조값인 x567이 그대로 할당됨.
  - 즉, array와 array2는 동일한 배열 오브젝트를 가리키므로, 
  - 한쪽에서 id: 1 인 오브젝트의 count 를 변경해도 둘 다 변경된 내용을 볼 수 있고, 한쪽에서 배열에 새로운 아이템을 추가 해도 **둘다** 총 3개의 아이템이 들어있다.
- array3
  - 단순히 참조값을 가지고 온게 아니라, Spread Operator를 이용해서 array에 있는 모든 아이템들을 새로운 배열로 가지고 와서 새로운 배열을 만들게 됨. 그래서 완전히 새로운 배열 오브젝트를 가리키게 됨.
  - ⭐️⭐️ 하지만!! 이 Spread Operator는 배열 안의 모든 오브젝트 내용들을 일일이 복사해서 새로운 것을 만드는 것이 아니라, 오브젝트는 그대로 두고 array 배열을 빙글빙글 돌면서 각각의 아이템들의 **참조값을 복사**하게 됨.
  - 즉, array3 배열 안에는 array 안에 들어 있는 동일한 오브젝트들이 들어 있다. 다만 `배열 오브젝트 자체`만!!! 새롭게 만들어진다.
  - 그래서 array3은 새롭게 만들어진 배열 오브젝트 x999 참조값이 들어 있고, array3[0] 에는 x123, array3[1] 에는 x234가 들어있다.
  - 한쪽에서(array) id: 1 인 오브젝트의 count를 변경해도 `둘다(array, array3)` 변경된 내용을 볼 수 있고,
  - 한쪽에서(array) 배열에 새로운 아이템을 추가하면 다른쪽(array3)에서는 새로 추가된 아이템을 볼 수 없다. 둘은 엄연히 **다른 오브젝트**(물건을 담고 있는 껍데기, 컨테이너) 이기 때문임.

<br/>

📌 Spread Operator는 Shallow-cloneing 을 한다.

- 배열 안에 있는 모든 오브젝트 또 그 안에 들어 있을 수 있는 오브젝트들까지 모두 다 한땀한땀씩 새로운 것으로 바꿔주는게 아니라, 단순히 제일 상위의 배열 껍데기만 새로운 껍데기로 바꿔주고 안의 오브젝트는 예전의 그것의 참조값을 복사해온다.
- Spread Operator를 이용하면 처음에는 안에 들어있는 내용물들을 복사해오지만(값이 아니라 레퍼런스, 참조값), 배열 자체는 새로운 것을 만들기 때문에 배열에 아이템을 삭제하거나, 추가하면 배열의 내용은 달라질 수 있다.
