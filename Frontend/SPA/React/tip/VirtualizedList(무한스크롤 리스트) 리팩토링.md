# VirtualizedList(무한스크롤 리스트) 리팩토링

> [출처](https://www.bucketplace.com/post/2024-09-11-virtualizedlist-%EB%AC%B4%ED%95%9C%EC%8A%A4%ED%81%AC%EB%A1%A4-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%EA%B0%9C%EB%B0%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0/)

![Group_12 (1) (1) (1)](https://github.com/user-attachments/assets/7c7809fd-7784-405c-b2ae-4bca8db7b79a)

VirtualizedList(가상 리스트)는 나열된 리스트의 아이템 중 화면에 실제로 보이는 아이템만 렌더링하는 기술이다. 유저가 스크롤을 내리면 화면에 보이는 아이템의 범위가 바뀌고, 그에 따라 렌더링 되는 아이템도 바뀌게 된다.

![image](https://github.com/user-attachments/assets/ddeaef1d-7398-40ed-9476-73767b569816)

그림에서 Item1, 2, 99, 100은 화면을 벗어난 곳에 위치해 있기 때문에 현재 시점에서는 렌더링 되지 않지만, 유저가 스크롤을 내리거나 올려 위치를 변경하면 렌더링 될 수 있다. 이로 인해 유저는 마치 리스트가 처음부터 끝까지 차례로 구성된 것처럼 느끼게 된다. 바로 이 점 때문에 Virtualized List (가상 리스트)라는 이름이 붙게 되었다. 화면에 없는 아이템을 실제로 존재하는 것처럼 생각하게 만드는 것이다.

가상 리스트는 현재 가지고 있는 아이템의 끝에 다다르게 되면, 서버에서 다시 데이터를 받아오면서 계속 스크롤을 내릴 수 있도록 구현되는데, 이 모습이 마치 무한히 리스트가 있는 것처럼 느껴지기에 Infinite Scrolling이라 불리기도 한다. 가상 리스트와 함께 자주 쓰이는 개념이다.

<br/>

## 기존 가상 리스트를 바꾸게 된 배경

[초창기 글](https://www.bucketplace.com/post/2020-09-10-%EC%98%A4%EB%8A%98%EC%9D%98%EC%A7%91-%EB%82%B4-%EB%AC%B4%ED%95%9C%EC%8A%A4%ED%81%AC%EB%A1%A4-%EA%B0%9C%EB%B0%9C%EA%B8%B0/)에도 언급 되었듯, 가상 리스트 라이브러리들은 '반응형으로 한 row(행)'에 보여줄 아이템의 개수를 변경하지 못하는 문제가 있어 모든 기능을 직접 구현했었음. 유지 보수 문제가 있음.

현재는 관련 라이브러리들이 업뎃 되면서 문제 해결되었음. 기본 기능은 라이브러리를 이용하고, 부가적 필요 기능은 wrapping 하여 커버하는 모키 패칭 기법으로 리팩토링.

<br/>

## 라이브러리 선택

다운수, 업뎃 시점, 원하는 기능 커버 3가지 조건을 고려해 [virtuoso](https://virtuoso.dev/) 라이브러리 선택

![image](https://github.com/user-attachments/assets/2707cd92-c0c3-456b-9e40-e8a239177f03)

현재 시점은 virtuoso 대비 tanstack의 virtual-core의 점유율 상승. tanstack-query의 사용이 많아지면서 덩달아 점유율이 올라감.

<br/>

## 페이지 재방문 시 스크롤 복귀

대부분 기능은 virtuoso로 구현할 수 있었지만, 가장 어려웠던 기능인 '페이지 재방문 시 스크롤 복귀'에 대해 설명한다.

### 스크롤 복귀 위치를 저장하는 방식

유저가 페이지 진입했을 때

1. 스크롤 복귀가 필요한지
2. 저장된 스크롤 위치 정보가 현재 페이지와 같은지

를 판단하기 위해 **같은 페이지인지 구분하는 uniqueId** 를 생성해야 함. '같은 페이지'의 기준이 모호해 명확히 하기 위해 볓 가지 예를 들어 본다.

1. 가상 리스트를 사용하는 A 페이지에서 스크롤을 내린 후, B 페이지로 이동한 다음 뒤로 가기 버튼을 눌러 A 페이지로 돌아왔을 때(결과: A 페이지에서 보던 스크롤 위치로 복귀 되어 있어야 함)
2. 가상 리스트를 사용하는 A 페이지에서 스크롤을 내린 후 , 새로고침을 했을 때 (결과 : 페이지에서 보던 스크롤 위치로 복귀되어 있어야 함)
3. 가상 리스트를 사용하는 A 페이지에서 스크롤을 내린 후 , B페이지로 이동한 다음, 네비게이션의 메뉴를 클릭해 A 페이지로 돌아왔을 때 (결과 : 페이지의 스크롤은 초기화 되어있어야 함)

결국 '새로 고침'이나 '뒤로가기'와 같이 A 페이지를 보고 있다 되돌아왔다는 것이 보장된 상황에서만 '저장된 스크롤 위치를 받아와 이동'하는 스크롤 복귀를 수행해야 함. 이 기술 구현은 history API와 연관이 있다.

![gif첨부 (1)](https://github.com/user-attachments/assets/54d64a68-fba5-47e4-9e45-0a93f12f1cc2)

1)state 넣기 2) 새로고침 / 뒤로가기 시 3) 페이지 재 진입 시

먼저 홈 화면에서 history.pushState 함수를 실행, history.state에 특정 값을 세팅해준다. 이후 새로고침해 history.state 값을 체크해보면, 처음에 세팅한 값이 그대로 남아있는 것을 확인. 하지만, 다른 페이지로 이동한 후 로고를 클릭해 다시 홈으로 돌아오면 세팅 값이 날라감

이런 history API의 특성을 이용해 페이지에서 벗어날 때 생성한 uniqueId를 history.state에 저장해두고, 페이지 접근 시 똑같은 Id가 history.state에 있는지 확인하는 방식으로 스크롤 복귀 로직을 구성함.

이제 페이지를 벗어날 때 uniqueid를 이용해 보고 있던 스크롤 위치의 정보를 저장, 페이지 재진입할 때 정보를 다시 받아올 수 있게 되었다.

### 렌더링이 완료된 후 스크롤 이동

그런데 만약 스크롤 할 위치를 알고 있더라도 해당 위치까지 페이지가 렌더링 되어 있지 않다면, 원하는 위치로 이동할 수 없게 됩니다.

1. 큰 padding을 먼저 렌더링하고, 스크롤 복귀 이후 원래 아이템으로 렌더링하는 방식
2. 스크롤 위치에 도달할 때까지 반복적인 스크롤 이동을 시도하는 방식

1번 방식을 이용하면 스크롤 복귀가 확실하게 이루어지지만, 유저가 잠시동안 아무것도 없는 빈 공간을 볼 수 있고, 또 원래 아이템으로 바꿔 렌더링하는 시점을 찾기가 어렵다. 2번 방식을 이용하면 UI가 자연스럽지만, 스크롤 위치가 정확하지 않을 수 있고 무한 루프에 빠질 수 있다는 단점이 존재.

처음에는 1번 방식을 시도했으나, 원래 아이템으로 복귀하는 시점을 찾기가 쉽지 않았다. 그래서 2번 방식을 이용하되 반복 횟수에 조건을 걸고 여러 번 스크롤 이동을 시도하는 방식으로 구현.

### 스크롤 복귀 위치의 데이터 불러오기

이제 스크롤 위치로 이동할 수 있게 되었지만, 이동한 곳에서 유저에게 아이템이 한참 후에야 뜨는 현상이 발생. 왜 그럴까요? 첫 번째 데이터부터 순차적으로 받아오면서 복귀한 위치에 있는 아이템의 데이터는 위쪽의 데이터가 모두 받아진 후에야 받아오기 때문. 이 문제를 해결하기 위해서는 서버에서 클라이언트에 infinite scroll을 지원하는 방식에 대한 이해가 필요. 크게 2가지 방식.

1. pageOffset 방식
2. cursor 방식

pageOffset 방식은 (page, per) ⇒ items 의 구조를 가지고 있습니다. 원하는 페이지와 페이지별 아이템의 개수를 넘기면 해당 페이지의 아이템들을 내려주는 방식. 클라이언트는 데이터를 1번 페이지부터 불러올 필요 없이 중간 page도 한 번에 요청할 수 있다는 장점이 있다.

cursor 방식은 (token, per) ⇒ (items, nextToken) 구조를 가지고 있다. 이전에 불러온 데이터의 nextToken 값을 기준으로 다음 데이터를 요청한다. cursor 방식은 일반적으로 단방향으로 작동하기 때문에 이전 데이터를 불러오지 못하고 다음 데이터만 불러올 수 있다. 따라서 클라이언트가 스크롤 복귀 위치의 아이템을 불러올 token 값을 알고 있어도, 스크롤을 위로 올리는 순간 데이터를 불러올 수 없는 문제가 생겨버린다.

이를 극복하기 위해 양방향 cursor 방식을 도입할 수 있는데요. 바로 (token, per) ⇒ (items, prevToken, nextToken) 구조로 prevToken을 추가하는 방식이다. 이렇게 구현하면 데이터를 유지보수하기 쉬운 cursor 방식을 사용하면서도, 스크롤 복귀 시 위쪽으로 스크롤을 올려도 데이터를 받아올 수 있다. 비록 아직 양방향 cursor 방식을 구현하진 않았음.

이렇게 우여곡절 끝에 스크롤 복귀 기능이 완성되었습니다.

<br/>

## 기존에 없던 기능 추가

 아이템과 다른 UI를 중간에 삽입하는 기능도 추가함. 예를 들어 배너와 같은 컴포넌트.

![image](https://github.com/user-attachments/assets/3851f6e6-fcf8-4279-911b-f265bc01d94b)

중간에 주입할 item은 InsertedItem의 배열 형태로 받으며, 내부에는 주입할 행을 나타내는 rowIndex 와 주입할 아이템인 component 가 있다.

이 배열을 이용해서 VirtualizedList 내부에서 insertedItem이 원하는 rowIndex에 렌더링될 수 있도록 구현하고, 해당 아이템 이후에 위치하는 기존 행들은 rowIndex가 1씩 증가하는 방식으로 구현.

이를 간단히 코드를 표현해 보자면 다음과 같음.

![image](https://github.com/user-attachments/assets/41ba30af-5ae4-4bc9-ba5c-86103c1f0514)

- [추천 콘텐츠 페이지](https://contents.ohou.se/topics/recommend)
- [쇼핑홈 페이지](https://store.ohou.se/)
- [인테리어 시공업체 찾기 페이지](https://o2o.ohou.se/remodeling/business/discovery)

