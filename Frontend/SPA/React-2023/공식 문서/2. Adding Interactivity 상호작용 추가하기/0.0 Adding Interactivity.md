# Adding Interactivity

화면의 일부 항목은 사용자 입력에 따라 업데이트된다. 예를 들어, 이미지 갤러리를 클릭하면 활성 이미지가 전환된다. React에서는 시간이 지남에 따라 변하는 데이터를 *state*라고 한다. 모든 컴포넌트에 state를 추가하고 필요에 따라 업데이트할 수 있다. 이 장에서는 상호작용을 처리하고, state를 업데이트하고, 시간에 따라 다른 출력을 표시하는 컴포넌트를 작성하는 방법을 배운다.

## 이벤트에 응답하기

React를 사용하면 JSX에 이벤트 핸들러를 추가할 수 있다. 이벤트 핸들러는 클릭, 마우스 오버, input에 초점 맞추기와 같은 사용자 상호작용에 반응해 촉발되는 자체 함수다.

`<button>` 과 같은 기본 제공 컴포넌트는 `onClick`과 같은 기본 제공 브라우저 이벤트만 지원한다. 그러나 자체 컴포넌트를 생성하고 이벤트 핸들러 props에 원하는 어플리케이션 별 이름을 지정할 수 있다.

## state: 컴포넌트의 메모리

컴포넌트는 상호 작용의 결과로 화면의 내용을 변경해야 하는 경우가 많다. 양식에 입력하면 입력 필드가 업데이트되어야 하고, 이미지 캐러셀에서 ‘다음’을 클릭하면 표시되는 이미지가 변경되어야 하며, ‘구매’를 클릭하면 장바구니에 제품이 담겨야 함. 컴포넌트는 현재 입력값, 현재 이미지, 장바구니와 같은 것들을 **기억**해야 함. React에서는 이런 종류의 컴포넌트별 메모리를 *state*라고 부른다.

컴포넌트에 state를 추가하려면 [`useState`](https://react-ko.dev/reference/react/useState) 훅을 사용하면 된다. *훅*들은 컴포넌트가 React 기능을 사용할 수 있게 해주는 특수한 함수들입니다(state는 그 기능 중 하나임). `useState` 훅을 사용하면 state 변수를 선언할 수 있다. 초기 state를 받아 현재 state와 이를 업데이트할 수 있는 state 설정자 함수의 값 쌍을 반환함.

## 렌더링하고 커밋하기

컴포넌트가 화면에 표시되기 전에, 컴포넌트들은 React에서 렌더링해야 함. 이 프로세스의 단계를 이해하면 코드가 어떻게 실행되는지 생각하고 그 동작을 설명하는 데 도움이 된다.

컴포넌트가 주방에서 재료로 맛있는 요리를 만드는 요리사라고 상상해보자. 이 시나리오에서 React는 고객의 요청을 접수하고 주문을 가져오는 웨이터 역할을 한다. UI를 요청하고 제공하는 이 과정은 세 단계로 이루어짐.

1. 렌더링 **발동**(식당의 주문을 주방으로 전달) -> Trigger
2. 컴포넌트 **렌더링**(주방에서 주문 준비) -> Render
3. DOM에 **커밋**(테이블에 주문 배치) -> Commit

<img width="1141" alt="image" src="https://github.com/pozafly/TIL/assets/59427983/bf525886-0e2a-480f-ae51-5527dea9f50f">

## 스냅샷으로서의 state

일반 JavaScript 변수와 달리 React state는 스냅샷처럼 동작함. state 변수를 설정해도 이미 가지고 있는 state 변수는 변경되지 않고 대신 리렌더링 된다.

```js
console.log(count);  // 0
setCount(count + 1); // Request a re-render with 1
console.log(count);  // Still 0!
```

오.. 요 매커니즘이구나.

React는 이런 식으로 작동하면 미묘한 버그를 피할 수 있음.

## 여러 state 업데이트를 큐에 담기

## 객체 state 업데이트

