# 컴포넌트 순수성 유지

일부 JavaScript 함수는 *순수*하다. 순수 함수는 계산만 수행하고 그 이상은 수행하지 않습니다. 컴포넌트를 엄격하게 순수 함수로만 작성하면 코드베이스가 커짐에 따라 당황스러운 버그와 예측할 수 없는 동작을 피할 수 있습니다. 하지만 이러한 이점을 얻으려면 몇 가지 규칙을 준수해야 합니다.

## 순수성: 수식으로서의 컴포넌트

함수형 프로그래밍의 세계에서 순수함수는 다음과 같은 특징을 가진 함수다.

- 자신의 일에만 신경쓴다. 호출되기 전에 존재했던 객체나 변수를 변경하지 않는다.
- 동일 입력, 동일 출력. 동일한 입력이 주어지면 항상 동일한 결과를 반환해야 한다.

React는 모든 컴포넌트가 순수 함수라고 가정한다. 즉, React 컴포넌트는 동일한 입력이 주어지면 동일한 JSX를 반환해야 한다.

## 사이드 이펙트: 의도하지 (않은) 결과

React 렌더링 프로세스는 항상 순수해야 한다. 컴포넌트는 오직 JSX만을 반환해야 하고, 렌더링 전에 존재했던 객체나 변수를 변경해서는 안된다.

```jsx
let guest = 0;

function Cup() {
  // 나쁨: 기존 변수를 변경합니다!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

<img width="210" alt="image" src="https://github.com/pozafly/TIL/assets/59427983/02bd61eb-675e-4acb-b8c0-e6dff4245a12">

이 컴포넌트는 `guest` 외부 변수를 읽고 쓰고 있다. 호출 될 때마다 다른 JSX가 생성된다는 뜻이다. 다른 컴포넌트가 gest를 읽으면 렌더링된 시점에 따라 JSX가 다르게 생성된다.

[`guest`를 prop으로 전달](https://react-ko.dev/learn/passing-props-to-a-component)함으로써 이 컴포넌트를 고칠 수 있다

```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
```

props만 의존하므로 순수하다.

[StrictMode](https://github.com/pozafly/TIL/blob/main/Frontend/SPA/React-2023/tip/Strict%20Mode.md)에 대해선 여기.

Side Effect는 DOM 수정도 마찬가지이다. Ajax 요청하는 것도.

- DOM 수정
- Ajax 요청 (데이터 페칭)
- 상태 변경
- 이벤트 처리
- 타이머 설정(setTimeout, setInterval)
- 외부 라이브러리 사용

<br/>

## 사이드 이펙트를 일으킬 수 있는 곳

함수형 프로그래밍은 순수성에 크게 의존하지만, 언젠가는 뭔가 바뀌어야 한다. 화면 업데이트, 애니메이션 제작, 데이터 변경과 같은 이런 변경을 **사이드 이펙트**라고 하고, 렌더링 중 일어나는 것이 아니라 '부수적으로' 일어나는 일이다.

React에서 사이드 이펙트는 보통  **[이벤트 핸들러](https://react-ko.dev/learn/responding-to-events)에 속한다**. 이벤트 핸들러는 사용자가 어떤 동작을 수행할 때(버튼 클릭) react가 실행하는 함수다. 이벤트 핸들러가 **컴포넌트 내부에 정의**되어 있긴 하지만 렌더링 중에 실행되지 않는다. 따라서 **이벤트 핸들러는 순수할 필요가 없다**.

다른 모든 옵션을 다 사용했는데도 사이드 이펙트에 적합한 이벤트 핸들러를 찾을 수 없다면, 컴포넌트에서 [`useEffect`](https://react-ko.dev/reference/react/useEffect) 호출을 통해 반환된 JSX에 이벤트 핸들러를 첨부할 수 있다. 이렇게 하면 나중에 렌더링 후 사이드 이펙트가 허용될 때 React가 이를 실행하도록 지시한다. 하지만 **이 방법은 최후의 수단으로 사용해야 한다**.

가능하면 렌더링 만으로 로직을 표현하고자 해야 함.

<br/>

## 왜 리액트는 순수성을 중시 할까?

- 컴포넌트를 다른 환경(예: 서버)에서 실행할 수 있다. 동일 입력에 대해 동일 결과를 반환하기 때문에 하나의 컴포넌트가 많은 사용자 요청을 처리할 수 있다.
- 입력이 변경되지 않은 컴포넌트는 [렌더링 건너뛰기](https://react-ko.dev/reference/react/memo)를 통해 성능을 향상시킬 수 있다. 순수 함수는 항상 동일 결과를 반환하므로 캐싱해도 안전하다.
- 깊은 컴포넌트 트리를 렌더링 하는 도중에 일부 데이터가 변경되면 React는 오래된 랜더링을 완료하기 위해 시간을 낭비하지 않고 렌더링을 다시 시작할 수 있다. 순수성 덕분에 언제든지 계산을 중단해도 안전하다.
- 새로운 react 모든 기능은 순수성의 이점을 활용함. 이는 패러다임임.

<br/>

## 요약

- 컴포넌트는 순수해야 한다:
  - **자신의 일에만 신경쓴다.** 렌더링 전에 존재했던 객체나 변수를 변경하지 않아야 한다.
  - **동일한 입력, 동일한 출력.** 동일한 입력이 주어지면 컴포넌트는 항상 동일한 JSX를 반환해야 한다.
- 렌더링은 언제든지 발생할 수 있으므로, 컴포넌트는 서로의 렌더링 순서에 의존해서는 안 된다.
  - `이게 무슨 말이지?`

- 컴포넌트가 렌더링에 사용하는 어떠한 입력값도 변이해서는 안된다. 여기에는 props, state 및 context가 포함된다. 화면을 업데이트하려면 기존 객체를 변이하는 대신 [“set” state](https://react-ko.dev/learn/state-a-components-memory)를 사용해라.
- 컴포넌트의 로직을 반환하는 JSX 안에 표현하기 위해 노력해라. “무언가를 변경”해야 할 때는 보통 이벤트 핸들러에서 이 작업을 수행하고자 할 것임. 최후의 수단으로 `useEffect`를 사용할 수도 있다.
- 순수 함수를 작성하는 데는 약간의 연습이 필요하지만, React 패러다임의 힘을 발휘할 수 있다.
