# Escape Hatches

컴포넌트 중 일부는 React 외부의 시스템을 제어하고 동기화해야 할 수 있다. 예를 들어, 브라우저 API를 사용해 input에 초점을 맞추거나, React 없이 구현된 비디오 플레이어를 재생 및 일시정지하거나, 원격 서버에 연결해서 메시지를 수신해야 할 수 있다. 이 장에서는 React의 “외부”로 나가서 외부 시스템에 연결할 수 있는 탈출구를 배우게 된다. 대부분의 애플리케이션 로직과 데이터 흐름은 이러한 기능에 의존해서는 안 된다.

## ref로 값 참조하기

컴포넌트가 특정 정보를 ‘기억’하도록 하고 싶지만 해당 정보가 [새 렌더링을 촉발](https://react-ko.dev/learn/render-and-commit)하지 않도록 하려는 경우 ref를 사용할 수 있다

```js
const ref = useRef(0);
```

state와 마찬가지로 ref는 리렌더링 사이에 React에 의해 유지된다. 다만 state를 설정하면 컴포넌트가 다시 렌더링되는 반면, ref를 변경하면 그렇지 않다! `ref.current` 프로퍼티를 통해 해당 ref의 현재 값에 접근할 수 있다.

ref는 React가 추적하지 않는 컴포넌트의 비밀 주머니와 같다. 예를 들어, ref를 사용하여 컴포넌트의 렌더링 출력에 영향을 주지 않는 [timeout ID](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#return_value), [DOM 엘리먼트](https://developer.mozilla.org/en-US/docs/Web/API/Element) 및 기타 객체를 저장할 수 있다.

## ref로 DOM 조작하기

React는 렌더링 출력과 일치하도록 DOM을 자동으로 업데이트하므로 컴포넌트에서 자주 조작할 필요가 없다. 하지만 때로는 노드에 초점을 맞추거나 스크롤하거나 크기와 위치를 측정하기 위해 React가 관리하는 DOM 요소에 접근해야 할 수도 있다. React에는 이러한 작업을 수행할 수 있는 빌트인된 방법이 없으므로 DOM 노드에 대한 ref(참조)가 필요하다. 예를 들어, 버튼을 클릭하면 ref를 사용해 input에 초점을 맞춘다

## Effect와 동기화하기

일부 컴포넌트는 외부 시스템과 동기화해야 한다. 예를 들어, React state에 따라 비 React 컴포넌트를 제어하거나, 서버 연결을 설정하거나, 컴포넌트가 화면에 표시될 때 분석 로그를 보내야 할 수 있다. 특정 이벤트를 처리할 수 있는 이벤트 핸들러와 달리 *Effect*를 사용하면 렌더링 후 일부 코드를 실행할 수 있다. 이를 사용해 컴포넌트를 React 외부 시스템과 동기화할 수 있다.

많은 Effect는 스스로 “정리”하기도 함. 예를 들어, 채팅 서버에 대한 연결을 설정하는 Effect는 해당 서버에서 컴포넌트의 연결을 끊는 방법을 React에 알려주는 *클린업 함수*를 반환해야 함.

개발 모드에서 React는 즉시 실행되고 Effect를 한 번 더 정리합니다.

## Effect가 필요하지 않을 수도 있다

Effect는 React 패러다임에서 벗어날 수 있는 탈출구이다. 이를 통해 React의 “외부”로 나가서 컴포넌트를 외부 시스템과 동기화할 수 있다. 외부 시스템이 관여하지 않는 경우(예: 일부 prop이나 state가 변경될 때 컴포넌트의 state를 업데이트하려는 경우)에는 Effect가 필요하지 않다. 불필요한 Effect를 제거하면 코드를 더 쉽게 따라갈 수 있고, 실행 속도가 빨라지며, 오류 발생 가능성이 줄어든다.

Effect가 필요하지 않은 일반적인 경우는 두 가지가 있다.

- **렌더링을 위해 데이터를 변환할 때 Effect는 필요하지 않다.**
- **사용자 이벤트를 처리할 때 Effect는 필요하지 않다.**

반대로 외부 시스템과 동기화하려면 Effects가 필요할 것이다.

## 반응형 Effect의 생명주기

Effect는 컴포넌트와 다른 생명주기를 가진다. 컴포넌트는 마운트, 업데이트 또는 언마운트할 수 있다. 반면 Effect는 동기화를 시작하거나 동기화를 중지하는 두 가지 작업만 할 수 있다. Effect가 시간에 따라 변하는 prop 및 state에 의존하는 경우 이 주기는 여러 번 발생할 수 있다.

React는 Effect의 의존성을 올바르게 지정했는지 확인하는 린터 규칙을 제공.

## 이벤트와 Effect 분리하기

이벤트 핸들러는 동일한 상호작용을 다시 수행할 때만 다시 실행된다. 이벤트 핸들러와 달리 Effect는 prop이나 state 변수처럼 읽은 값이 마지막 렌더링에서와 다른 경우 다시 동기화한다. 때로는 두 가지 동작을 혼합하여 일부 값에는 반응하지만 다른 값에는 반응하지 않는 Effect를 원할 수 있다.

Effect 내의 모든 코드는 *반응형*이며, 읽은 반응형 값이 리렌더링으로 인해 변경된 경우 다시 실행된다.

## Effect 의존성 제거하기

Effect를 작성할 때, Effect의 의존성 목록에서 Effect가 읽는 모든 반응형 값(예: prop 및 state)을 포함했는지 확인한다. 이렇게 하면 Effect가 컴포넌트의 최신 prop 및 state와 동기화된 상태를 유지할 수 있다. 불필요한 의존성으로 인해 Effect가 너무 자주 실행되거나 무한 루프를 생성할 수도 있다. 의존성을 제거하는 방법은 경우에 따라 다르다.

## 커스텀 훅으로 로직 재사용하기

React에는 `useState`, `useContext`, `useEffect`와 같은 훅이 빌트인되어 있다. 때로는 데이터를 페치하거나, 사용자가 온라인 상태인지 추적하거나, 채팅방에 연결하는 것과 같이 좀 더 구체적인 목적을 위한 훅이 있었으면 좋겠다. 이를 위해 애플리케이션의 필요에 맞는 고유한 훅을 만들 수 있다.





















