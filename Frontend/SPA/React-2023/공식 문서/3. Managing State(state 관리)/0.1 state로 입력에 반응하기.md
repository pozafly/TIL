# State로 입력에 반응하기

React는 UI를 조작하는 선언적인 방법을 제공함. UI를 개별적으로 직접 조작하는 대신 컴포넌트가 있을 수 있는 다양한 상태를 기술하고, 사용자 입력에 반응하여 각 상태들 사이를 전환한다. 이는 디자이너가 UI를 바라보는 방식과 유사함.

## 선언형 UI와 명령형 UI의 차이점

UI 인터렉션을 디자인할 때 사용자의 행동에 따라 UI가 어떻게 변하는지에 대해서 생각해봤을 것이다.

- 폼에 무언가를 입력하면 'Submit' 버튼이 **활성화될** 것.
- '제출' 버튼을 누르면 폼과 버튼이 **비활성화** 되고 **스피너가 나타날** 것.
- 네트워크 요청이 성공한다면 form은 **숨겨질** 것이고 'Thank you'메세지가 **나타날** 것.
- 네트워크 요청이 실패한다면 오류 메세지가 **보일** 것이고 form은 다시 **활성화** 될 것.

명령형 프로그래밍에서 위 내용은 인터랙션을 구현하는 방법에 직접적으로 해당한다. 방금 일어난 일에 따라 UI를 조작하기 위한 정확한 지침을 작성해야 한다.

컴퓨터에게 스피너부터 버튼까지 각 요소에 '명령'을 내려 컴퓨터에 *어떻게* UI를 업데이트할 내용을 지시해야 하므로, 이를 *명령형*이라고 부른다.

UI를 조작하는 것은 복잡한 시스템에서는 관리하기가 기하급수적으로 어려워진다. 다양한 form 양식으로 가득 찬 페이지를 업데이트 해야 한다고 생각해보자. 새로운 UI 요소나 새로운 인터랙션을 추가하려면 기존의 모든 코드를 주의 깊게 살펴 버그의 발생 여부(예를 들어, 무언가를 표시하거나 숨기는 것을 잊는 등)를 확인해야 한다.

React는 이런 문제를 해결하기 위해 만들어졌음.

React에서는 직접 UI를 조작하지 않는다. 즉, 컴포넌트를 직접 활성화하거나 비활성화 하지도, 보여주거나 숨기지도 않는다. 대신 **표시할 내용을 선언하면** React가 UI를 업데이트할 방법을 알아낸다. 택시를 타고 기사에게 정확히 어디서 꺾어야 할지를 알려주는 대신 어디로 가고 싶은지만 말한다 생각해보자. 목적지까지 데려다주는 것은 택시기사의 몫임.

<img width="525" alt="image" src="https://github.com/pozafly/TIL/assets/59427983/df543be9-df18-4f12-aa77-ba992eb019b1">

<br/>

## UI를 선언적인 방식으로 생각하기

React로 다시 구현하는 과정을 살펴보자.

1. 컴포넌트의 다양한 시각적 상태를 **식별**한다.
2. 상태 변화를 촉발하는 요소를 **파악**함.
3. `useState`를 사용하여 메모리의 상태를 **표현**함.
4. 비필수적인 state 변수를 **제거**함.
5. 이벤트 핸들러를 **연결**하여 state를 설정함.

### Step 1: 컴포넌트의 다양한 시각적 상태 식별하기

먼저 사용자에게 표시될 수 있는 UI의 다양한 '상태'를 모두 시각화해야 한다.

- 비어있음: 버튼은 비활성화 되어있음.
- 입력중: 버튼이 활성화 되어있음.
- 제출중: form자체가 비활성화, spinner가 표시된다.
- 성공시: form은 없어지고 성공 메시지 표시.
- 실패시: 입력중 상태와 동일하지만 추가로 오류 메시지가 표시된다.

### Step 2: 상태 변경을 촉발하는 요인 파악하기

두 종류의 입력에 대한 응답으로 상태 변경을 촉발할 수 있다:

- **사람의 입력**: 버튼 클릭, 필드 입력, 링크 이동 등
- **컴퓨터의 입력**: 네트워크에서 응답 도착, 시간 초과, 이미지 로딩 등

두 경우 모두 **[state 변수](https://react-ko.dev/learn/state-a-components-memory#anatomy-of-usestate)를 설정해야 UI를 업데이트할 수 있다.** 개발중인 form의 경우 몇 가지 다른 입력에 따라 state를 변경해야함:

- **text 입력을 변경**(사람)하면 text box가 비어있는지 여부에 따라 *비어있음* state에서 입력중 state로, 또는 그 반대로 전환해야함.
- **제출 버튼을 클릭**(사람)하면 *제출중* state로 전환해야함.
- 네트워크 응답 성공(컴퓨터)시 *성공* state로 전환해야 함.
- 네트워크 요청 실패(컴퓨터)시 일치하는 오류 메세지와 함께 *오류* state로 전환해야 함.

이 흐름을 시각화하는 데 도움이 되도록 종이에 각 상태가 적힌 원을 그리고 각 상태 사이의 변경 사항을 화살표로 그려 봐라. 이 방식으로 흐름을 파악할 수 있을 뿐 아니라 구현하기 훨씬 전에 버그를 분류할 수 있다.

![image](https://github.com/pozafly/TIL/assets/59427983/746df228-0cb7-47a6-be3d-1dfb1a1593b1)

### Step 3: 메모리의 상태를 `useState` 로 표현하기

메모리에서 컴포넌트의 시각적 상태를 [`useState`](https://react-ko.dev/reference/react/useState)로 표현해야함. 이 과정은 단순함이 핵심이다. 각 상태 조각은 "움직이는 조각"이며, **가능한 적은 수의 "움직이는 조각"을 원한다.** 복잡할수록 버그가 더 많이 발생함!

가장 좋은 방법을 즉시 생각하기 어렵다면 가능한 모든 시각적 상태를 *확실하게* 다룰 수 있을 만큼 충분한 state를 추가하는 것부터 시작해라.

### Step 4: 비필수적인 state 변수 제거하기

state 콘텐츠의 중복을 피해 필수적인 것만 추적하고 싶을 것입니다. state 구조를 리팩토링하는 데 약간의 시간을 투자하면 컴포넌트를 더 쉽게 이해하고, 중복을 줄이며, 의도하지 않은 경우를 피할 수 있다. 목표는 **state가 사용자에게 보여주기를 원하는 유효한 UI를 나타내지 않는 경우를 방지**하는 것이다. (예를 들어, 오류 메세지를 표시하면서 동시에 입력을 비활성화하면 사용자는 오류를 수정할 수 없게 된다!)

다음은 state 변수에 대해 물어볼 수 있는 몇가지 질문이다.

- **state가 모순을 야기하나?** 예를 들어, `isTyping` 과 `isSubmitting`은 동시에 `true`일 수 없습니다. 이러한 모순은 일반적으로 state가 충분히 제약되지 않았음을 의미함. 두 boolean의 조합은 네 가지가 가능하지만 유효한 state는 세 가지뿐입니다. '불가능한' state를 제거하려면 세 가지 값을 하나의 status로 결합하면 됩니다: `'typing'`, `'submitting'`, `'success'`.
- **다른 state 변수에 이미 같은 정보가 있나?** `isEmpty`와 `isTyping`은 동시에 `true`가 될 수 없다. 이를 각 state 변수로 분리하면 동기화되지 않아 버그가 발생할 위험이 있다. 다행히 `isEmpty`를 제거하고 대신 `answer.length === 0`으로 확인할 수 있다.
- **다른 state 변수를 뒤집으면 동일한 정보를 얻을 수 있나?** `isError`는 `error!== null`을 대신 확인할 수 있기 때문에 필요하지 않다.

### Step 5: 이벤트 핸들러를 연결하여 state 설정하기

모든 상호작용을 state 변화로 표현하면 나중에 기존 상태를 깨지 않고도 새로운 시각적 상태를 도입할 수 있다. 또한 인터랙션 자체의 로직을 변경하지 않고도 각 state에 표시되어야 하는 항목을 변경할 수 있다.

<br/>

## 요약

- 선언형 프로그래밍은 UI를 세밀하게 관리(명령형)하지 않고 각 시각적 상태에 대해 UI를 기술하는 것을 의미한다.
- 컴포넌트를 개발할 때
  1. 모든 시각적 상태를 식별하세요.
  2. 사람 및 컴퓨터가 상태 변화를 촉발하는 요인을 결정하세요.
  3. `useState`로 상태를 모델링하세요.
  4. 버그와 모순을 피하려면 비필수적인 state를 제거하세요.
  5. 이벤트 핸들러를 연결하여 state를 설정하세요
