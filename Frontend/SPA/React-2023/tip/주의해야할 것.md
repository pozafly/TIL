# 주의해야할 것

## 1. JSX에서 class가 아니라, className을 사용한다.



## 2. label에서 for 어트리뷰트가 아니라, htmlFor을 사용해야 한다.

마찬가지로, JavaScript의 `for` 예약어와 충돌하기 때문이다.



## 3. 조건부 렌더링에서 falsy 값

```jsx
export default function Some() {
  const bool = undefined;
  return bool && <div>Some</div>;
}
```

bool 변수가 falsy한 값이면, 태그가 보여지는 조건부 렌더링 컴포넌트이다. bool 변수를 true로 변경하면, 엘리먼트가 나타난다.

> falsy란, 조건식이나 논리 연산에서 false로 평가되는 값을 의미한다.

falsy한 값은, null, undefined, 0, "", NaN 등이 있다. 하지만 위 코드에서 `0`을 넣어볼까?

```jsx
export default function Some() {
  const bool = 0;
  return bool && <div>Some</div>;
}
```

`<div>Some</div>` 이 렌더링 되는게 아니라, `0`이 렌더링 된다. falsy한 값이라면 렌더링 되면 안되지만 0이 렌더링 되었다. 따라서 react에서 falsy한 값인, 0을 사용할 때 주의해주어야 한다.

`&&` 연산자로 평가하기 보다는 삼항 연산자를 사용하는 것이 좋다.

```jsx
export default function Some() {
  const bool = 0;
  return bool ? <div>Some</div> : null;
}
```



## 리렌더링 무한루프

```jsx
const [value, setValue] = useState(null);
function handleClick(i) {
  setValue(i);
}

<Square onClick={handleClick(0)} />
```

위 코드를 실행시키기만 해도 무한루프에 빠진다. 이유는 handleClick 함수를 식별자를 넘긴 것이 아니라 실행을 해버렸기 때문인데, 단순 함수를 실행하면 무한 루프를 돌지 않지만, `setValue` 라는 상태 값을 변경시키는 함수가 내부에 있기 때문에 무한루프를 돈다.

왜냐하면 react에서는 상태값을 변경시키면 랜더링이 다시 일어나기 때문이다. 렌더링이 다시 일어나면 onClick에 있는 `handleClick(0)` 함수가 다시 실행되고, 다시 상태값이 변경되고 다시 랜더링이 일어난다.

그러면 아래와 같이 함수를 반환하는 함수(고차 함수)로 만들어주면 된다.

```jsx
const [value, setValue] = useState(null);
function handleClick(i) {
  return () => {
    setValue(i);  
  }
}

<Square onClick={handleClick(0)} />
```

혹은, 

```tsx
const [value, setValue] = useState(null);
function handleClick(i) {
  setValue(i);
}

<Square onClick={() => handleClick(0)} />
```

`onClick` 자체에 함수 식별자가 아닌 함수 자체를 넣어주면 된다.

<br/>

## react에서 함수명 관례

props로 내려가는 함수 자체는 `on[Event]` 이름을 사용하며, 이벤트를 처리하는 함수는 `handle[Event]` 를 사용하는 것이 관계다. 위 코드처럼, props로 내려가는 함수는 `onClick`, 이벤트를 처리하는 함수는 `handleClick`.

