# 간단 RSC

> [출처](https://www.wooslog.com/blog/understanding-rsc)

Next.js 13.4가 릴리즈 되면서 App Router가 Stable 상태가 되었음.

## SSR and Suspense가 해결한 부분

SSR은 초기 페이지 로딩에 초점을 맞춰 pre-rendering 된 HTML을 클라이언트에 전송하고, 클라이언트가 일반적인 React 앱처럼 동작하기 전 다운로드한 JavaScript로 hydration 해야 한다. SSR은 페이지로 직접 이동할 때 **한 번** 발생한다.

SSR만 사용하면 사용자는 HTML을 더 빨리 얻을 수 있지만, JavaScript 와 상호작용하기 전 'all-or-nothing' 워터폴을 기다려야 한다.

- 모든 데이터는 서버에서 가져와야 표시할 수 있다.
- 모든 JavaScript는 서버에서 다운로드해야 클라이언트에서 hydration 할 수 있다
- 모든 hydration은 클라이언트에서 완료되어야만 상호 작용할 수 있다.

즉, RSC가 나온 이유는, **hydration 할 때 까지 걸리는 시간이 문제인 것**이다. 이 문제를 해결하기 위해 React는 서버 측 HTML 스트리밍과 클라이언트에서 선택적 하이드레이션을 허용하는 Suspense를 만들었다. 컴포넌트를 `<Suspense>`로  감싸면 서버에 해당 컴포넌트의 렌더링과 하이드레이션의 우선순위를 낮추도록 지시하여 다른 컴포넌트가 더 무거운 컴포넌트에 의해 차단되지 않고 로드될 수 있도록 할 수 있다.

서스펜스에 여러 컴포넌트가 있는 경우, React는 작성한 순서대로 트리를 따라 작동하기 때문에 어플을 최적으로 스트리밍할 수 있다. 하지만, 사용자가 특정 컴포넌트와 상호작용을 시도하면 해당 컴포넌트가 다른 컴포넌트보다 우선순위를 갖는다.

이렇게 하면 상황이 크게 개선되지만 여전히 몇 가지 문제가 남아 있다:

- 컴포넌트를 표시하기 전에 전체 페이지에 대한 데이터를 서버에서 가져와야 한다. 이 문제를 해결할 수 있는 유일한 방법은 `useEffect()` 훅을 통해 클라이언트 측에서 데이터를 가져오는 것인데, 이는 서버 측에서 가져오는 것보다 왕복 시간이 더 길고 컴포넌트가 렌더링되고 hydration된 후에만 발생한다.
- 모든 페이지 자바스크립트는 브라우저에 비동기적으로 스트리밍되더라도 결국 다운로드된다. 앱의 복잡성이 증가하면 사용자가 다운로드하는 코드의 양도 증가함.
- 하이드레이션을 최적화하더라도 사용자는 클라이언트 측 자바스크립트를 다운로드하여 해당 컴포넌트에 대해 구현할 때까지는 여전히 컴포넌트와 상호 작용할 수 없다.
- 자바스크립트 연산량의 대부분은 여전히 다양한 기기에서 실행되는 클라이언트에서 발생함. 더 강력하고 예측 가능한 서버로 옮기는 것은 어떨까?

![image](https://github.com/pozafly/TIL/assets/59427983/3131901a-af04-4d9f-900c-5dc6a96fde43)

RSC를 사용하지 않았을 때의 API 흐름.

## React 서버 컴포넌트의 기능은 무엇인가?

위의 문제를 해결하기 위해 React는 서버 컴포넌트를 만들었다. RSC는 개별적으로 데이터를 가져와 서버에서 렌더링하고, 결과 HTML은 필요에 따라 다른 서버 및 클라이언트 컴포넌트와 인터리빙하면서 클라이언트 측 React 컴포넌트 트리로 스트리밍된다.

이 프로세스는 클라이언트 측에서 다시 렌더링할 필요가 없으므로 성능이 향상된다. 모든 클라이언트 컴포넌트의 경우, 컴퓨팅 부하가 클라이언트와 서버 간에 공유되므로 하이드레이션은 스트리밍되는 RSC와 동시에 발생할 수 있다.

다시 말해, 훨씬 더 강력하고 데이터 소스에 물리적으로 더 가까운 서버가 컴퓨팅 집약적인 렌더링을 처리하고 인터랙티브한 코드만 클라이언트로 전송한다.

상태 변경으로 인해 RSC를 다시 렌더링해야 하는 경우 서버에서 새로 고침하고 하드 새로 고침 없이 기존 DOM에 원활하게 병합한다. 따라서 서버에서 뷰의 일부가 업데이트되더라도 클라이언트 상태는 유지된다.

## Server Components는 무엇을 할까?

- JavaScript 번들 크기를 줄이고 로딩 성능을 개선하는데 도움이 된다.
  - 서버 컴포넌트를 사용하면 초기 페이지 로딩이 더 빠르고 간결해진다. 기본 클라이언트 측 런타임은 캐싱이 가능하고 크기가 예측 가능하며 어플리케이션이 커져도 증가하지 않는다.
- data fetching 시 [워터폴](https://nextjs.org/docs/app/building-your-application/data-fetching/patterns#parallel-and-sequential-data-fetching)을 방지해 server side 데이터 종속성을 빠르게 해결한다.
  - 기존 클라이언트측 렌더링에서 컴포넌트는 비동기 작업이 완료되기를 기다리는 동안 react suspense를 사용해 렌더링 프로세서를 '일시 중지'하고 폴백 상태를 표시한다. RSC를 사용하면 데이터 불러오기와 렌더링이 모두 서버에서 이루어지므로 Suspense는 서버 측에서도 대기 기간을 관리해 총 왕복 시간을 단축해 폴백 및 완료된 페이지의 렌더링 속도를 높인다.

## 올바른 RSC 사용방법

- Server와 Client components 균형 맞추기
  - 개발자는 server-side rendering 및 data fetching에는 RSC를 활용하고, 지역적으로 사용되는 상호작용 기능 및 사용자 경험에는 클라이언트 커포넌트 사용을 고려하자. 적절한 균형을 유지하면 고성능의 효율적 어플을 만들 수 있음.
- Next.js와 함께 data fetching을 향상시키는 데 사용하낟.
  - RSC는 서버에서 데이터를 가져오기 때문에 백엔드 데이터에 안전하게 엑세스할 수 있을 뿐아니라 서버에 클라 간 상호작용을 줄여 성능을 개선한다.

