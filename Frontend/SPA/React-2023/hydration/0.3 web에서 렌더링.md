# Web에서 렌더링

> [출처](https://web.dev/rendering-on-the-web/)

web dev 팀은 개발자가 전체 재수화 접근 방식보다 SSR 또는 정적 렌더링을 고려하도록 권장한다.

## 용어

### 렌더링

- SSR: 클라이언트 측 또는 범용 앱을 서버의 HTML로 렌더링한다.
- CSR: JavaScript를 통해 브라우저에서 앱을 렌더링해 DOM을 수정한다.
- Rehydration: 서버에서 렌더링 된 HTML의 DOM 트리 및 데이터를 재사용하도록 클라이언트에서 JavaScript 뷰를 'booting up' 한다.
- Prerendering: 빌드 시 클라이언트 측 앱을 실행해 초기 상태를 정적 HTML로 캡쳐한다.

### 퍼포먼스

- Time to First Byte (TTFB): 링크를 클릭하고 콘텐츠가 들어오는 첫 번재 비트 사이의 시간으로 표시된다.
- First Contentful Paint (FCP): 요청 된 내용(기사 본문 등)이 표시되는 시간.
- Interaction to Next Paint (INP): 페이지가 사용자 입력에 일관되게 빠르게 응답하는지 여부를 평가하는 대표적인 메트릭으로 표시됨.
- Total Blocking Time (TBT): INP에 대한 프록시 메트릭으로, 페이지 로드 중 주 스레드가 차단된 시간을 계산함.

<br/>

## SSR

서버측 렌더링은 링크 이동에 대한 응답으로 서버에서 페이지에 대한 HTML을 생성함. 브라우저가 응답을 받기 전에 처리되므로 클라이언트에서 데이터 페칭이 방지된다.

SSR은 일반적으로 빠른 FCP를 생성함. 서버에서 페이지 로직과 렌더링을 실행하면 클라이언트에 많은 JavaScript를 보내지 않을 수 있다. 이것은 페이지 로드 중에 메인 스레드가 자주 차단되지 않기 때문에 페이지의 TBT를 줄이는 데 도움이 되며, 낮은 INP로 이어질 수도 있다.

메인 스레드가 덜 차단되면 사용자 상호 작용이 더 빨리 실행될 수 있다. SSR에서는 텍스트와 링크를 사용자의 브라우저로 전송할 수 있기 때문에 이것이 의미가 있다. 이 접근 방식은 광범위한 장치 및 네트워크 조건에서 잘 작동할 수 있으며 스트리밍 문서 구문 분석과 같은 흥미로운 브라우저 최적화를 도와준다.

![[assets/images/6e5877db124330923393992890aad4d0_MD5.png]]

그러나 이 접근 방식에는 한 가지 잠재적인 아쉬운 점이 있음. 서버에서 페이지를 생성하는 데 시간이 소요되며, 이로 인해 TTFB가 높아질 수 있다.

SSR이 애플리케이션에 충분한지 여부는 주로 어떤 유형의 경험을 구축하는지에 따라 결정됨. 서버측 렌더링과 클라이언트측 렌더링의 논쟁이 있지만, 일부 페이지에 대해 서버측 렌더링을 사용하도록 선택할 수 있으며 다른 페이지에는 사용하지 않을 수 있음. 일부 사이트는 하이브리드 렌더링 기술을 성공적으로 채택했음.

**넷플릭스** 서버는 정적인 랜딩 페이지를 렌더링하는 반면, 상호 작용이 많은 페이지에 대해 JS를 프리페치하여 클라이언트 렌더링 페이지를 빠르게 로드할 수 있는 더 나은 기회를 제공한다.

많은 현대적인 프레임워크, 라이브러리 및 아키텍처는 클라이언트와 서버 모두에서 동일한 애플리케이션을 렌더링할 수 있게 한다. 이러한 기술은 SSR에 사용할 수 있다. 그러나, 서버와 클라이언트 모두에서 렌더링이 발생하는 아키텍처는 성능 특성과 트레이드오프가 매우 다른 자체 솔루션 클래스다. 리액트는 서버 DOM API 또는 SSR을 위해 Next.js와 같이 그 위에 구축된 솔루션을 사용할 수 있다. 그러나 대부분의 일반적인 솔루션은 어떤 형태의 hydration을 사용하므로 도구를 선택하기 전에 사용 중인 접근 방식을 알고 있어야 함.

## Static rendering

정적 렌더링은 빌드 시간에 수행됨. 이 접근 방식은 빠른 FCP를 제공하며, 클라이언트 측 JS의 양이 제한되어 있다고 가정할 때 TBT와 INP도 낮춘다. SSR과 달리 페이지의 HTML이 서버에서 동적으로 생성될 필요가 없기 때문에 일관되게 빠른 TTFB를 달성할 수 있다. 일반적으로 정적 렌더링은 각 URL에 대해 별도의 HTML 파일을 미리 생성하는 것을 의미함. HTML 응답을 미리 생성하면 정적 렌더링을 여러 CDN에 배치하여 엣지 캐싱을 활용할 수 있음.

![[assets/images/71e058af2fea071f6e97cde2613c21ae_MD5.png]]

Gatsby와 같은 도구들은 개발자들이 그들의 응용 프로그램이 빌드 단계로 생성되는 것이 아니라 동적으로 렌더링되는 것처럼 느끼도록 설계되었다. 11ty, Jekyll 및 Metalsmith와 같은 정적 사이트 생성 도구는 정적 특성을 수용하여 보다 템플릿 중심 접근 방식을 제공함.

> Next.js 또는 Nuxt와 같은 유명한 프레임워크의 추상화는 Static Rendering과 SSR 모두 제공합니다. 이를 통해 개발자는 한정된 페이지에 대해 정적 렌더링을 선택하거나 요청에 따라 동적으로 생성해야 하는 페이지에 대해 서버 측 렌더링을 사용할 수 있음.

정적 렌더링의 단점 중 하나는 가능한 모든 URL에 대해 개별 HTML 파일을 생성해야 한다는 것. 이러한 URL을 미리 예측할 수 없거나 고유한 페이지가 많은 사이트의 경우 이는 어렵거나 불가능할 수 있음.

react 사용자는 Gatsby, Next.js 정적 내보내기 또는 Navigation에 익숙할 수 있음. 그러나 **정적 렌더링과 프리렌더링의 차이점**을 이해하는 것이 중요함.

- **정적 렌더링** 페이지는 클라이언트 측 JavaScript를 많이 실행할 필요 없이 상호 작용하는 반면,
- **프리렌더링**은 페이지가 상호 작용하기 위해 클라이언트에서 부팅되어야 하는 SPA의 FCP를 향상시킵니다.

사용하고자 하는 목적이, 정적 렌더링인지 아니면 미리 렌더링인지 확실하지 않으면 JavaScript를 비활성화하고 테스트할 페이지를 로드해봐라. 정적으로 렌더링된 페이지의 경우 자바스크립트를 활성화하지 않으면 대부분의 기능이 여전히 존재함. 미리 렌더링된 페이지의 경우 링크와 같은 기본 기능이 남아 있을 수 있지만 대부분의 페이지는 비활성화된다.

또 다른 유용한 테스트는 Chrome DevTools에서 네트워크 조절을 사용하여 페이지가 대화형이 되기 전에 얼마나 많은 자바스크립트가 다운로드되었는지를 관찰하는 것이다. 프리렌더링은 일반적으로 대화형이 되기 위해 더 많은 자바스크립트를 필요로 하며, 자바스크립트는 정적 렌더링에 사용되는 점진적인 향상 접근법보다 더 복잡한 경향이 있음.

<br/>

## 서버 측 렌더링 대 정적 렌더링

SSR은 쉬운 일이 아님. SSR의 동적 특성에는 상당한 컴퓨팅 오버헤드 비용이 수반될 수 있음. 많은 서버 측 렌더링 솔루션은 초기에 플러시되지 않으며, TTFB를 지연시키거나 전송되는 데이터를 두 배로 증가시킬 수 있음. (예: 클라이언트에서 자바스크립트가 사용하는 인라인 상태) React에서 `renderToString()` 은 동기화 및 단일 스레드이므로 느릴 수 있다. 스트리밍을 지원하는 새로운 리액트 서버 DOM API는 브라우저에 대한 HTML 응답의 초기 부분을 더 빨리 가져올 수 있으며 나머지 부분은 서버에서 계속 생성된다.

SSR을 "올바르게" 하려면 구성 요소 캐싱, 메모리 소비 관리, 메모이제이션 기술 적용 및 기타 문제에 대한 솔루션을 찾거나 구축해야 함. 일반적으로 동일한 어플을 클라이언트와 서버에서 여러 번 처리/재구축함. SSR이 무언가를 더 빨리 표시할 수 있다고 해서 갑자기 작업량이 줄어든 것은 아님. 서버 생성 HTML 응답이 클라이언트에 도착한 후 클라이언트에 대한 작업량이 많은 경우에도 웹 사이트의 TBT 및 INP가 높아질 수 있음.

SSR은 각 URL에 대해 주문형 HTML을 생성하지만, 정적 렌더링된 내용을 제공하는 것보다 느릴 수 있다. 추가 레그워크를 넣을 수 있는 경우, SSR과 HTML 캐싱을 통해 서버 렌더링 시간을 크게 줄일 수 있음. SSR의 장점은 정적 렌더링을 통해 가능한 것보다 더 많은 "실시간" 데이터를 끌어오고 더 완전한 요청에 응답할 수 있다는 것. 개인화가 필요한 페이지는 정적 렌더링에서는 잘 작동하지 않는 요청 유형의 구체적인 예이다.

서버 측 렌더링은 PWA를 구축할 때 흥미로운 결정을 내릴 수도 있습니다. 전체 페이지 Service Worker 캐싱을 사용하는 것이 더 나은가, 아니면 개별 콘텐츠를 서버로 렌더링하는 것이 더 나은가?

<br/>

## CSR

클라이언트 측 렌더링은 자바스크립트로 브라우저에서 직접 페이지를 렌더링하는 것을 의미한다. 모든 논리, 데이터 가져오기, 템플릿 및 라우팅은 서버가 아닌 클라이언트에서 처리된다.

클라이언트 측 렌더링은 모바일 장치에서 빠르게 가져오고 유지하기 어려울 수 있다. 최소한의 작업만 수행하면 클라이언트 측 렌더링은 순수한 서버 측 렌더링 성능에 접근하여 JavaScript 예산을 엄격하게 유지하고 가능한 한 적은 왕복으로 가치를 제공할 수 있습니다. `<link rel=preload>` 를 사용하면 중요한 스크립트와 데이터를 더 빨리 제공할 수 있으므로 파서를 더 빨리 사용할 수 있음.

![[assets/images/3b258efbf4c699983c20c0e15b6f968a_MD5.png]]

클라이언트 측 렌더링의 주요 단점은 애플리케이션이 성장함에 따라 필요한 자바스크립트의 양이 증가하는 경향이 있으며 페이지의 INP에 부정적인 영향을 미칠 수 있다는 것. 새로운 자바스크립트 라이브러리, 폴리필, 서드파티 코드의 추가로 특히 어려워진다.

대규모 자바스크립트 번들에 의존하는 클라이언트 측 렌더링을 사용하는 사용자는 페이지 로드 중에 TBT와 INP를 낮추기 위해 공격적인 코드 스플리팅을 고려해야 하며, "필요할 때 필요한 것만 제공"해야 함. 상호 작용이 거의 없거나 전혀 없는 경험의 경우, 서버 측 렌더링은 이러한 문제에 대한 확장 가능한 솔루션을 나타낼 수 있다.

SPA을 구축하는 사용자의 경우 대부분의 페이지에서 공유하는 사용자 인터페이스의 핵심 부분을 식별하면 애플리케이션 셸 캐싱 기술을 적용할 수 있다. Service worker와 결합하면 애플리케이션 셸 HTML 및 종속성을 `CacheStorage` 에서 매우 빠르게 로드할 수 있기 때문에 반복 방문 시 인식되는 성능을 크게 향상시킬 수 있다.

<br/>

## 리하이드레이션을 통해 서버 측 렌더링과 클라이언트 측 렌더링을 결합

전체 페이지 로드 또는 다시 로드와 같은 탐색 요청은 응용프로그램을 HTML로 렌더링하는 서버에 의해 처리되며, 그러면 렌더링에 사용되는 자바스크립트와 데이터가 결과 문서에 포함됨. 신중하게 수행하면 서버 측 렌더링과 마찬가지로 빠른 FCP를 달성한 다음 `(re)hydration` 이라고 하는 기술을 사용하여 클라이언트에서 다시 렌더링함으로써 "픽업"됩니다. 이는 효과적인 해결책이지만 상당한 성능 저하를 가져올 수 있음.

리하이드레이션을 사용한 SSR의 주요 단점은 FCP를 개선하더라도 TBT 및 INP에 상당한 부정적인 영향을 미칠 수 있다는 것. SSR 페이지는 로드되고 상호 작용하는 것처럼 보일 수 있지만 구성 요소에 대한 클라이언트 측 스크립트가 실행되고 이벤트 핸들러가 부착될 때까지 실제로 입력에 응답할 수 없다. 이 작업은 모바일에서 몇 초 또는 몇 분이 걸릴 수 있다.

페이지가 로드된 것처럼 표시된 후 일정 기간 동안에는 이 문제를 직접 경험한 적이 있을 수 있다. 클릭하거나 탭해도 아무런 효과가 없다. 사용자가 페이지와 상호 작용하려고 할 때 왜 아무 일도 일어나지 않는지 의문을 갖게 된다.

### Rehydration problem: 두 개의 가격에 하나의 앱

리하이드레이션 문제는 종종 JavaScript로 인한 지연된 상호작용보다 더 심각할 수 있다. 클라이언트 측 자바스크립트가 HTML 렌더링에 사용된 모든 데이터를 재요청하지 않고 서버가 중단된 곳에서 정확하게 "픽업"할 수 있도록, 현재 서버 측 렌더링 솔루션은 일반적으로 UI의 데이터 종속성에서 문서로 응답을 직렬화한다. HTML 결과 문서에는 높은 수준의 중복이 포함되어 있다.

![[assets/images/135b3b69cb1493975325461304959098_MD5.png]]

서버는 Navigation 요청에 응답하여 어플리케이션의 UI에 대한 설명을 반환하지만, UI를 구성하는 데 사용된 소스 데이터와 클라이언트에서 부팅되는 UI 구현의 전체 복사본도 반환한다. bundle.js가 로드 및 실행을 완료한 후에만 이 UI가 상호작용이 가능하다.

SSR 및 리하이드레이션을 사용하여 실제 웹 사이트에서 수집한 성능 메트릭은 사용을 금지해야 함을 말한다. 그 이유는 사용자 경험으로 귀결된다: 페이지가 준비되어 있음에도 불구하고 상호 작용이 부재하다고 느끼게 하기 때문임.

> 쉽게 말하면, HTML이 반환 되어 사용자는 화면을 보는데, `bundle.js` 파일이 모두 로드 되어야하지만 상호 작용이 가능하다. 하지만, `bundle.js`안에는 SPA 전체 소스가 들어있기 때문에 엄청 오래걸리고, 이는 SPA를 다운받아 실행하는 것보다 사용자에게 좋지 못한 경험이 된다는 말임.

![[assets/images/c95d50e701763fdde1c69d7d85744f4c_MD5.png]]

하지만 리하이드레이션을 통한 SSR에 대한 희망이 있음. 단기적으로는 캐시 가능성이 높은 콘텐츠에 SSR을 사용하면 TTFB를 줄일 수 있으며, 프리렌더링과 유사한 결과를 얻을 수 있다. 점진적으로, 점진적으로, 또는 부분적으로 hydration하는 것이 미래에 이 기술을 더 실행 가능하게 만드는 열쇠가 될 수 있다. -> 그래서 RSC가 나왔구만.

<br/>

## 스트리밍 서버 측 렌더링 및 점진적인 리하이드레이션

서버 측 렌더링은 지난 몇 년 동안 많은 발전을 이루었음.

스트리밍 서버 측 렌더링을 사용하면 HTML을 수신할 때 브라우저가 점진적으로 렌더링할 수 있는 청크로 보낼 수 있다. 따라서 마크업이 사용자에게 더 빨리 전달되므로 FCP가 빨라질 수 있다. React에서 동기식 `renderToString()` 과 비교하여 `renderToPipeableStream()` 에서 비동기식 스트림은 배압이 잘 처리됨을 의미한다.

점진적인 rehydration은 또한 고려할 가치가 있으며, 리액트가 도달할 곳임. 이 접근 방식을 사용하면 전체 어플을 한 번에 초기화하는 일반적인 접근 방식이 아니라, 서버 렌더링 어플리케이션 **개별 부분이** 시간이 지남에 따라 "부팅"된다. 이것은 페이지의 낮은 우선순위 부분의 클라이언트 측 업그레이드가 메인 스레드를 차단하는 것을 방지하기 위해 지연될 수 있기 때문에, 페이지를 대화형으로 만드는 데 필요한 자바스크립트의 양을 줄이는 데 도움이 될 수 있다.

점진적인 rehydration은 서버에서 렌더링되는 DOM 트리가 파괴된 후 즉시 재구축되는 가장 일반적인 서버 측 렌더링 리하이드레이션 위험을 방지하는 데 도움이 된다. 대부분의 경우 초기 동기화 클라이언트 측 렌더링에는 준비되지 않은 데이터가 필요하여 Promise 해결을 기다리는 경우가 많기 때문임.

### 부분적 rehydration

부분적 rehydration은 실행하기 어려운 것으로 입증되었다. 이 접근법은 점진적으로 수분을 보충할 개별 조각(구성요소/뷰/트리)을 분석하고 상호작용성이 거의 없거나 반응성이 없는 조각을 식별하는 점진적인 수분 보충 개념의 확장임. 대부분 정적인 각 부분에 대해 해당 자바스크립트 코드는 비활성 참조 및 장식 기능으로 변환되어 클라이언트 측 풋프린트를 거의 0으로 줄인다.

부분적 hydration 접근법에는 자체적인 문제와 타협이 수반됨. 캐싱에 몇 가지 흥미로운 문제를 제기하며 클라이언트 측 탐색은 애플리케이션의 비활성 부분에 대한 서버 렌더링 HTML이 전체 페이지 로드 없이 사용 가능할 것이라고 가정할 수 없다는 것을 의미함.

### Trisomorphic rendering

생략..

<br/>

## SEO 고려사항 #

웹에서 렌더링을 위한 전략을 선택할 때 SEO의 영향을 고려한다. SSR은 크롤러가 쉽게 해석할 수 있는 "완전한" 경험을 제공하기 위해 종종 선택된다. 크롤러는 자바스크립트를 이해할 수 있지만, 렌더링 방식에는 종종 인식할 가치가 있는 제한이 있다. 클라이언트 측 렌더링은 작동할 수 있지만 추가 테스트 및 레그워크 없이는 작동하지 않는 경우가 많다. 최근에는 아키텍처가 클라이언트 측 JavaScript에 크게 의존하는 경우 동적 렌더링도 고려할 만한 옵션이 되었다.

모바일 친화적인 테스트 도구는 선택한 접근 방식이 원하는 것을 수행하는지 테스트하는 데 매우 유용함. 구글의 크롤러에 페이지가 어떻게 나타나는지, 발견된 직렬화된 HTML 콘텐츠(자바스크립트 실행 후), 렌더링 중 발생한 오류에 대한 시각적 미리보기를 보여준다.

<br/>

## 마무리 #

렌더링에 대한 접근 방식을 결정할 때는 병목 현상이 무엇인지 측정하고 이해해야 함. 정적 렌더링 또는 SSR을 통해 대부분의 작업을 수행할 수 있는지 고려하라. 대화형 경험을 얻기 위해 최소한의 자바스크립트로 HTML을 대부분 발송하는 것은 아주 좋다. 다음은 서버-클라이언트 스펙트럼을 보여주는 유용한 이미지다.

![[assets/images/3f9be8e9bfd23fa2f569be998f07de96_MD5.png]]
