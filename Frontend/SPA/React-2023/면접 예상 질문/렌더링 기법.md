# 렌더링 기법

- Next.js에서 사용하는 렌더링은 무엇이 있는가?
  - 서버 측 렌더링(SSR)
  - 정적 사이트 생성(SSG)
  - 클라이언트 측 렌더링(CSR)
- pre-rendering이란?
  - 서버 측에서 페이지를 사전에 렌더링 해 정적 HTML 파일로 생성하는 것을 말한다.
  - 두가지를 지원한다. SSR, SSG.
  - 장점은?
    - 페이지 로딩 속도를 개선하고, SEO를 향상시킴.
- CSR이란?
  - 화면에 그려질 HTML 문서를 JavaScript를 이용해 클라이언트 사이드에서 동적으로 DOM을 완성하는 방식. (TTV === TTI)
  - 사용자와 인터렉션이 많은 경우, 화면 업데이트/렌더링이 많은 경우, 검색 엔진에 노출되지 않아도 되는 경우 유리하다.
    - 장점
      - 사용성이 좋다. 페이지를 이동할 때, JavaScript로 동적으로 페이지를 생성하기 때문에 깜빡임이 없다.
      - 초기 로딩 이후 구동 속도가 빠른다.
      - TTV와 TTI 사이 간극이 없다.
      - 서버측 부하가 적다.
    - 단점
      - JavaScript 파일이 커서, 첫 화면을 볼때까지 시간이 오래걸릴 수 있다. -> TTV가 느리다.
        - 이 경우는, 코드 분할 기법을 사용해, 필요할 때 서버로부터 JavaScript 파일을 다운로드할 수 있도록 한다.
      - SEO에 좋지 않다. 검색엔진이 기본적으로 HTML을 보고 웹사이트를 분석하기 때문이다.
      - 보안에 취약하다.
    - 보완 방법
      - 초기 로딩 속도 보완: code splitting, tree-shaking, 지연 로딩
      - SEO 개선: pre-rendering
- SSR이란?
  - 클라이언트에서 페이지 요청이 일어나면, HTML이 서버에서 생성되어 클라이언트로 전송되는 기법. (TTV!== TTI)
  - 비교적 인터렉션이 적고, 데이터가 요청할 때마다 한 번만 처리되어도 좋은 경우, 검색엔진에 노출이 필요한 경우 좋다.
    - 장점
      - 초기 구동 속도가 빠르다. -> TTV가 빠르다.
      - SEO에 유리하다.
      - 보안에 좋다.
    - 단점
      - 페이지를 이동하면 페이지 전체를 다시 서버로부터 받아와야 하기 때문에 깜빡임이 있을 수 있다.
      - 동적으로 처리하는 JavaScript 파일을 가져오지 못했을 때, 반응이 없는 경우가 발생할 수 있다. -> TTI가 느리다. (TTV와 TTI 사이 간극이 있다.)
      - 서버에 과부하가 걸리기 쉽다.
- SSG란?
  - 빌드 시 정적 HTML파일을 생성하고, 클라이언트에서 페이지 요청이 일어나면, 만들어 둔 HTML 파일을 전송하는 기법.
  - JavaScript 파일도 함께 보낼 수 있기 때문에 항상 정적인 것만은 아니다.
  - 업데이트가 적거나, 고정된 데이터를 사용할 때 적합하다. 블로그 등.
    - 장점
      - 페이지 로딩시간, TTV가 빠르다.
      - SEO 최적화가 좋음.
      - 보안이 뛰어남
      - CDN에 캐시가 됨
    - 단점
      - 데이터가 정적이다.
      - 사용자 별 정보 제공이 어려움
- ISR(Incremental Static Regeneration)이란?
  - SSG로 생성한 HTML 파일을 주기적으로 다시 서버에서 재생성하는 기법.
  - revalidate가 필요한 SSG 페이지에 적합하다.
  - revalidate 옵션을 시간으로 설정하면 그 주기에 맞춰 새롭게 생성하지만, 페이지 방문자가 없다면 진행하지 않는다.
    - 장점
      - 페이지 로딩시간, TTV가 빠르다.
      - SEO에 좋음
      - CDN에 캐시가 됨
      - 데이터가 주기적으로 업데이트 됨
    - 단점
      - 실시간 데이터가 아님
      - 사용자별 정보 제공의 어려움
- SSR, SSG의 차이점은?
  - SSR은 요청할 때 HTML을 만들기 때문에 동적인 데이터가 많다면 사용하면 좋다.
  - SSG는 데이터가 정적이여서 바뀔일이 거의 없는 페이지에 적합하다.
- Hydration이란?
  - 서버로 부터 전달받은 HTML과 React component를 일치시키는 기법.
    - Hydrantion이 완료되면, 사용자와 어플리케이션이 상호작용이 가능해진다.. JavaScript 코드와 HTML이 연결되는 과정을 hydration이라고 한다.
  - 예를 들면, 버튼에 이벤트 핸들러 추가 등이 있다.
- Progressive Hydration이란?
  - 일반적인 SSR Hydration은 모든 hydration이 처리된 후 반영 되지만, Progressive Hydration은 점진적으로 hydration이 처리된다. 특정 부분이나 컴포넌트 필요에 따라 순차적으로 hydration된다.
- 성능 주요 지표
  - TTV란?: Time To View: 사용자가 첫 화면을 보기까지의 시간.
  - TTI란?: Time To Interact: 사용자가 웹 어플리케이션과 인터렉션이 가능해지는 시간.
  - TTFB란? Time to First Byte: HTTP 요청을 했을때 처음 byte (정보) 가 브라우저에 도달하는 시간.
  - FCP란? First Contentful Paint: 초기 DOM 콘텐츠를 렌더링하는데 걸리는 시간.(무언가 일어나고 있다고 인지)
  - LCP란? Largest Contentful Paint: 뷰포트에서 가장 큰 콘텐츠 엘리먼트가 나타날 때 측정. (페이지의 주요 내용이 화면에 렌더링되고 있다고 인지)
- Universal Rendering이란?
  - 서버와 클라이언트에서 동일한 코드가 동작하는 어플리케이션.
  - CSR + SSR이 동시에 동작하는 기법
  - 서버 측에서 초기 렌더링을 수행하고, 클라이언트 측에서는 초기 렌더링 결과를 재사용해 상호작용을 제공하는 방식.
    - 초기 로딩 속도 보완, SEO 개선, CSR의 장점.
- JAM Stack이란?
  - JavaScript, API, Markup의 약자이다.
  - 렌더링의 관점이 아니라, 웹사이트를 어떻게 구성할 것인지의 관점을 설명하는 것. 즉, 방법론이다.
  - 렌더링할 화면을 pre-render하고, CDN에 배포해 서버 관리를 최소화할 수 있다.
    - JavaScript: Client의 처리
    - API: 모든 기능 및 비즈니스 로직은 API가 처리
    - Markup: SSG나 Template Engine을 이용해 Markup을 미리 생성한다.
- react server component란?
  - 서버에서 data-fetching 처리를 하고 렌더링하는 방식이다. 브라우저 대신 서버에서 렌더링 하기 때문에 브라우저에서 번들링된 코드를 다운로드 해야하는 것과 달리 서버에서 필요한 데이터만 빠르게 반영할 수 있다.
  - 스트리밍 방식을 통해 브라우저로 전달된다. 이를 통해 브라우저가 서버로 부터 전달받은 JSON을 처리하고, 클라이언트에서 렌더링 될 리액트 트리를 재구성할 수 있다.
  - SPA에서처럼 코드 스플리팅과 API 요청을 구현할 수 있고, SSR과 같은 서버 렌더링의 이점도 얻을 수 있다.
