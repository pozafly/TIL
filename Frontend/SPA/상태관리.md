# 상태관리

> [출처](https://blog.hoseung.me/2021-12-05-state-management)

## 상태와 상태 관리의 의미

### 상태

**UI에 영향을 줄 수 있는 모든 데이터**.

- 팔로워 수
- 장바구니에 담긴 상품 리스트
- 총 결제 금액
- 카드사 할인 혜택
- 현재 열려있는 모달
- 유저가 현재 보고 있는 페이지
- 어떤 UI를 보여줄지에 대한 여부
- input의 입력 값
- ...

상태는 가만히 있지 않고 **변화**한다.

예를 들어 키보드를 입력했을 때 '입력값'은 변화한다. 또한 모달을 닫았을 때 '현재 열려있는 모달'은 변화한다. 좀 더 구체적인 예시는 '어떤 UI 를 보여줄지에 대한 여부'다.

알림센터를 예시로 들어보면, 서버로부터 알림 리스트를 로딩해야 한다. 알림 리스트가 로딩되는 동안에는 유저에게 Skeleton UI를 보여줘야 한다. 로딩이 끝나면 알림 리스트를 UI에 렌더링한다. 또는 로딩 중에 에러가 났다면 에러 페이지로 이동하거나, Skeleton UI를 계속 보여주고 다시 데이터를 요청한다.

이때 '알림이 언제 온건지'를 UI에 보여주려고 함. 그냥 '날짜/시/분/초'로 보여주면 되나? 밋밋하다. 1분이 안되었어다면 'n초 전', 1시간이 안되었다면 'n분 전', 1일이 안되었다면 'n시간 전'과 같이 알림이 생성된 후 시간이 얼마나 흘렀냐에 따라 UI를 다르게 보여줄 수도 있다.

### 상태 관리

또한, 프론트에서는 '컴포넌트' 개념이 매우 중요하다. 모든 화면은 컴포넌트가 조합되어 만들어진다. 이 때 특정 상태에 변화가 일어난다면, 해당 변화는 그 상태의 영향을 받는 모든 컴포넌트에 필연적으로 '전파' 되어야 한다.

상태를 어디에 저장할 것인지, 상태에 변화를 어떻게 일으킬 것인지, 또는 변화를 어떻게 감지할 것인지, 그 변화를 어떻게 전파할 것인지, 변화/전파에 따라 상태를 어떻게 가공해 UI에 보여줄 것인지 등, 이런 '**상태의 변화/전파를 처리하는 방법들**'을 '**상태 관리**'라 정의한다.

<br/>

## 상태 관리는 왜 하는 것이고, 왜 중요할까?

프론트엔드에서 너무나 많은 상태가 존재하고, 이런 상태들은 직/간접적으로 UI에 많은 영향을 주게 된다. 따라서 상태를 제대로 관리하지 못하면 유저에게 어색한 경험을 제공하게 되거나, 서비스에 버그가 생김.

서버 상태를 예시로 보자. 상태는 항상 프론트엔드 내부에서 만들어지지는 않는다. 서버 상태는 외부 상태다. '팔로워 수' 데이터를 서버에서 불러오고, 그걸 사용하는 페이지가 여러 개라 가정하자. 또한, '팔로워 수' 데이터는 서버 비용을 아끼기 위해 전역 Cache Map에 저장한다고 하자. 

아이유의 팔로워 수는 1000명이라 하자. 팔로우를 하면 1001 명으로 보여진다. 근데 검색 결과 페이지로 다시 돌아갔더니 1000명으로 그대로 보여지고 있다. 왜?개발자가 그냥 프로필 페이지 내부적으로 1만 더해 보여주는 실수를 한 것. 적절한 상태 관리를 했다면 전역 Cache Map에서 '팔로우 수' 데이터를 함께 수정하거나 서버로부터 '팔로우 수'를 refetch 해 전역 Cache Map에 반영했을 것이다. 이런 경우 유저에게 어색한 경험으로 끝나지만, 상품 찜 기능이라 해보자. 난리남.

이렇게 상태를 어떻게 관리하냐에 따라 유저 경험이 달라지고, 중단 없는 서비스 운영에도 도움이 된다.

<br/>

## 상태 관리는 어떻게 잘 하는가?

3가지 원칙이 있다.

### 상태 범위를 적절히 구분할 것

상태가 어떤 컴포넌트들 사이에 공유되냐에 따라 상태가 어디에 위치할 지 잘 결정해야 함. 특정 컴포넌트 내부에서만 사용되고 있다고 하면 로컬로 가지고 있으면 될 것이고, 전역에서 쓰이는 경우 전역 상태로 가져가야 함.

우선, 기본적으로 올바른 위치에 놓으려고 노력하면, 서로 의존하는 상태와 컴포넌트들의 물리적 거리가 가까워지게 된다. 이런 경우, 변경 사항이 일어났을 때, dead code가 생길 확률이 훨씬 적고, 혹여나 dead code가 생기더라도 리팩토링을 진행할 때 삭제하기가 수월하다.

또한, 불필요하게 특정 상태를 남용(적절한 예시로, react-router v5의 useLocation이 있다) 하게 되어 퍼포먼스에 문제가 생기는 등, 특정 상태의 영향을 받지 않아도 되는 컴포넌트들에 대한 side effect도 사전에 방지할 수 있다.

### 최대한 필요한 곳에만 변화가 전파될 것

위의 '상태의 범위를 적절히 구분할 것'과 매우 밀접히 연결되는 원칙임. react에서는 리렌더링을 일으켜 상태변화를 전파한다. 이때, 상태를 잘못 위치 시켜 상태가 너무 상위 컴포넌트에 위치해있거나 하위 컴포넌트들이 React.memo 등으로 memoization이 안되어 있는 경우, 상태가 변화했을 때 수많은 하위 컴포넌트들이 전부 리렌더링 되는 문제가 발생할 수 있다.

### 어떻게 저장하고 갱신할 것인지 잘 설계할 것

단순 버그 방지를 넘어 많은 비용을 아껴준다.

이번엔 상태 변화의 빈도(frequency)를 예시로 들어보자. 서버 상태는 변화가 매우 잦아 캐시해서는 안되는 데이터와, 변화가 거의 없다시피해 요청 보내는게 아까운 수준의 데이터도 있음.

후자는 어떻게? 서버에 요청을 계속 보내지 않으면서 사이트가 꺼져도 상태를 유지할 수 있는 방법 `localstorage` 가 떠오른다. 단, localstorage 같은 경우 영구정이기 때문에 특정 시간이 지났을 때나 특정 시점마다 삭제하는 로직이 필요할 것이다.

client-side 캐시를 localstorage로 구현할 수 있는데, API call 도 많이 줄었고, 관련 컴포넌트의 렌더링 소도도 눈에 보이지 만큼 빨라진다.

변화가 거의 없는 데이터 말고, 변화가 실시간으로 보여져야하는 데이터의 경우 웹소켓을 사용해 관리하는 방법도 있을 것이다.

<br/>

## 마무리

상태 관리를 잘 하는 것이 생각보다 많은 비용을 절약해준다. 그것이 서버 부하의 감소일 수도 있고, CS 인입의 감소일 수도 있다.

