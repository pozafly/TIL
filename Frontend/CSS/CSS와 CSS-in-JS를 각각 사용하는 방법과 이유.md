# CSS와 CSS-in-JS를 각각 사용하는 방법과 이유

> [출처](https://blog.logrocket.com/css-vs-css-in-js/)

## 렌더링 차단 및 CSS

전통적으로 브라우저는 HTML을 먼저 로드 후 외부 리소스에서 CSS를 로드함. 그 다음 브라우저는 모든 외부 및 내부 CSS 정보를 사용해 CSSOM을 생성한다. 이제 브라우저는 CSS 케스케이드 규칙에 따라 렌더링 된 HTML에 스타일을 제공할 준비가 되었다.

이 프로세스로 인해 CSS는 [페이지 렌더링을 차단](https://blog.logrocket.com/9-tricks-eliminate-render-blocking-resources/)하고 요청된 페이지의 첫 번째 페인트를 지연시킨다. 첫 번째 페인트는 브라우저가 요청된 페이지의 화면에 첫 번째 픽셀을 인쇄할 때 발생하는 이벤트다.

첫 번째 페인트에서 0.5초 이상 지연되면 사용자가 불만족할 위험이 더 커지고, 앱 목표에 부정적인 영향을 미칠 수 있다. 클라이언트에 CSS를 더 빨리 전달할 수 있도록 페이지의 첫 페인트 시간을 더 잘 최적화할 수 있다.

<br/>

## CSS 렌더링 블록과의 싸움

HTTP/2 기반 앱을 사용하면 여러 HTML, CSS, JS 파일을 병렬로 로드할 수 있다. 이 기능은 HTTP/1.1로 제한되어있었지만, 최신 브라우저는 HTTP/2를 지원하므로 다른 파일이 로드되기를 기다리면서 발생하는 렌더링 블록을 최소화 한다.

![image](https://github.com/pozafly/TIL/assets/59427983/82a07566-71cd-4bf7-923c-9723d28c7d50)

그러나, 렌더링 차단에는 파일 로딩 속도 외 다른 요소도 포함된다.

웹 페이지에 CSS가 많다고 가정하자. 사용되지도 않지만, 모든 페이지에 하나의 마스터 CSS 파일을 가져오기 때문에 존재하는 Selector가 포함될 수 있다.

디자인 시스템을 사용하기 위해 만든 CSS UI 프레임워크 또는 UI kit(bootstrap 또는 TailwindCSS 등)을 직접 사용하면, 모든 스타일이 모든 페이지에서 사용되는 것은 아니다. 결과적으로 페이지의 최종 CSS 스타일에 더 많은 정크가 발생한다.

CSS가 많을 수록 브라우저에서 CSSOM을 구성하는데 시간이 더 오래 걸리므로 완전 불필요한 렌더링 차단이 발생한다.

---

이에 대응하려면 CSS를 작은 덩어리로 나누는 것이 매우 유용하다. 즉, 전역 스타일과 Critical CSS를 하나의 범용 CSS 파일에 유지한 다음, 다른 모든 항목을 구성요소화 한다. 이러면 합리적이다.

![image](https://github.com/pozafly/TIL/assets/59427983/5c0d29c3-31f4-4ce5-8035-3a17730a5a3c)

위 그림은 React에서 구성 요소에 대해 별도의 CSS 파일을 만들고 관리하는 전통적인 방법을 보여준다. 각 CSS 파일은 해당 element에 직접 첨부되므로 해당 element를 가져올 때만 가져오고 element가 사라질 때 제거된다.

하지만 단점이 있음. 어플리케이션에 100개의 element가 포함되어 있고, 동일 프로젝트에서 작업하는 다른 개발자가 실수로 일부 CSS 파일에서 동일 클래스 이름을 사용했다 가정하자.

여기에서 element에 대한 모든 CSS 파일의 범위는 전역이므로 실수로 복제된 스타일은 계속해서 서로 재정의되고 전역적으로 적용된다. 이는 심각한 레이아웃 및 디자인 불일치가 발생한다.

CSS-in-JS는 scope 문제를 해결한다.

<br/>

## CSS-in-JS

CSS-in-JS는 JavaScript를 통해 구성 element에 대한 CSS 속성을 작성할 수 있는 외부 기능이다.

2015년 [JSS](https://cssinjs.org/?v=v10.10.0)라는 JavaScript 라이브러리로 시작되었다. 페이지가 로드 되면 속성을 선택기에 자동으로 적용하는 방식이다. React에서는 Styled-Components, Emotion 라이브러리가 있다.

<br/>

## CSS-in-JS 장점

- scope 지정
- 동적 스타일링. props 값에 따라.
- 쉬운 테마. JavaScript를 통해 테마를 작성할 수 있음. `ThemeProvider` 등.
- 간편한 유지보수. 수백 개의 CSS 파일을 관리하지 않아도 된다.

<br/>

## CSS-in-JS 단점

- 지연된 렌더링. JavaScript에서 CSS를 구문 분석 후 DOM에 삽입한다. element가 많을 수록 브라우저에서 First Paint를 수행하는데 시간이 더 걸림.
- 캐싱 문제. CSS-in-JS는 CSS 파일을 만들지 않으므로 캐싱이 큰 문제. 동적으로 생성된 CSS 클래스 이름으로 인해 이 문제가 더욱 복잡해짐.
- CSS 전처리기 지원 불가. Sass, PostCSS 등과 같은 전처리기에 대한 지원을 쉽게 하지 못한다. -> 아닌듯?
- 지저분한 DOM. JavaScript 모든 스타일 정의를 바닐라 CSS로 구문 분석 후 스타일 블록을 사용해 스타일을 DOM에 주입한다. 각 element에서 구문 분석 후 주입해야하는 스타일 블록이 100개가 넘을 수 있다. 간접비가 더 많이 발생하게 된다.
- 라이브러리 의존성. 실제 CSS 구문 분석 전 많은 JavaScript가 포함되어 실행된다.
- 학습 곡선

<br/>

## CSS-in-JS 권장사항

성능이 우선순위가 낮은 소규모 어플에 이상적이다. 거대한 디자인 시스템으로 성능이 중요한 어플을 다룰 때는 이상적이지 않다.

