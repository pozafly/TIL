# 쿠키 & 세션



> 출처 : [얄코](https://www.youtube.com/watch?v=OpoVuwxGRDI&t=163s)

어떤 시설을 이용한다고 했을 때, 시설을 모두 이용하고 나와서 정산한다고 하자.

사용자는 **쿠키북**을 들고 다님. 시설을 이용할 때마다 기록하고 시설에게 보여줘야 함. 쿠키는 이용하고 방문할 때, 브라우저에 저장되는 내용들임. 즉, 나의 정보임.

쿠키북의 한계가 있음. 내가 지우거나 조작할 수 있고 심지어 남이 훔쳐보거나 도둑질하기도 쉬움. 민감한 정보는 여기 적으면 부담스러움.

시설 측에서도 이용 가격을 여기 적어주고 싶지 않아할 것임. 시설 측에서 관리해야 함. 이게 **세션**임.

시설 측에서는 사용자가 시설을 이용할 때마다 그때그때 생성되는 바코드를 쿠키북에 찍어줌. 쿠키북에 저장하기 민감한 정보들은 시설 측에서 세션에 저장한다. 

사용자가 웹사이트에 접속하면, 서버에서는 사용자를 구분하기 위해 기간이 짧은 임시 키 하나를 브라우저에 보내서 쿠키로 저장함. 사용자의 중요한 정보는 서버의 메모리나 DB에 저장된다.

후에, 사용자가 브라우저에서 돌아다닐 때 서버에 http 요청에 이 키를 실어 전송하고, 서버는 그 key를 보고 사용자를 식별해 사용자의 정보들을 가공해 응답으로 보내준다.

<br/>

따라서, 사용자가 웹에서 로그인 후 다른 페이지로 이동할 때마다 새로 로그인 할 필요가 없는 것은, 쿠키와 세션의 조합으로 브라우저에서 로그인 해 있다는 것을 서버에서 인지하고 있기 때문임.

<br/>

### 쿠키 사용 예시

- 로그인 창의 아이디를 자동완성
- 공지 메세지를 하루 안 보기
- 쇼핑몰에서 로그인 하지 않은 상태로 장바구니 담기

-> 지워지거나 조작되거나 가로채이더라도 큰 일은 없음. 반대로 세션은 사용자의 민감한 정보를 서버에 저장하고 있음.

단, 세션을 남발하면 접속자가 많을 때 서버에 부하가 걸림. 

<br/>

<br/>

## 심화

> **출처1**, **출처2**, [출처3](https://junhyunny.github.io/information/server/tomcat-session-management/)

## 공통점, 차이점

1. 공통점 : 웹 통신간 **유지하려는 정보**(로그인 정보 등)**를 저장**하기 위해 사용하는 것
2. 차이점 : 저장위치, 저장형식, 용량제한, 만료 시점 등
   - 쿠키 : 개인 PC에 저장됨.
   - 세션 : 접속중인 웹 서버에 저장됨.

<br/>

쿠키와 세션을 사용하는 이유는 HTTP 프로토콜의 특징이자 약점을 보완하기 위함.

## HTTP의 특성

1. Connectionless 프로토콜 (비연결지향)

HTTP 통신을 하기 위해서 클라이언트와 서버가 연결되어 있어야 함. 커넥션을 유지하는 것은 부담, 따라서 통신을 한번 할 때 통신이 끝나면 바로 연결을 끊음. 한 클라이언트가 여러 번의 요청을 보내도 커넥션은 바로 끊어졌다, 연결되었다 함. 단, HTTP 1.1 버전에서, 연결을 유지하고, 재활용하는 기능이 default로 추가 됨. (keep-alive 값으로 변경 가능)



2. Stateless 프로토콜 (상태정보 유지 안함)

HTTP는 이전 요청의 상태를 기록하지 않기 때문에 서버는 클라이언트를 식별할 수 없음. 클라이언트의 상태 정보를 가지지 않는 서버 처리 방식. 클라이언트와 첫번째 통신에서 데이터를 주고 받았다 해도, 두번째 통신에서 이전 데이터를 유지 하지 않는다.

![image](https://user-images.githubusercontent.com/59427983/151703310-b31898b3-fe81-4dcb-80fd-2b938cf7c3c8.png)

Stateful 방식과 같이 이전 상태를 보존한다면 이전 요청의 내용을 기억해 다음 요청에 반영할 수 있음. 그러나 Stateless는 이전 요청이 무엇이었는지 기억하지 않기 때문에 한 번의 요청에 모든 내용을 다 전달해야 함.

그럼 HTTP는 Stateful 쓰지 왜 Stateless 쓰냐?

-> 스케일링(scaling)이 자유롭다는 장점이 있음. 트래픽이 증가할 때, 서버를 한대 더 생성해(scale out) 다른 서버로 응답을 대체할 수 있기 때문임. Stateful은 스케일 아웃이 일어나면 해당 서버에서 상태를 보존하고 있기 때문에 새로 생성된 서버에서는 제대로 된 응답할 수 없고, Stateless는 상태를 보존하지 않기 때문에 새로 생긴 서버에서도 정상적으로 응답할 수 있음.

<br/>

## 비교

### 쿠키

사용자의 브라우저에 저장하는 작은 기록 정보 파일.

#### 특징

1. 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어 있음.
2. 클라이언트에 총 300개의 쿠키를 저장할 수 있음.
3. 하나의 도메인 당 20개의 쿠키를 가질 수 있음.
4. 하나의 쿠키는 4kb(=4096byte) 까지 저장 가능

#### 동작 순서

1. 클라이언트가 페이지를 요청
2. 웹 서버는 쿠키를 생성
3. 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때 같이 클라이언트에게 전달
4. 넘겨 받은 쿠키는 클라가 가지고 있음. 다시 서버에 요청할 때 요청과 함께 쿠키를 전송함
5. 동일 사이트 재방문 시 클라이언트에게 쿠키가 있는 경우 요청 페이지와 함께 쿠키를 전송.

#### 한계

사용자 측에 저장되어 정보를 고쳐 악용가능, 보안 취약

<br/>

### 세션

#### 특징

일정 시간동안 같은 브라우저로부터 들어오는 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술. 즉, 방문자가 웹 서버에 접속해있는 상태를 하나의 단위로 보고 그것을 세션이라 함. (세션은 **쿠키를 기반**으로 하여 동작한다.)

1. 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장.
2. 브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되므로, 쿠키보다 보안이 좋음.
3. 저장 데이터 제한 없음.
4. 각 클라이언트 고유 Session ID을 부여함. Session ID로 클라이언트 구분 및 요구에 맞는 서비스 제공.
5. 접속 시간에 제한을 두어 일정 시간 응답이 없으면 정보가 유지되지 않도록 설정 가능.
6. 세션 정보를 저장하는 저장소는 서버 메모리일 수도 있지만 다중 서버 환경에서는 외부 저장소를 사용함. 레디스 등.

#### 동작 순서

1. 클라가 페이지 요청
2. 서버는 접근한 클라이 Request-Header 필드인 Cookie를 확인, 클라가 해당 session-id를 보냈는지 확인함.
3. session-id가 존재하지 않을 시 쿠키를 사용해 서버에 저장.
4. 클라 재접속 시, 쿠키를 이용, session-id값을 서버에 전달.

#### 한계

사용자가 많아질 수록 서버의 메모리를 많이 차지해 과부하 주고 성능 저하의 요인이 된다.

![image](https://user-images.githubusercontent.com/59427983/151704169-bdd02a84-0a35-4643-a29c-54d6d71bdb2a.png)

<br/>

<br/>

## Tomcat Sesstion 획득과 만료

실제적으로 세션이 어떻게 생성되고 쿠키가 어떻게 세팅되는지 알아보자. Tomcat 서버, JSP 기술 스택 기반임.

### 세션 생성 및 쿠키 세팅

처음 서버에 접근하면 쿠키는 없음. 쿠키는 응답 헤더를 통해 서버로부터 전달받음. 서버 첫 응답을 통해 쿠키 생성되고, 이후는 브라우저가 쿠키 정보를 스스로 요청 헤더(request header)에 추가함.

- 첫 요청 정보와 그 이후 요청 정보의 차이점
  - 첫 응답 헤더 `Set-Cookie` 항목에 `JSESSIONID` 값이 전달 됨
  - 이후 요청 헤더를 보면 Cookie 항목으로 전달 받은 JSESSIONID 값이 들어감.

![image](https://user-images.githubusercontent.com/59427983/151705474-ad5cc11c-d586-4993-b764-16aed577b793.png)

### 생성 시점

1. 컨트롤러(controller) 에서 응답 값을 반환함
2. DispatcherServlet 에서 전달 받은 페이지를 JstlViewer 객체를 이용해 렌더링(rendering) 함.
3. 렌더링 수행 중 JspServlet 객체에 의해 PageContext 정보가 초기화 되는 시점에 세션이 생성됨.
4. 세션을 생성하고 세션 ID 정보를 응답 헤더에 쿠키로 담아 전달함.

![image](https://user-images.githubusercontent.com/59427983/151705560-dcac1c17-b63e-4ab9-b70c-d9a5fc27a7a6.png)

<br/>

### 응답 헤더에 쿠키 정보 설정 - Spring Boot 서버

```java
@Controller
public class CookieController {

    @GetMapping(value = {"", "/"})
    public String index(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
        Cookie firstCookie = new Cookie("firstCookie", "chocolateCookie");
        Cookie secondCookie = new Cookie("secondCookie", "vanillaCookie");
        servletResponse.addCookie(firstCookie);
        servletResponse.addCookie(secondCookie);
        return "index";
    }
}
```

단, HTTP 헤더의 Set-Cookie 헤더를 통해 쿠키를 세팅할 수 있는 것은 아님. 서버에서 렌더링하는 HTML에 정보를 전달하고 script 내에서 쿠키를 세팅할 수 있음.

```js
setCookie({
  name: 'status',
  value: '{{ user.status }}',
  expires: new Date(),
  (...)
})
```

쿠키의 저장 위치는 브라우저가 어떻게 쿠키 스토리지를 구현했는지에 따라 다르다.



읽어보기 ([Beomy - Cookie 톺아보기](https://beomy.github.io/tech/browser/cookie/))