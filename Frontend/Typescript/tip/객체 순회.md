# 객체 순회

> [출처](https://www.daleseo.com/ts-object-iteration/)

JavaScript에서 하던대로 객체를 순회하는 코드를 짜면 자꾸 예상치 못한 타입 오류에 부딪힌다.

## Object.keys()

`Object.keys()` 와 `forEach`를 돌려보자.

```ts
const obj = {
  a: 1,
  b: 2,
  c: 3,
};

Object.keys(obj).forEach(key => {
  console.log(obj[key]); // 오류발생
});
```

```
'string' 형식의 식을 '{ a: number; b: number; c: number; }' 인덱스 형식에 사용할 수 없으므로 요소에 암시적으로 'any' 형식이 있습니다.
  '{ a: number; b: number; c: number; }' 형식에서 'string' 형식의 매개 변수가 포함된 인덱스 시그니처를 찾을 수 없습니다.ts(7053)
-----
Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ a: number; b: number; c: number; }'.
  No index signature with a parameter of type 'string' was found on type '{ a: number; b: number; c: number; }'.
```

`{ a: number; b: number; c: number; }` 형식의 객체를 문자열(string) 자료형의 키로 접근할 수 없다는 것.

`Object.keys()` 함수의 반환 형태가 `string[]` 이기 때문에 `forEach()` 함수에서 `key`의 자료형이 `string`으로 추론 되었기 때문이다.

문제는 TypeScript 컴파일러가 주어진 객체의 현재 모습만 보고 키가 반드시 `a`, `b`, `c` 중에 하나여야 한다고 생각하는 것이다. JavaScript에서는 사실 `obj[d] = 4`와 같이 다른 키로 값을 추가할 수 있다. 따라서 `obj`의 자료형을 `Record<string, number>`로 명시하여 TypeScript 컴파일러에게 객체의 키가 아무 문자열이든 상관 없다고 알려주면 된다.

```ts
const obj: Record<string, number> = {
  a: 1,
  b: 2,
  c: 3,
};
```

<br/>

## for in

객체를 순회하기도 한다.

```ts
const obj = {
  a: 1,
  b: 2,
  c: 3,
};

for (const key in obj) {
  console.log(obj[key]); // 오류
}
```

이렇게 해주면, 아까와 마찬가지 완전 동일한 오류 메시지가 나타난다. 원인은, TypeScript에서 `for in` 구문을 사용하면 `key`는 항상 문자열로 취급이 되기 때문이다. `obj`의 자료형이 `{ a: number; b: number; c: number; }` 이기 때문에 TypeScript는 문자열인 `key`로 `obj`에 접근하는 것은 위험하다 판단하는 것이다.

이 타입 오류는 `Object.keys()` 와 마찬가지로 `Record`를 사용해 나타내주면 된다.

```ts
const obj: Record<string, number> = {
  a: 1,
  b: 2,
  c: 3,
};
```

또 다른 편법으로, JavaScript의 `typeof` 키워드와 TypeScript의 `keyof` 키워드를 사용해 객체의 키 자료형을 추출 후 TypeScript의 `as` 키워드를 사용해 `key`의 자료형을 `"a" | "b" | "c"`로 강제해주는 것이 있다.

```ts
const obj = {
  a: 1,
  b: 2,
  c: 3,
};

for (const key in obj) {
  console.log(obj[key as keyof typeof obj]);
}
```

하지만, 이 방법은 추천하지 않는다. 타입 강제는 애초에 TypeScript 사용하려는 취지와 어긋나기 때문이다.

<br/>

## Object.values()

객체를 순회할 때마다 해당 객체의 자료형을 직접 명시해줘야하는 것이 번거롭게 느껴질 수 있지만, `Object.values()`, `Object.entries()`를 사용하면 굳이 키를 통해 객체의 값에 접근할 필요가 없어지기 때문에 좀 더 편하게 타입 오류의 걱정으로 해방될 수 있다.

```ts
const obj = {
  a: 1,
  b: 2,
  c: 3,
};

Object.values(obj).forEach(v => console.log(v));
```

<br/>

## 왜그럴까?

TypeScript에서 `Object.keys()`와 `for...in` 구문이 키에 대한 타입 추론을 제공하지 않는 이유는 다음과 같습니다.

1. 객체의 키는 동적으로 변할 수 있으며, 다양한 속성을 가질 수 있습니다. 이에 따라 TypeScript는 객체의 키에 대한 정확한 타입을 추론하는 것이 어렵습니다.
2. `Object.keys()`와 `for...in`은 런타임에 동적으로 객체의 키를 가져오는 방법입니다. TypeScript는 정적 타입 체크를 수행하기 때문에, 런타임에서 동적으로 결정되는 키에 대한 정확한 타입을 제공하기 어렵습니다.

따라서, TypeScript는 `Object.keys()`와 `for...in` 구문에서 키의 타입을 `string`으로 간주하고, 해당 객체의 실제 타입과 일치시키지 않습니다. 이는 객체의 키에 대한 정확한 타입을 추론하는 것이 어렵고, 런타임 동작과의 호환성을 고려하기 때문입니다.

한편, `Object.values()`와 `Object.entries()`는 객체의 값들을 추출하는 것으로, 정적인 배열로 반환되므로 타입 추론에 더욱 적합합니다. 배열의 요소에 대한 타입 추론은 일반적으로 더 정확하게 이루어지며, 타입 안정성을 보장하기 위해 사용됩니다.

TypeScript는 정적 타입 체크와 런타임 동작의 조화를 이루기 위해 이러한 설계를 채택한 것입니다. 이로써 코드의 타입 안정성을 유지하면서 동적으로 키를 순회하고 값을 추출할 수 있는 방법을 제공합니다.

> 즉, value에 직접 접근하는 것은 타입스크립트가 값을 추론하기 쉽게 되어있기 때문에 오류가 나지 않지만, 대괄호 표기법으로 접근했을 때 대괄호 표기법의 타입이 추론되지 않기 때문에 값 접근만 허용한다.

**근데 사실 객체의 key 값은 string으로 고정되어 있을텐데?**

맞습니다. JavaScript에서 객체의 키(key)는 일반적으로 문자열(`string`) 또는 심볼(`symbol`) 형태를 가집니다. TypeScript 역시 JavaScript를 기반으로 하고 있기 때문에 객체의 키에 대한 기본 타입으로 문자열과 심볼을 사용합니다.

`Object.keys()`, `for...in` 구문, 그리고 `Object.values()`와 `Object.entries()` 함수는 JavaScript의 내장 함수들로서 이러한 객체 순회와 관련된 기능을 제공합니다. 이들 함수는 JavaScript의 동작과 호환성을 유지하기 위해 설계되었기 때문에, 객체의 키에 대한 기본 타입인 문자열(`string`)에 대해서만 보장하고 있습니다.

TypeScript는 정적 타입 체크를 수행하기 위해 사용되며, 이를 통해 코드의 타입 안정성을 제공합니다. 따라서 TypeScript에서 객체의 프로퍼티에 접근할 때는 프로퍼티의 타입을 명확하게 추론하기 위해 문자열(`string`) 또는 심볼(`symbol`)을 사용하는 것이 좋습니다. 이는 TypeScript의 정적 타입 시스템과의 호환성을 유지하면서 코드의 가독성과 안정성을 높일 수 있습니다.

**그렇다면 에러가 나지 않지 않냐는 말 아니야?**

실제로 TypeScript에서 `Object.keys()`, `for...in` 구문을 사용하여 객체를 순회할 때에도 에러가 나지 않습니다. 다만, 타입 체커가 해당 코드를 분석할 때에는 키가 문자열(`string`)로 추론되지 않기 때문에 타입 어노테이션을 추가해주는 것이 좋습니다. 이를 통해 명시적으로 키의 타입을 선언하여 TypeScript의 타입 체커에게 정확한 타입 정보를 제공할 수 있습니다.

아래는 `Object.keys()`와 `for...in` 구문을 사용한 객체 순회 예시입니다.

```ts
typescriptCopy code
interface MyObject {
  [key: string]: number;
}

const obj: MyObject = {
  foo: 1,
  bar: 2,
};

// Object.keys() 사용
Object.keys(obj).forEach((key) => {
  const value = obj[key]; // key의 타입은 여전히 string | number입니다.
  console.log(key, value);
});

// for...in 구문 사용
for (const key in obj) {
  if (Object.prototype.hasOwnProperty.call(obj, key)) {
    const value = obj[key]; // key의 타입은 여전히 string | number입니다.
    console.log(key, value);
  }
}
```

이 예시에서도 `key`의 타입은 여전히 `string | number`로 추론됩니다. 하지만 타입 체커에게 명확한 타입 정보를 제공하기 위해 `MyObject` 인터페이스에서 키의 타입을 `string`으로 지정해주었습니다. 이렇게 타입 어노테이션을 추가함으로써, 타입 체커는 해당 코드를 분석할 때 `key`를 `string`으로 추론하게 되어 정확한 타입 체크를 수행할 수 있습니다.