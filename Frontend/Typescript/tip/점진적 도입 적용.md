# 점진적 도입 적용



TypeScript를 사용해 개발 하는 단계는 크게 3가지로 나눌 수 있다.

1. Lint stage
2. Compile stage
3. Runtime stage

Lint stage는 개발자가 코드를 작성하는 시점이다. Compile은 코드를 모두 작성한 후 ts 파일을 js 파일로 변환하는 단계이다. Runtime stage는 컴파일 된 코드가 JavaScript 런타임 환경에서 실제로 동작하는 시점이다.

각 단계를 거쳐 어플리케이션이 실행된다. 위 단계로 부터 TypeScript가 어떻게 동작하는지, 어떤 환경설정이 필요한지 알아보자.

<br/>

## tsc, tsserver

TypeScript는 기존 JavaScript가 동적 타입 언어로써 코드가 실행될 때 타입 에러가 발생할 가능성이 있기 때문에 나온 언어다. TypeScript는 크게 2가지 기능을 제공한다.

1. 타입체크
2. 컴파일

타입체크는 Lint stage에서 이루어진다. 개발을 위해 사용하는 IDE에서 코드를 작성하는 순간마다 타입을 체크해주며, 타입 오류가 있을 경우에는 lint 메시지로 이를 개발자에게 알려준다. IDE에서는 어떻게 우리의 코드가 에러가 있는지 판별하는 걸까?

흔히 사용하는 VSCode는 Microsoft 사가 만든 IDE다. 그리고 TypeScript 또한 Microsoft 사가 만든 언어다. VSCode에서 TypeScript를 사용하면 TypeScript의 버전에 맞는 `TSServer`를 설정하고 VSCode는 서버로 부터 정보를 받아들이는 클라이언트 역할을 한다.

따라서 IDE는 TSServer를 이용해 TypeScript의 타입 체킹을 실시간으로 해주고, 개발자는 어떤 부분에서 타입 오류가 있는지 쉽게 알 수 있다.

컴파일은, 개발자가 TypeScript로 작성한 파일을 `tsc`를 이용해 js 파일로 변환하는 것을 말한다. tsc는 TypeScript Compiler의 줄임말이자, TypeScript CLI 명령어다.

```sh
$ npm i -D typescript
```

npm을 이용해 typescript를 설치하면 tsserver와 tsc 두가지가 함께 설치된다.

[tsc-tsserver]

사진은 node_modules 내부에 있는 typescript 패키지 안의 모습이다. tsc, tsserver가 설치된 모습을 볼 수 있다.

> ※ Microsoft사는 Web 개발 측면에서 다른 기업에 밀리고 있다는 생각 때문에 TypeScript와 VSCode를 만들어 제공했다. 
>
> TypeScript는 2012년 10월에 처음 공개되었고, Visual Studio Code는 2015년 4월에 공개되었다. VSCode에서 TypeScript를 기본 언어로 사용하는 것은 TypeScript의 개발과 사용을 촉진하고, TypeScript로 개발된 어플리케이션을 더욱 쉽게 개발할 수 있도록 지원하는 것을 목적으로 하고 있다.
>
> 즉, 개발자들이 TypeScript를 사용하게끔 유도하기위해 DX가 좋은 VSCode를 만들어 제공하면서 TypeScript 점유율을 높인 것이다.

컴파일은 Compile stage에서 이루어지는데, 또다시 컴파일에서 이루어지는 프로세스는 2가지다.

1. 타입체크
2. 트랜스파일

컴파일 전에 이미 타입체크가 진행되었다. 그 때 타입체크는 tsserver를 통해 코드 작성 시점에 체크된 것이다. 후에 컴파일 될 때도 tsc에서 타입체크를 한번 더 한다. 왜냐하면 tsserver를 통해 코드를 작성하지 않았을 수 있기 때문이다. 

컴파일러는 ts 파일에 작성된 '타입 관련 코드' 모두를 제거해 실제로 동작할 수 있는 JavaScript 코드로 변환한다. 브라우저는 TypeScript의 존재를 알 수 없고 오로지 JavaScript 파일으로 동작하기 때문이다.

여기서 타입 관련 코드 모두 제거된다는 사실에 주의해서 TypeScript 코드를 작성해야 한다. 코드를 작성할 때 '타입 영역', '값 영역'을 정확히 인지해야 한다. 이는 타입 가드 등의 기법을 사용할 경우 컴파일 시점에 사라지는 '타입 영역' 코드를 타입 가드 역할로 잘못 작성할 수 있기 때문이다.

Runtime stage에서는 컴파일된 TypeScript, 즉 js 파일이 실행된다.

<br/>

## tsconfig.json

타입스크립트를 설치하면 CLI 명령어와 옵션을 조합해 컴파일 할 수도 있지만, tsconfig.json 파일을 만들어 compileOptions를 정해두면 `tsc` 명령어를 사용할 경우 tsconfig.json 파일의 옵션을 의존해 컴파일을 실행한다.

```sh
$ tsc --init
```

위 명령어를 사용하면 프로젝트 루트에 TypeScript에서 권장되는 옵션이 켜진 상태로 `tsconfig.json` 파일이 생성된다.

### target, lib

target은, TypeScript가 tsc를 이용해 `.ts` 파일을 `.js` 파일로 컴파일(트랜스파일) 할 때 ECMAScript 어느 버전으로 변경할지를 지정하는 옵션이다. 예를 들어, 'es5'로 설정하면 es5 문법에는 화살표 함수가 없기 때문에 `() => null` 코드를 `function() { return null }` 으로 변경해준다. 하지만, 'es6'로 설정하면  `() => null` 코드를  `() => null` 그대로 사용한다.

target의 역할은 한가지 더 있다. target에 지정한 ECMAScript 버전에 해당하는 lib 옵션을 자동으로 설정(사용) 한다.

lib 옵션은, 우리가 작성하는 타입스크립트의 Type Definition 라이브러리를 어떤 것을 사용할 것인지 설정한다. `.d.ts` 파일이 타입이 정의된 Type Definition 파일이다. IDE의 tsserver가 이 파일들을 참조하여 타입스크립트에서 자바스크립트의 타입을 추론하거나 타입을 체크한다.

 아래 사진과 같이 타입스크립트 파일에 `Math`를 치고 `Command + 클릭` 해보면 아래 사진과 같이 interface가 정의된 Type Definition 파일을 보여준다.

[math-lib]

lib를 지정하지 않으면, target을 지정함에 따라 자동으로 lib가 암묵적 선택된다.

- target이 'ES3' 이면, 디폴트로 lib.d.ts 를 사용
- target이 'ES5' 이면 , 디폴트로 dom, es5, scripthost 를 사용
- target이 'ES6' 이면, 디폴트로 dom, es6, dom.iterable, scripthost 를 사용

따라서 target에 따라 지정된 lib가 사용되는데, 이를 커스텀하게 바꾸고 싶을 때 lib를 지정해줄 수 있다. `.d.ts` 파일은 실제로 node_modules의 lib 폴더에 존재한다.

[typescript-lib-directory]

또 한가지 짚고 넘어갈 부분은, target을 설정하면서 기본 값인 lib를 사용하고 있을 때, lib를 추가로 정의하면, target에 설정된 기본 값 위에 추가적인 lib가 생기는게 아니라 다시 모두 지정해주어야 한다는 점이다. 예를 들어 target이 ES5 이면서, lib를 `esnext`로 설정한다고 했을 경우, 기본으로 사용하고 있는 dom, es5, scripthost은 위의 배열에 다시 넣어주어야 한다.

브라우저 런타임 환경이 아닌 Node.js 환경같은 경우 DOM Type이 필요없기 때문에 lib에 필요한 라이브러리만 명시해서 제외시켜줄 수 있다.

나는 아래와 같이 선언해주었다.

```json
"lib": [
  "dom",
  "dom.iterable",
  "esnext"
],
```

- dom은 흔히 브라우저에서 사용하는 DOM API 관련 라이브러리다.  `let a: HTMLBodyElement;` 와 같은 interface를 에러 없이 사용할 수 있다.
- dom.iterable 내부에는 `NodeList` 같은 interface가 정의되어 있다.
- esnext는 조금 특이하다.

lib.esnext.d.ts에 들어가보면 아래와 같이 적혀있다.

[esnext]

이는 es2023, esnext.intl 파일을 참조하고 있다. es2023은, es2022를, es2022는 es2021을 ... es5 까지 이어지는데, 사이 사이에는 각 버전의 또다른 파일을 참조하고 있다. 즉, ESMAScript 버전 관련 lib 파일 모두를 참조하고 있다. TypeScript 버전이 업그레이드 될 때마다 lib 파일이 변경되거나 추가될텐데 이를 적절히 나누어 참조하고 있다는 것을 알 수 있다.

esnext를 설정해주면 소스코드에서 JavaScript 최신 문법에 대한 type을 지원받을 수 있다.

### noEmit

noEmit 설정은 `tsc` 를 사용해 컴파일 할 때, 트랜스파일링 된 JavaScript 출력 파일을 만들지 않는다. 하지만 Babel의 `@babel/preset-typescript` 라이브러리를 사용해 babel에서 출력 파일을 만들 것이기 때문에 tsc를 사용하지 않는 이상 아무런 영향을 주지 않는다. 단, 아래에서 알아볼 allowImportingTsExtensions 옵션과 함께 사용하려면 true로 주는 것이 좋다.

tsc 명령어는 `src/index.ts` 와 같이 파일을 지정해주면 tsconfig.json 파일을 무시하고 컴파일한다. 따라서 noEmit에 대해 tsc로 테스트 해보고 싶다면 `$ tsc src/index.ts --noEmit` 로 테스트 해볼 수 있다.



## import 구문에 대해서 (allowImportingTsExtensions)

### module

코드의 모듈 시스템을 설정한다. 정확히는 tsc로, TypeScript 코드가 컴파일된 `후` 생성되는 JavaScript 모듈 형식을 지정하는 옵션이다. 몇가지 옵션이 있지만 `CommonJS`, `ESNext` 두가지만 알아보자.

`module: CommonJS` 일 경우

```js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const person_1 = require("./person");
console.log(person_1.ps);
```

`module: ESNext` 일 경우

```js
import { ps } from './person';
console.log(ps);
```

CommonJS는 `require` 함수가 사용되었고, ESNext는 `import` 키워드가 사용되었다. 어느 환경에 사용하는지에 따라 지정해주면 된다.

ES6, ES2020, ESNext로 ESM 방식은 3가지가 있는데, 모두 동일하게 import 키워드를 사용하며, ES6와 ES2020의 차이점은 다이나믹 import를 지원하는지, 그리고 `import.meta`를 지원하는지 차이가 있다.

target이 지정되어 있다면 아래 값이 default로 설택된다.

- target이 'ES5' 이하면, `commonjs` 를 사용
- target이 'ES6' 이면, `ES6` 을 사용

주의할 점은, `tsc`로 컴파일 했을 경우의 결과물인 JavaScript 파일에만 변환된다. Babel을 이용해 트랜스파일링 할 경우는 이 옵션이 적용되지 않는다.

### allowImportingTsExtensions

#### tsc

TypeScript에서는 import 구분에 `./app` 과 같이 `.ts` 확장자가 없어야만 해당 파일을 가져올 수 있다. `.ts` 확장자가 붙는다면 tsc로 컴파일 했을 때 error를 뿜는다. 또, 확장자가 없이 사용하거나 `.js` 확장자를 붙여주어야 정상적으로 컴파일 된다.

```ts
import { some } from './index.ts'; // 오류
import { some } from './index'; // 성공
import { some } from './index.js'; // 성공
```

타입스크립트 파일에서 다른 타입스크립트 파일(.ts)을 가져오는데 왜 에러가 날까? [typescript-issues](https://github.com/microsoft/TypeScript/issues/27481#issuecomment-426026215) 페이지에서 그 이유를 찾을 수 있다.

```ts
a.ts: import * as b from "./b.ts";
b.ts: export const b: number = 0;
```

a, b 두 ts 파일이 있고, b라는 변수를 export 하고 있다. a.ts를 컴파일 할 때 `import` 구문은 변경하지 않는다. 즉, ts 파일이 컴파일 되면, js 파일이 되는데, import 구문은 변경하지 않기 때문에 `a.js` 파일에서 `b.ts` 파일을 가져오려고 시도할 것이다.

하지만 `b.ts` 파일도 `b.js` 파일로 이미 변환 되었기 때문에 `b.ts` 파일이 없으므로 에러가 나는 것이다. 따라서, `./b` 또는 `./b.js` 로 명시를 해주어야 한다. `./b` 와 같은 확장자가 없는 파일 경로를 TypeScript가 알 수 있는 이유는, Node.js의 CommonJS에서 경로가 없어도 모듈을 가져올 수 있는 특징 때문이다. tsc는 Node.js 위에서 동작한다.

이제, 5버전 부터는 `.ts` 확장자도 tsc에서 사용할 수 있게 변경되었다. tsconfig.json에 `allowImportingTsExtensions`을 사용하면 된다.

allowImportingTsExtensions 옵션은, TypeScript에서 `.ts`, `.mts`, `.tsx`와 같은 명시적인 확장자가 붙은 파일을 import 할 수 있게 한다. 단, `noEmit` 옵션이 true일 경우에만 사용이 가능하다.

noEmit 옵션은 컴파일 된 파일이 실제 `js` 파일로 변환되어 출력될 것인지의 여부를 결정하는 옵션이다. 원래 tsc를 사용해 js 파일로 변환하는 것이 typescript의 한가지 역할이기 때문에 이를 막는 옵션을 주는 것이 의아하게 여겨질 수 있는데, 실제 js파일로 변환하는 과정은 tsc가 하지 않고, Babel 혹은 swc같은 트랜스파일러를 사용해서 할 경우 tsc는 따로 해주지 않아도 되기 때문에 이 옵션이 존재한다.

앞서 살펴보았던 `.ts` 확장자 오류는 js로 변환되는 과정에서 import 구문은 그대로 남아 있기 때문에 문제가 되었다. 따라서 그 문제는 noEmit으로 js 파일을 생성하지 않는 것으로 TypeScript는 해결했다.

> ※ 터미널에서 작업할 경우 tsc version을 잘 확인해야한다. `$ tsc -v` 명령어를 사용해 버전을 확인하자. allowImportingTsExtensions 옵션은 5버전 이상에서 인식한다.
>
> ※ 만약 작업 디렉토리의 node_modules에 5버전 이상의 버전이 깔려있지만 tsc가 낮은 버전이라면 컴퓨터의 Global에 설치된 npm의 tsc 버전이 낮기 때문이다. `$ npm -g upgrade typescript` 를 통해 버전을 높여주거나, 그래도 tsc 버전이 낮은 상태로 유지된다면 package.json의 script에 `"build": "tsc"` 를 명시해주고, `$ npm run build` 명령어를 통해 tsc를 돌려주도록 하자.

#### Webpack

모던 프레임워크 환경에서 번들러는 필수다. 대표적으로 Webpack을 사용할 경우를 알아보자. Webpack도 마찬가지로 Node.js 위에서 동작한다. Webpack에서 TypeScript를 트랜스파일링 할 수 있는 방법은 2가지가 존재한다.

1. `ts-loader`
2. `@babel/preset-typescript`

TypeScript를 알아보면서, TypeScript가 tsc를 이용해 트랜스파일링 시 target 옵션을 통해 ECAMScript 버전도 구버전으로 변경시켜준다는 사실을 알게되었다. 그렇다면 기존에 Webpack + Babel을 사용한다면 트랜스파일링이 두번 들어가게 되는 것 아닌가 궁금했다.

`@babel/preset-typescript` 이 나오기 전에는 ts-loader로 ts 파일을 Webpack으로 가져와 tsc로 `타입체킹 + 구버전 트랜스파일링` 후 babel로 다시 `트랜스파일 + 폴리필 제공`의 역할을 했다고 한다.

이렇게 트랜스파일링이 두번 들어가면서 개발자들은 트랜스파일링이 두번 거치는 것을 원하지 않았고, TypeScript 팀과 Babel이 합작하여 나온 라이브러리가 `@babel/preset-typescript`다. 라이브러리를 사용하면 tsc가 아니라, Babel에서 ts 파일을 변환하고, 구버전으로 트랜스파일링을 진행한다. 단, `@babel/preset-typescript`는 타입 체크를 지원하지는 않기 때문에 타입 체크가 컴파일 시점에 필요하다면 tsc(ts-loader)가 반드시 필요하다.

프론트엔드에서 TypeScript를 통해 개발할 경우, Lint stage에서 tsserver가 타입체크를 해주고 있기 때문에 요즘은 Babel을 통해 트랜스파일링만 하는 추세라고 한다. ※ 백엔드를 TypeScript + Node.js 조합으로 사용하는 경우에는 Babel을 사용할 필요가 없기 때문에 경우가 다르다.

어쨌든 Webpack 환경에서는 타입스크립트 파일을 읽기 위해서 webpack.config.js 파일에 추가적인 설정이 필요하다.

```json
// webpack.config.js
module.exports = {
  (...)
  resolve: {
    extensions: ['.ts', '.js'],
  },
}
```

### esModuleInterop

이 옵션은 CommonJS/AMD/UMD 모듈을 ESM 문법으로 가져왔을 경우 연동되도록 설정하는 옵션이다. 이 옵션이 `false`로 되어있다면 CommonJS 방식을 사용하는 라이브러리는





더 자세한 것은 이곳을 참고하자. ([내 import 문이 그렇게 이상했나요?](https://www.youtube.com/watch?v=mee1QbvaO10))















   - allowJs
     - TypeScript 파일에서 `.js` 파일을 import 할 수 있게 해준다.
   - checkJs
     - allowJs와 함께 사용된다. 활성화 되면 JavaScript 파일에 오류가 발견된다. 각 JS 파일에 `// @ts-check`와 동일한 효과나 나타난다.
   - outDir
     - ts or js 파일이 여기 설정된 디렉토리로 컴파일 후 내보닌다. `.d.ts`, `.js.map` 파일 모두 이 디렉토리로 내보내진다.
   - noEmit
     - 

Babel, swc와 같은 번들러가 TypeScript 파일을 JavaScript 환경에서 실행될 수 있는 파일로 변환하는 작업을 담당할 수 있도록 한다.

   - allowImportingTsExtensions

















1. typescript, @babel/preset-typescript 설치

```sh
$ npm i -D typescript @babel/preset-typescript
```

1. babelrc 파일에 @babel/preset-typescript 설정

```json
// .babelrc
{
  "presets": [
    ["@babel/preset-typescript"],
    (...)
  ]
}
```

1. webpack.common.js

```js
// webpack.common.js
entry: {
  main: './src/index.ts', // js -> ts
},
module: {
	rules: [
    (...)
    {
       test: /\.(j|t)s$/, // babel loader에 ts도 추가
       exclude: /node_modules/,
       use: {
         loader: 'babel-loader',
         options: {
           cacheDirectory: true,
         },
       },
    },
  ]}
```



2. `tsc --init` 으로 tsconfig.json 생성

3. @typescript-eslint/parser @typescript-eslint/eslint-plugin 설치

```ts
// .eslintrc.js
extends: [
  (...)
  'plugin:@typescript-eslint/recommended',
],
parser: '@typescript-eslint/parser',
```

















레퍼런스

- https://norux.me/59 (typescript lib)
- 





















