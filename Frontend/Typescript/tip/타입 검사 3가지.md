# 타입 검사 3가지

TypeScript를 사용할 때 3가지 방법으로 타입(검사)를 사용할 수 있다.

1. 런타임 => 타입 가드(더 있을 수 있다)
2. IDE => 타입 체커 (TSServer)
3. 컴파일 => TSC (loader..)
   - babel-loader
   - esbuild
   - ts-loader
   - awesome-typescript-loader

- 리액트에서 하는 방법이 또 있다. 뭘까?
  - props-types (런타임 체킹)
  - MobX => MST (런타임 체킹)

---

## TypeScript는 왜 런타임에 타입이 결정되도록 허술하게 허용할까?

TypeScript는 정적 타입 검사를 제공하는 언어이지만, 이는 개발 시간에 코드에서 타입 오류를 감지하고 수정하는 것을 돕기 위한 것입니다. TypeScript의 타입 시스템은 런타임에는 제거되고, 일반적인 JavaScript 코드처럼 실행됩니다. 이렇게 함으로써 TypeScript는 코드의 유연성과 호환성을 보장하면서, 정적 타입 검사의 이점을 제공합니다.

따라서, TypeScript에서 일부 유형의 불일치를 허용하면 런타임 중에 유용한 유연성을 제공할 수 있습니다. 이러한 유형의 불일치는 런타임 오류를 일으킬 수 있지만, 타입 검사를 수행하는 것보다 유연성이 더 중요한 경우가 있습니다. 이러한 상황에서 TypeScript는 프로그래머가 런타임 오류를 방지하도록 도울 수 있는 유용한 경고를 제공합니다.

또한, TypeScript는 JavaScript 코드의 타입 시스템을 적용하기 때문에, JavaScript 코드의 동작과 호환성을 유지합니다. 이를 통해 기존 JavaScript 코드를 TypeScript로 마이그레이션하는 과정에서도 코드를 수정하지 않고 호환성을 유지할 수 있습니다.

---

다른 답

TypeScript는 JavaScript와 호환성을 유지하기 위해, 런타임 시 동적으로 타입이 결정되는 것을 일부 허용합니다. 이것은 JavaScript에서 동적으로 값을 할당하거나 객체의 속성을 동적으로 추가하는 경우에 발생할 수 있습니다. 이러한 경우 TypeScript는 타입 검사를 보장하기 어렵기 때문에, 일부 상황에서 허용하는 것입니다.

예를 들어, 다음과 같은 JavaScript 코드가 있다고 가정해 봅시다.

```js
const obj = {};
obj.name = "John";
```

이 코드는 동적으로 객체에 속성을 추가하는 것이므로, TypeScript에서는 이것이 런타임에서 일어나기 때문에 컴파일 시점에서 타입 검사를 할 수 없습니다. 따라서 TypeScript는 이를 허용합니다. 그러나 이 경우에도, `obj` 객체가 다른 곳에서 전달되거나 사용될 때, 해당 코드가 예상한 대로 동작할지 보장할 수 없기 때문에 가능한 한 이러한 동적인 타입 할당을 최소화하는 것이 좋습니다.

---

어쨌든, 런타임에 타입이 결정되도록 허술하게 허용하는 이유는, JavaScript의 호환성 때문이다.