# Hoisting

<br/>

> 출처: https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/JavaScript#part-2-2-javascript

- ES6 문법이 표준화 되면서 신경쓰지 않아도 되지만 자바스크립트가 가진 특성을 가장 잘 보여주므로 알아보자.

<br/>

## 정의

- `hoist` 라는 단어의 사전적 정의는 **끌어올리기**라는 뜻이다. 자바스크립트에서 끌어올려지는 것은 변수임.
- 하지만 코드 단계에서는 어떠한 이동도 발견되지 안고, 함수와 변수 선언부는 컴파일 단계에서 메모리에 추가된다. (https://webruden.tistory.com/137)
- `var` 키워드로 선언된 모든 변수 선언은 **호이스트** 된다. 호이스트란 변수의 정의가 그 범위에 따라 `선언`과 `할당`으로 분리되는 것을 의미함.
- 즉, 변수가 함수 내에 정의되었을 경우, 선언이 함수의 최상위로, 함수 바깥에서 정의되었을 경우, 전역 컨텍스트의 최상위로 변겅 됨.

우선 선언(Declaration)과 할당(Assignment)을 이해해야 한다. 끌어올려지는 것은 선언임.

```javascript
function getX() {
  console.log(x);  // undefined
  var x = 100;
  console.log(x);  // 100
}
getX();
```

- 다른 언어의 경우엔, 변수 x를 선언하지 않고 출력하려 한다면 오류를 발생할 것이다. 하지만 자바스크립트에서는 `undefined` 라고 하고 넘어감.
- `var x = 100;` 이 구문에서 `var x;` 를 호이스트 하기 때문. 즉, 변수에 할당된 값까지 같이 올리는게 아니라 변수 자체만 올라감.
- 즉, 작동 순서에 맞게 코드를 재구성하면 다음과 같다.

```javascript
function getX() {
  var x;
  console.log(x);
  x = 100;
  console.log(x);
}
getX();
```

선언문은 항시 자바스크립트 엔진 구동 시 가장 최우선으로 해석하므로 호이스팅 되고, **할당 구문은 런타임 과정에서 이루어지기 때문**에 호이스팅 되지 않음.

- 함수가 자신이 위치한 코드에 상관없이, 함수 선언문 형태로 정의한 함수의 유효범위는, 전체 코드의 맨 처음부터 시작한다.
- 함수 선언이 함수 실행 부분보다 뒤에 있더라도 자바스크립트 엔진이 함수 선언을 끌올 하는 것을 의미함. 함수 호이스팅은 함수를 끌올하지만 변수의 `값`은 끌올 하지 않음.

```javascript
foo();
function foo() {
  console.log('hello');
}

// hello
```

- foo 함수에 대한 선언을 호이스팅하여 global 객체에 등록시키기 때문에 `hello`가 제대로 출력된다.

```javascript
foo();
var foo = function() {
  console.log('hello');
}

// Uncaught TypeError: foo is not a function
```

- 위의 예제 함수 표현은 함수 리터럴을 할당하는 구조이기 때문에 호이스팅 되지 않으며 그렇기 때문에 런타임 환경에서 `Type Error`를 발생시킴.

<br/>

## 호이스팅 현상 발생 이유

> 출처: https://2dubbing.tistory.com/68

Javascript는 코드가 실행될 때 `실행 컨텍스트`가 생성된다. 이 때, 실행 컨텍스트 내부 변수 객체에서 현재 컨텍스트에 사용되는 변수 또는 함수를 생성함.

변수가 생성되는 과정은 3단계로 나뉨.

1. 변수 선언
2. 변수 초기화
3. 변수에 사용자가 지정한 값으로 초기화

여기서 **3. 변수에 지정한 값 할당**은 해당 실행 컨텍스트의 변수 객체 생성이 완료된 뒤에 실행됨. 즉, 변수의 선언 + 초기화와 사용자가 지정한 값 초기화가 발생되는 환경이 나뉘어 발생됨.

함수의 경우 **함수 선언문**인지 **함수 표현식**형태인지 따라 생성과정에 차이가 있음.

- 함수 선언문
  - 변수 객체가 만들어지는 과정에서 함수 선언, 초기화, 사용자 지정 값으로 초기화 3단계 모두 발생함.
  - 즉, 실행 단계에서 함수 선언문보다 함수 호출이 먼저 발생해도 에러가 나지 않고 정상적으로 실행됨.
- 함수 표현식
  - 익명함수를 생성하여 변수에 할당하는 방식(변수 호이스팅 적용).
  - 즉, 실행 단계에서 함수 표현식보다 함수 호출이 먼저 발생하게 되면 TypeError가 발생.

<br/>

## Const, let 의 호이스팅

const, let으로 정의된 변수도 호이스팅 된다!!! 우와…

하지만, const 또는 let으로 변수를 **정의하기 전에 그 변수를 사용하려고 하면** 참조 에러가 발생한다.

```js
console.log(foo);   // 참조 에러
const foo = 1;
```

똑같은 경우에 `var` 는 에러가 발생하지 않았다.(undifined) 따라서 const, let은 호이스팅이 되지 않는다고 생각하기 쉽다. 다만 변수가 정의된 위치와 호이스팅된 위치 사이에서 변수를 사용하려고 하면 에러가 발생한다. 이 구간을 `임시적 사각지대(temporal dead zone)` 라고 한다.

임시적 사각지대에서 변수를 사용하지 못한다면 호이스팅의 역할은 무엇일까? 다음 코드에서는 같은 이름의 변수가 서로 다른 스코프에 정의되어 있다.

```js
const foo = 1;   // 📌 1
{
  console.log(foo);  // 참조 에러 📌 2
  const foo = 3;   // 📌 3
}
```

만약 📌 3 변수가 호이스팅 되지 않았다면, 참조 에러는 발생하지 않고 📌 1 의 값이 출력될 것이다. 이 예제를 통해 호이스팅의 역할을 짐작할 수 있다. 📌 3 변수의 호이스팅 때문에, 📌 2 는 📌 3을 참조하게 된다. 그리고 📌 3 변수를 참조했지만 임시적 사각지대여서 에러가 발생한다.

따라서 미루어 생각해보면, 임시적 사각지대 때문에 다른 변수를 참조하지 않고 에러를 내주어 안전하게 코딩할 수 있다. 복잡도를 낮춰주는 것.

<br/>

> `정리`
>
> 호이스팅은 ES6 에서 작동하진 않겠는데.. 어쨌든 의미는 파악했다. 하지만 궁금한 것은 왜 호이스팅 환경에서 Javascript가 만들어졌는지가 궁금하다. Javascript 이전 언어들에서 호이스팅이라는 개념이 없었을텐데.. 단순히 변수나 함수를 끌올하여 부르기 쉬워진 것은 맞지만 어떻게 생각해보면 더 헷갈릴 수 있는 환경이 아닌가?
>
> -> 찾아보니 javascirpt를 만들 때 java에 탑승하기 위해 java란 이름을 앞에 붙여서 출시할 정도로 빨리 개발되었다. 그러는 과정에 유연하게 사용되는 언어를 만들게 되면서 이 개념이 나온듯.
>
> -> const, let의 호이스팅을 보면서 ES6에서도 호이스팅이 일어나고, 더 안전하게 개발할 수 있겠다는 생각이 든다. 이해 완료!
