# 함수의 내부 메서드

## 내부 메서드 Call, Constructor

함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수도, 생성자 함수로서 호출 할 수 있다. 생성자 함수로 호출한다는 것은 `new` 연산자와 함께 호출해 객체를 생성하는 것을 의미.

함수는 객체이므로 일반 객체와 동일하게 동작할 수 있음. 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가지고 있다. 하지만, 함수는 객체지만 일반 객체와 다름. **일반 객체는 호출할 수 없지만, 함수는 호출할 수 있다.** 함수는 함수로 동작하기 위해 \[[Environment]], \[[formalParameters]] 등의 내부 슬롯과 \[[Call]], \[[Constructor]] 같은 내부 메서들르 추가로 가지고 있음.

함수가 일반 함수로 호출되면 함수 객체의 내부 메서드 \[[Call]]이 호출되고, new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 \[[Constructor]]가 호출된다.

<br/>

내부 메서드 \[[Call]]을 갖는 함수를 callable이라고 하며, 내부 메서드 \[[Constructor]]를 갖는 함수를 constructor, \[[Constructor]]를 갖지 않는 함수 객체를 non-constructor라고 부름. 함수는 무조건 callable이어야 하고, constructor, non-constructor일 수 있다.

- constructor : 함수 선언문, 함수 표현식, 클래스
- non-constructor : 메서드(ES6 메서드 축약 표현), 화살표 함수

메서드를 한번 보자.

```js
// 프로퍼티 x의 값으로 할당된 것은 일반 함수로 정의된 '함수'다. 이는 메서드로 인정하지 않는다.
const bas = {
  x: function() {},
}
new bas.x(); // x {}

// 메서드 정의 : ES6의 메서드 축약 표현만 메서드로 인정함.
const obj = {
  x() {},
}
new obj.x(); // TypeError: obj.x is not a constructor
```

