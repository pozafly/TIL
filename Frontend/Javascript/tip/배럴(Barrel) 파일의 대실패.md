# 배럴(Barrel) 파일의 대실패

> [출처](https://github.com/yeonjuan/dev-blog/blob/master/JavaScript/speeding-up-the-javascript-ecosystem-the-barrel-file-debacle.md)

## 요약

많은 프로젝트에 다른 파일을 다시 export 하는 파일들로 가득 차 있다. 소위 '배럴(Barrel) 파일'이라고 불리는 이런 파일은 대규모 프로젝트에서 JavaScript 툴이 느려지는 주요 원인 중 하나다.

---

## 개요

```javascript
import { foo } from "./some/other-file";

export function myCoolCode() {
  // 아주 똑똑한 코드라고 가정합니다. :)
  const result = foo();
  return result;
}
```

코드를 실행해보니 완료시간 까지 너무 오래 걸린다. 수행 시간을 측정해보자.

```javascript
import { foo } from "./some/other-file";

export function myCoolCode() {
  console.time();
  const result = foo();
  console.timeEnd();
  return result;
}
```

측정된 값은 매우 짧은 시간이 나옴. 그러면 함수 내부에서가 아니라, 메인 진입점 파일에 `console.time()` 문을 추가해보자. 역시 마찬가지다.

<br/>

## 자세한 정보 수집

핵심 정보는 코드 런타임 문제가 아니라는 것이다. 즉, 코드를 실행하기 전이나 후에 시간이 낭비된다. 도구에 소요되는 시간은 프로젝트 코드를 실행하기 전에 소비된다.

일부 npm 패키지는 성능 때문에 미리 번들링 하기도 한다. esbuild를 사용해 단일 파일로 번들링 해보자. minification을 의도적으로 비활성화하고.

번들링은 빠르게 된다. 걸리는 시간을 측정해보니 둘을 합친 시간이 원본 소스코드를 실행하는 것보다 여전히 빠르다. 번들러가 하는 일은 모듈 그래프를 평평하게 만들고 변합하는 것이라는 사실이 떠오른다. 수천 개의 파일로 구성되어 있던 모듈 그래프가 esbuild를 통해 단일 파일로 병합된다. 모듈 그래프 크기가 진짜 문제라는 강력한 지표가 된다. 그리고 배럴 파일이 그 주요 원인이다.

<br/>

## 배럴 파일 해부

배럴 파일은 다른 파일만 내보내고 코드 자체는 포함하지 않는 파일이다. 에디터에 자동 import 같은 편의 기능이 없던 시절에는 많은 개발자가 직접 import 문을 작성했고, import 문을 최소화하려고 노력했다.

```javascript
// 이 import 문을 보세요.
import { foo } from "../foo";
import { bar } from "../bar";
import { baz } from "../baz";
```

모든 폴더에 일반적으로 같은 디렉토리에 있는 다른 파일에서 코드를 다시 export (re-export) 하는 자체 `index.js` 파일이 생기는 패턴이 생겼다. 이런 파일이 있으면 다른 모든 코드가 하나의 import 문만 참조하면 되기 때문에 수동 입력이 줄어드는 효과가 있었음.

```javascript
// feature/index.js
export * from "./foo";
export * from "./bar";
export * from "./baz";
```

이제 이전에 표시된 import 문을 한 줄로 축소할 수 있다.

```js
import { foo, bar, baz } from "../feature";
```

시간이 지나면 이 패턴이 코드 베이스 전체에 퍼지고 프로젝트의 모든 폴더에 `index.js` 파일이 생긴다.

<br/>

## 괜찮지 않다

이 규칙이면 모듈은 다른 파일을 import 하는 또 다른 배럴 파일을 import 하고, 이 배럴 파일은 또 다른 배럴 파일을 가져오는 식으로 import 할 가능성이 높음. 거미줄처럼 얽힌 import 문을 통해 프로젝트의 모든 파일을 import 하게 된다. 그리고 프로젝트 클수록 이런 모든 모듈을 로드하는데 시간이 더 오래걸린다.

뭐가 더 빠를까? 3만 개의 파일을 로드하기? 아니면 10개? 아마도 10개의 파일만 로드하는 것이 더 빠를 것이다.

모듈이 필요할 때만 로드된다는 것은 JavaScript 개발자들 사이에서 흔히 발생하는 오해임. 사실이 아님. 왜냐하면 그렇게 하면 전역이나 모듈 실행 순서에 의존하는 코드가 손상될 수 있음.

```javascript
// a.js
globalThis.foo = 123;

// b.js
console.log(globalThis.foo); // 123 이 로깅되어야 함

// index.js
import "./a";
import "./b";
```

엔진이 첫 번째 `./a` import 를 로드하지 않으면, 코드는 예기치 않게 `123` 대신 `undefined` 가 나옴.

<br/>

## 배럴 파일이 성능에 미치는 영향

테스트 러너와 같은 도구를 고려하면 상황은 더욱 심각해짐. jest 테스트 러너에서 각 테스트 파일은 고유한 자식 프로세스에서 실행된다. 이는 사실상 모든 테스트 파일이 모듈 그래프를 처음부터 다시 구성하고 그에 대한 비용을 지불해야 한다는 것을 뜻한다. 프로젝트에서 모듈 그래프를 구성하는데 6초가 걸리고 테스트 파일이 100개만 있다고 가정하면 모듈 그래프를 반복적으로 구성하는데 총 10분을 낭비한다는 것이다. 그 동안 테스트나 다른 코드는 실행되지 않는다. 엔진이 소스 코드를 준비해서 실행할 수 있도록 하는데 필요한 시간일 뿐이다.

배럴 파일이 성능에 심각한 영향을 미치는 것은 모든 종류의 import 사이클 린트 규칙이다. 일반적으로 린터는 파일 단위로 실행되므로 모듈 그래프를 구성하는데 드는 비용을 모든 파일에 지불해야 함. 이로 인해 린팅 시간이 통제 불능 상태가 되어 대규모 프로젝트에서 갑자기 린팅에 몇 시간이 걸리는 경우가 종종 있음.

실험해보자. 모든 파일은 비어있고, import 문 이외의 코드는 포함하지 않는다.

![image](https://github.com/pozafly/TIL/assets/59427983/ea27c4d8-bb64-44c2-8115-27f957feea46)

모듈을 적게 로드하면 그만한 가치가 있음. 100개의 테스트 파일이 있는 프로젝트에 적용하고, 각 테스트 파일에 새로운 자식 프로세스를 생성하는 테스트 실행 도구를 사용한다 가정해보자. 여기서는 테스트 러너가 4개의 테스트를 병렬로 실행할 수 있다고 가정한다.

- 모듈 500 개: `0.15s \* 100 / 4` = `3.75s` 오버헤드
- 모듈 1000 개: `0.31s \* 100 / 4` = `7.75s` 오버헤드
- 모듈 10000 개: `3.12s \* 100 / 4` = `1:18m` 오버헤드
- 모듈 25000 개: `16.81s \* 100 / 4` = `~7:00m` 오버헤드
- 모듈 50000 개: `48.44s \* 100 / 4` = `~20:00m` 오버헤드

실제 프로젝트에서는 이 수치가 더 나빠질 가능성이 높다. 배럴 파일은 툴링 성능 측면에서 좋지 않다.

<br/>

## 해야 할 일

배럴 파일이 몇 개만 있는 것은 보통 괜찮지만, 모든 폴더에 배럴 파일이 있으면 문제가 된다. 배럴 파일을 광범위하게 사용하는 프로젝트에서 작업하는 경우, 많은 작업을 60~80% 더 빠르게 만드는 무료 최적화를 적용할 수 있음. 모든 배럴 파일을 제거해라.
