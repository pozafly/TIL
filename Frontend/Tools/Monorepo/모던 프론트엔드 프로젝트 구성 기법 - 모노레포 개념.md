# 모던 프론트엔드 프로젝트 구성 기법 - 모노레포 개념

> [출처](https://d2.naver.com/helloworld/0923884)

## 1. 모노레포의 등장 배경

> 모노레포란 버전 관리 시스템에서 두 개 이상의 프로젝트 코드가 동일한 저장소에 저장되는 소프트웨어 개발 전략
>
> [위키백과](https://en.wikipedia.org/wiki/Monorepo)

이 개발 전략은 고전적 소프트웨어 개발 방식인 모놀리식 애플리케이션의 한계에 대한 비판에서 출발함.

### 모놀리식 어플리케이션의 한계

> SW 엔지니어링에서 모놀리식 어플리케이션은 모듈화 없이 설계된 소프트웨어 어플리케이션을 말한다.

![image](https://github.com/pozafly/TIL/assets/59427983/6cddecc6-4d30-4953-b12e-cd8d08c82f79)

네이버와 같은 거대 서비스를 개발할 때, 소스 코드가 모듈화 없이 하나의 프로젝트로 구성된다면? 코드가 서로 직접적으로 의존하며 단 하나의 버전으로 관리되면서 [관심분리(separation of concerns)](https://ko.wikipedia.org/wiki/%EA%B4%80%EC%8B%AC%EC%82%AC_%EB%B6%84%EB%A6%AC)가 어려워지고, 설계, 리팩토링, 배포 등의 작업을 매번 거대한 단위로 처리해야 하므로 개발상 많은 제약과 비효율이 있다.

### 모듈화와 재사용성

이런 모놀리식 구조의 한계는 [모듈화(modularity)](https://en.wikipedia.org/wiki/Modularity)를 통해 해결할 수 있음. 일반적으로 [모듈식 프로그래밍(modular programming)](https://en.wikipedia.org/wiki/Modular_programming)은 어플리케이션 로직의 일부를 재사용할 수 있도록 지원하고 전체 교체 없이 어플의 일부를 수정 또는 교체할 수 있게 해 유지관리를 용이하게 한다.

![image](https://github.com/pozafly/TIL/assets/59427983/6f1ac9ae-1a34-4cc1-a7d3-b1e21cf4825f)

그런데 이렇게 만든 모듈이 다른 어플에서도 사용될 수 있다면 소스를 어디에 위치시켜야 할까? 아마도 해당 모듈을 위한 독자적인 저장소가 있다면 좀 더 관리하기 쉬울 것이다. 이 구조가 바로 멀티레포(multirepo)다.

### 멀티레포

멀티레포 구조는 폴리레포(polyrepo) 구조라고도 부른다. 앞선 예시의 분리된 각 모듈은 멀티레포 구조에서 고유한 저장소가 있는 독자적 프로젝트가 된다. 각 프로젝트는 자율성이 높으며 독립적인 개발, 린트, 테스트, 빌드, 게시, 배포 파이프라인이 존재함.

![image](https://github.com/pozafly/TIL/assets/59427983/47b7fa87-9ab2-441b-bf4e-d0f21f19cb3d)

멀티레포는 현재 대부분의 어플을 개발하는 표준적인 방법임. 업계는 **팀의 자율성** 이라는 큰 이유 때문에 이 방식을 선호함. 팀은 어플 개발의 아이프 사이클을 스스로 결정하기를 원한다.

![image](https://github.com/pozafly/TIL/assets/59427983/2ecd3f58-65e2-4365-acbd-2bb7a9f951f2)

좋은 일인데 무엇이 문제? 양날의 검처럼 이 **[자율성은 고립(isolation)에 의해 제공되고 고립은 협업을 방해한다](https://monorepo.tools/#polyrepo-concept)**. 멀티레포를 통해 모놀리식 구조의 문제를 해결했지만 새로운 문제가 생김

## 멀티레포의 문제

- 번거로운 프로젝트 생성

새로운 공유 패키지를 생성할 때마다 다음과 같이 번거로운 과정을 거쳐야 한다.

저장소 생성 > 커미터 추가 > 개발 환경 구축 > CI / CD 구축 > 빌드 > 패키지 저장소에 publish

![image](https://github.com/pozafly/TIL/assets/59427983/e0829ea1-b59f-4e93-9002-68df764471a6)

- 패키지 중복 코드 가능성

위의 번거로움을 피하기 위해 각 프로젝트에서 공통 구성 요소를 자체적으로 작성하면, 초기 시간을 아낄 수 있지만 시간이 지날 수록 보안 및 품질 관리 부담을 증가시킨다.

- 관리 포인트 증가

늘어난 플젝 저장소의 수만큼 관리 포인트가 늘어난다. 린트, 테스트, 개발 모드 실행, 게시, 배포 등의 과정을 저장소의 수만큼 반복해야 한다.

- 일관성 없는 개발자 경험(DX)

각 프로젝트는 테스트 실행, 빌드, 테스트, 린트, 배포 등을 위해 고유한 명령 집합을 사용한다. 이러한 불일치는 여러 프로젝트에서 사용할 명령을 기억해야 하는 정신적 오버헤드를 만든다.

- 다른 패키지의 변경 사항 파악

관련 패키지의 변화를 지켜보거나 통지받지 않으면 문제가 발생할 수 있다.

- 교차 저장소의 리팩터링 비용

관련 패키지의 변화가 있을 때 여러 저장소에 걸쳐 변화를 반영하는 것은 쉬운 일이 아닐 것이다. 또한 이렇게 리팩터링된 각 패키지의 버전은 어떻게 관리해야 할까.

그렇다면 모듈을 적절히 분리해 관심 분리를 이루면서, 동시에 분리된 모듈을 쉽게 참조하고 테스트, 빌드, 배포 과정도 쉽게 한 번에 할 수는 없을까? 답은 모노레포.

<br/>

## 2. 모노레포가 해결하는 문제

### 모노레포의 특징

모노레포(Monorepo) 구조는 두 개 이상의 프로젝트가 동일 저장소에 저장되는 소프트웨어 개발 전략이다. 앞선 예시의 분리된 모듈들은 모노레포에서 여전히 독자 프로젝트로 존재하지만 저장소는 같은 곳을 사용한다.

![image](https://github.com/pozafly/TIL/assets/59427983/e187733b-86cb-498c-ab8d-935a0a51b249)

모노레포의 또 다른 중요한 특징 중 하나는 **프로젝트 간의 관계**다. 단순 여러 프로젝트가 하나의 저장소를 사용한다고 해서 모노레포 구조라고 부르게이는 부족함. 흔히 모노레포에서는 프로젝트 사이에 의존성이 존재하거나 같은 제품군이라거나 하는 정의된 관계가 존재한다. 아래에서 소개할 모노레포 관리 도구는 이런 **관계를 효율적으로 관리해주는 도구**라고 볼 수 있다.

### 모노레포가 해결하는 멀티레포의 문제

- 더 쉬운 플젝 생성

멀티레포에서 공유 패키지를 만들 때 다음과 같은 과정을 거친다.

저장소 생성 > 커미터 추가 > 개발환경 구축 > CI/CD 구축 > 빌드 > 패키지 저장소에 publish

모노레포에서는 저장소 생성 및 커미터 추가 과정이 필요 없고, 개발 환경, CI/CD, 빌드, 게시 등의 과정에 기존 DevOps를 이용하므로 새 프로젝트 생성에 대한 오버헤드가 없다.

- 더 쉬운 의존성 관리

의존성 패키지가 같은 저장소에 있으므로 버전이 지정된 패키지를 npm registry와 같은 곳에 publish할 필요가 없다.

- 단일화된 관리 포인트

개발환경 및 DevOps에 대한 업데이트를 한 번에 반영할 수 있다.

- 일관된 개발자 경험 제공

애플리케이션을 일관되게 구축하고 테스트할 수 있다. 개발자는 다른 팀의 애플리케이션에 자신 있게 기여하고 변경 사항이 안전한지 확인할 수 있다.

- 프로젝트들에 걸친 원자적 커밋

커밋할 때마다 모든 것이 함께 작동한다. 변경 사항의 영향을 받는 조직에서 쉽게 변화를 확인할 수 있다.

- 서로 의존하는 저장소들의 리팩토링 비용감소

모노레포는 대규모 변경을 훨씬 더 간단하게 만든다. 100개의 라이브러리로 만든 10개의 앱을 리팩터링하고 변경을 커밋하기 전에 모두 작동하는지 확인할 수 있다.

### 그 밖의 모노레포 특징

- 테스트 및 빌드 범위 최소화

소스 변경 시 모든 프로젝트를 다시 빌드하거나 다시 테스트하지 않는다. 대신 변경 사항의 영향을 받는 프로젝트만 다시 테스트하고 빌드한다.

### 모노레포에 대한 오해

- 다른 팀이 내가 모르는 사이에 내 코드를 변경한다면?

GitHub에는 [CODEOWNERS](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners)와 같은 기능을 사용하여 폴더 기반으로 소유권을 구성할 수 있다.

```
@global-owner1 @global-owner2 ## 이 저장소에 대한 모든 PR을 소유자에게 리뷰받아야 머지할 수 있다.
packages/todo-api/* @john @jane ## todo-api 경로는 john과 jane에게 리뷰받아야 한다.  
packages/i18n/* @michael ## i18n은 michael에게 리뷰받아야 한다.  
```

- 모노레포가 멀티레포보다 항상 나은 방법인가?

그렇지 않다. 멀티레포의 단점이 모노레포의 장점이고, 장단점이 교차하기 때문에 적절한 상황에서 사용해야 함. 모노레포의 핵심적 특징은 프로젝트 사이의 관계이고, 모노레포가 적절한 상황은 다음과 같음.

- 유사한 제품의 집합
- 여러 프로젝트의 변화를 한 눈에 파악해야 할 때
- 호스트 어플리케이션을 플러그인 등으로 확장할 때
- 공통 기능을 재사용하는 관련된 프로젝트의 집합
- 유사한 DevOps로 구성된 프로젝트의 집합

<br/>

## 3. 모노레포를 구축할 때 고려할 측면

모노레포를 구출하려고 할 때 **관리 용이성**, **속도** 그리**고 프로젝트 구조 관리** 측면에서는 다음과 같은 사항을 고려해야 함.

> 분류 기준은 [Monorepo features](https://monorepo.tools/#monorepo-features)를 참고했다.

### 관리 측면

- 코드 공유: 서로 다른 프로젝트 간에 쉽게 소스 코드를 공유
- 일관성 있는 도구: 서로 다른 프로젝트들(심지어 서로 다른 프레임워크를 사용하더라도)에서 일관된 개발 경험을 제공
- 스케폴딩: 새로운 프로젝트를 생성할 때 초기 코드를 쉽게 생성
- 프로젝트 제약 및 가시성(visibility): 저장소 내에서 의존 관계를 제한하는 규칙 정의 지원. 예를 들어, 일부 프로젝트를 팀 전용으로 표시하거나 특정 프레임워크을 사용 중임을 기술.

### 속도 측면

- 로컬 캐싱: 같은 머신에서 같은 것을 두 번 빌드하거나 테스트하지 않음
- 분산 캐싱: 다양한 환경에서 캐시 아티팩트를 공유. 즉, 조직 단위로 여러 CI 환경에 걸쳐 같은 것을 두 번 빌드, 테스트하지 않음
- 로컬 작업 오케스트레이션: 빌드 및 테스트 등의 작업을 순서에 맞게 병렬로 실행
- 분산 작업 실행: 단일 시스템에서 실행되어 여러 시스템에 명령을 전달
- 변화에 영향을 받는 프로젝트 감지: 변경의 영향을 받을 수 있는 항목을 결정하여 영향을 받는 프로젝트만 빌드/테스트

### 구조 파악 측면

- 워크스페이스 분석: 추가 구성 없이 주어진 워크 스페이스의 의존성 관계를 분석
- 의존성 그래프 시각화: 프로젝트 및 작업 간의 종속 관계를 시각화

<br/>

## 4. 모노레포 구축을 도와주는 도구

그럼 어떤 도구를 통해 위에 고려한 측면을 구축하고 지원받을 수 있을까? [2021.stateofjs.com](https://2021.stateofjs.com/en-US/libraries/monorepo-tools) 기준으로 인기있는 도구를 살펴보면 다음과 같다.

### 얼마나 사용되는가

Lerna, Yarn, npm, pnpm, Nx 등이 많이 사용되었다.

![image](https://github.com/pozafly/TIL/assets/59427983/76c27bcc-16d1-449e-9462-f3d44c191741)

### 얼마나 만족하는가

pnpm, Turborepo, Nx, npm, Yarn 등을 훌륭하게 평가하였다.

![image](https://github.com/pozafly/TIL/assets/59427983/5ca61100-ddde-4e45-894c-6dd227da4321)
