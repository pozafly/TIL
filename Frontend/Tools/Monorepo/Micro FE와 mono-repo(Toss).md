# Micro FE와 mono-repo

> [출처](https://velog.io/@dalbodre_ari/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%99%80-%EB%AA%A8%EB%85%B8%EB%A0%88%ED%8F%AC-%EC%A0%9C%EB%A1%9C%EB%B9%8C%EB%93%9C)

## 모노리스 아키텍쳐에서부터 마이크로 프론트엔드까지

![image](https://github.com/pozafly/TIL/assets/59427983/d88ff839-df50-4f26-94f3-9e63724540d0)

### 모노리스(Monolith) 아키텍쳐

모노리스는 모놀리식이라고 불린다. 둘 다 같은 말임.

기존 개발 방식으로 각각의 기능들을 개발한 후 하나의 앱으로 패키징 해 배포하는 것을 말함. 일반적으로 하나의 repo에 하나의 큰 앱만 존재하고, 코드 공유가 쉽고 형식 통일과 배포 관리에 용이함.

여러 팀으로 구성되는 대규모 플젝에서 문제가 있음. 계정/상품 확인/장바구니/배송/결제 기능이 포함된 인터넷 쇼핑몰에서, 결제 기능을 개발하기 위해 로그인 개발이 먼저 완료되어야 하는 등 개발 병목 현상이 발생함. 결제 시스템에서 문제가 생기더라도 상품 확인 및 장바구니를 포함한 기능을 사용하지 못하게 되는 에러 확산이 발생하기도 함.

전체 서비스가 하나의 프레임워크와 언어에 제한되는 경우도 생김. 블록체인 모듈은 node를 사용하는데 서버를 spring을 통해 서비스를 시작하는 경우 이를 통해 연동해야 함. 또한 수정하지 않은 다른 기능들을 포함한 전체 서비스 빌드가 필요하고, 작은 변경에도 높은 테스트 비용이 발생함.

### SOA, MSA

SOA : Service Oriented Architecture, MSA : Micro Service Architecture

이런 문제를 해결하기 위해 프론트, 백단이 나위기도 하고 공통 모듈을 기반으로 개발 모듈들의 의존성을 줄인 SOA와 아예 모듈들을 분리해 API로 통신하는 마이크로 서비스 아키텍쳐가 제안되기도 함. [참고](https://www.redhat.com/ko/topics/cloud-native-apps/what-is-service-oriented-architecture)

MSA에서 쇼핑몰의 경우 각각의 서비스는 개별적으로 모듈화 되어 독립적 테스트 및 배포가 이루어짐. 서비스 구현 기술과는 상관없이 API를 사용해 통신하기 때문에 서비스별로 기술스택이 달라도 상관 없음. 특히 대규모이면서 레거시 코드가 대부분인 플젝에서 이와 구분해 새로운 기술스택을 사용한 기능 개발에 제한이 없다는 장점이 있음.

백엔드에서 MSA가 많이 사용되는 것에 반해 FE는 모노리스 상태를 최근까지 유지해왔음. 백엔트와 비슷하게 시간이 지나며 규모가 커지며 여러 팀이 함께 하나의 서비스를 개발하게 되면서 점차 유지관리가 어려워짐에 따라 대규모 플젝에서 MSA가 도입되기 시작함.

### 마이크로 프론트엔드

FE에서 개별 팀이 담당하는 비즈니스 영역을 모듈화 하여 완전히 구분하는 것을 말함. 한 앱의 각각 일부 앱만 담당하는 것이 아니라, 각 팀 내 DB 부터 UI까지 end-to-end를 완료하는 것임.

마이크로 FE를 구성하는 방법에는 서버 템플릿 통합, 빌드 타임 통합, iframe을 통한 런타임 통합, JS를 통한 런타임 통합, Web Components를 통한 런타임 통합 방식이 있다. 이 중 토스에서도 사용하고 있고, lerna를 통해 쉽게 사용할 수 있어 보이는(?) 빌드 타임 통합 방식에 대해 조금 더 이야기할 수 있다.

<br/>

## 토스의 Micro FE 도입기: 의존성 지옥과 긴 빌드 타임

토스는 8~9명으로 구성된 사일로가 하나의 기능 개발을 담당한다. 각 사일로 마다 개별 서비스를 구현, 21년 세미나 당시 25개 이상의 리액트 서비스가 존재함. 새로운 플젝은 자연스럽게 기존 존재하던 플젝에 추가되는 형태로, 각 서비스는 웹팩의 엔트리포인트로 구분되기는 하지만, 하나의 패키지에서 하나의 웹팩 설정으로 한번에 빌드되는 구조였음.

이로 인해 의존성 지옥과 너무 긴 빌드 타임이라는 문제점 발생.

서로 코드를 공유하지 않는 A와 B 서비스, 그리고 두 서비스가 공유하는 X라는 의존성 패키지가 존재한다고 하자. A는 이미 개발 완료되어 정상적으로 서비스되던 중 B를 개발하다보니(이미 A에서 사용하던) X 패키지에서 버그를 발견하게 된다. 이때 B의 개발을 위해 X의 버전을 올리면 A에서 에러가 발생하거나 작동이 달라지는 경우가 종종 발생한다.

![image](https://github.com/pozafly/TIL/assets/59427983/2aa9c8ac-b3a0-4dbe-8ce7-80c9d26f84dd)

또한 (앞에서 말했던 모노리스 문제점) A 서비스에서만 변경이 있다고 하더라도 변경 없는 B 부터 Z 서비스를 모두 새로 빌드해야 했으며, 사진에서와 같이 개발 도중에도 20분에서 40분간 빌드를 돌리고 멍하니 기다려야 하는 병목 현상이 두드러지기 시작함.

토스는 이를 해결하기 위해 기존 거대 소스코드를 독립적 패키지로 분리하고 각각 빌드하기로 결정했는데, repo를 분리해서 사용하자니 공통 코드의 공유 어려움, 사용 라이브러리의 파편화, 복잡한 서비스 관리 등의 문제가 발생해 결국 모노레포를 도입하게 되어있음.

<br/>

## 모노레포: 의존성 지옥의 구원자

![image](https://github.com/pozafly/TIL/assets/59427983/c682a6f8-f658-4b33-bcef-193a1712044e)

일반적으로 자주 사용했던 멀티레포 방식은 여러 repo에 패키지를 분산시켜 사용한다.

**멀티레포 장점**

- repo 별 owner지정 : 수월한 패키지 관리
- 각 repo 별 빠른 CI Build : 하나의 repo는 하나의 Continuous Integraion 구성
- 패키지의 명확한 분리로 인한 유연성 향상 : repo상 서로 연계 관계가 없기 때문에 추가, 수정, 유지 관리 편리

**멀티레포 단점**

- 중복된 설정 및 반복된 설치 : 모든 공통된 설정과 모듈들을 반복적으로 설정/설치 해야 함
- 이슈의 분산 : 각 다른 repo가 연관되어 있는 이슈 트래킹 관리 어려움.
- Dependency Hell : 여러 패키지들이 사용하는 같은 모듈에서 (의도됐든 의도되지 않았든) 버전 차이 발생 및 충돌 발생 가능
- 중복 코드의 가능성 : 중복된 설정 및 반복된 설치와 비슷하게 repo가 분리되어 공통된 코드가 중복될 가능성이 커짐

반면, 모노레포란 하나의 저장소에서 여러 플젝을 관리함..(기존의 멀티레포의 단점을 장점으로, 장점을 단점으로 가진다)

**모노레포 장점**

- 공통 항목 단일화 : eslint, Build, Unit Test 등 공통된 설정 및 필요한 node_modules를 한 번의 설치와 함 번의 설정으로 모든 패키지가 사용할 수 있음.
- 쉬운 Package 공유
- 단일 이슈 트래킹 : 모노레포 내 연관된 패키디들에 관한(분산될 필요 없는) 이슈 트래킹
- 효율적 의존성 관리

**모노레포 단점**

- repo의 거대화 : 분산되어 있던 모든 리소스를 하나의 repo로 합치면서
- 느린 CI Build : CI가 하나로 구성된다는 장점 === 규모가 커짐에 따라 분산된 CI 빌드보다 속도가 느릴 수 밖에 없음
- 무분별한 의존성 : Package간 의존성 관리가 쉽지만, 오히려 과도한 의존성 관계 발생 가능

<br/>

## 제로빌드 : 긴 빌드 시간을 줄이자

빌드 시간을 줄이기 위해 yarn berry의 zero-install이 작동하는 방식을 차용함.

yarn berry는 기존 yarn과는 다르게 의존성을 압축 파일로 관리, 숫자가 적어 Git으로 의존성을 관리함. 새로 저장소를 복제하거나 브랜치를 바꾸었다 해서 yarn install을 실행하지 않아도 되고, 이로 인해 CI/CD도 쉬워진다는 이점이 있음. [참고](https://toss.tech/article/node-modules-and-yarn-berry)

빌드 시간을 줄이기 위해 변경사항이 없는 패키지는 빌드를 하지 않도록 변경함. 모노리스 방식에서는 이런 방식을 사용하기 어려웠지만, Micro FE 아키텍쳐에서는 소스코드 변경이 있는 패키지만 새로 빌드하면 되었기 때문에 쉽게 도입 가능. 기존 빌드 결과물을 아예 Git에 저장해 언제든 pull 받으면 최신 빌드 결과를 사용할 수 있도록 함.

<br/>

## 무조건 모노레포를 사용해야 하나?

아님. 어느 정도 복잡성을 가진(각 서비스/패키지로 구별되는) 시스템에서 유용하다. 실제로 여러 개의 서비스를 나누고 관리하는 것 또한 비용이기 때문에 오히려 생산성에 방해가 될 수도 있다. 특히 플젝 초반에 실제로 사용자들에게 유용한 기능을 빠르고 정확하게 만드는 것이 종요할 때가 많고 비교적 규모가 적은 플젝에서는 서비스 간 경계를 명확하게 나누는 일이 어렵기도 함.

결론 : 소규모 플젝 내 빠른 개발을 위해서는 모노리스/멀티레포 구성이 더 수월할 수 있다.

