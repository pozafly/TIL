# HTTP VS HTTPS

> [출처1](https://velog.io/@hygoogi/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0), [출처2](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Network/HTTP%20%26%20HTTPS.md), [출처3](https://youtu.be/H6lpFRpyl14)

<br/>

## 용어 정리

- HTTP(HyperText Transfer Protocol)

  인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약

HTTP는 텍스트 교환이므로, 누군가 네트워크에서 신호를 가로채면 내용이 노출되는 보안 이슈가 존재한다. 이런 보안 문제를 해결해주는 프로토콜이 'HTTPS'

- HTTPS(HyperText Transfer Protocol Secure)

  인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약.

HTTPS는 텍스트를 암호화 한다.(공개키 암호화 방식.)

<br/>

## 대칭키 & 공개키(비대칭키)

### 대칭키(Symmectric Key)

> 암호화와 복호화에 같은 암호키(대칭키)를 사용하는 알고리즘

동일한 키를 주고 받기 때문에, 매우 빠르다는 장점이 있다. 하지만, 동일한 복호화를 사용하므로 어쨌든 한번은 이 공개키를서버에서 클라이언트로 보내주어야 한다. 이 때 탈취의 위험이 있음.

<br/>

### 공개키(Public Key)

> 암호화와 복호화에 사용하는 암호키를 분리한 알고리즘

서버에서, 자신이 가지고 있는 고유한 비밀키(개인키)로만 복호화할 수 있는 공개키를 클라이언트에게 공개함. 즉, 도중에 누가 공개키를 가로채더라도, 서버에서 가지고 있는 개인키로만 복호화할 수 있으므로 누가 탈취하더라고 안전함.

그렇다면, 해당 서버로 보낼 때, 우리가 보내고 싶은 서버인지 어떻게 아느냐?

서버에서 클라이언트에게 보내는 정보들은, 일부가 서버의 개인키로 암호화 되어있다. 클라이언트가 서버의 공개키로 풀어서 알아볼 수 있는 것은, 서버의 개인키로 암호화된 정보들 뿐이다. 다른 서버로부터 온 정보들은 원래 서버의 공개키로 풀리지 않기 때문에, 본 서버의 공개키로 열어보려 하면 오류가 남.

<br/>

### 공개키 암호화 방식 진행 과정

1. A가 웹 상에 공개된 'B의 공개키'를 이용해 평문을 암호화 하여 B에게 보냄.
2. B는 자신의 비밀키로 복호화한 평문을 확인, A의 공개키로 응답을 암호화 하여 A에게 보냄.
3. A는 자신의 비밀키로 암호화된 응답문을 복호화함.

대칭키의 단점을 완벽하게 해결했지만, 암호화 복호화가 매우 복잡함. (암호화하는 키가 복호화하는 키와 서로 다르기 때문.)

<br/>

대칭키와 공개키 암호화 방식을 적절히 혼합해보면?

> SSL 탄생의 시초가 됨

1. A가 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하고 B에게 보냄
2. B는 암호문을 받고, 자신의 비밀키로 복호화함
3. B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화하여 A에게 보냄
4. A는 자신의 대칭키로 암호문을 복호화함
5. 앞으로 이 대칭키로 암호화를 통신함

즉, 대칭키를 주고 받을 때만 공개키 암호화 방식을 사용하고 이후에는 계속 대칭키 암호화 방식으로 통신하는 것!

<br/>

## HTTPS

조금 더 알아보자. 클라이언트는 아직 서버를 신뢰하지 못한다. 서로 탐색 과정을 거치게 되는데, 이것을 `Handshake` 라고 한다. 먼저 클라이언트는 랜덤 데이터를 생성해 서버에 보낸다. 서버는 데이터를 받고, 서버측에서 생성한 무작위 데이터, 해당 서버의 인증서를 보낸다.

그럼 이제 클라이언트는 이 인증서가 진짜인지 브라우저에 내장된 CA(Certification Authority)들의 정보를 통해 확인하게 된다. 공개키(비대칭키) 시스템을 사용해서. CA의 인증을 받은 인증서는 CA의 개인키로 암호화가 되어 있다. 이 인증서가 진짜라면, CA의 공개키로 복호화 할 수 있다. 공개키로 복호화될 수 있는 인증서를 발급할 수 있는 건 그에 대응하는 개인키를 가진 CA 뿐이다.

이제 성공적으로 복호화 된 인증서에는, 서버의 공개키가 포함되어 있다. 그러면, 이제 서버의 공개키로 메세지들을 암호화해서 **비대칭키 방식**으로 주고 받느냐? 아니다. 대칭키, 비대칭키 둘을 `혼합` 해서 사용한다.

비대칭키로 주고 받는 전체 데이터를 암호화 복호화하는 방식은 컴퓨터에 큰 부담을 주기 때문. 따라서 주고 받을 데이터는 대칭키로 암호화 한다. 그리고, 대칭키를 공유할 때, 그 키만 비대칭키를 사용한다.

처음 Handshke가 일어났을 때 생성된 랜덤 데이터를 클라이언트는 이 둘을 혼합해서 임시 키를 만든다. 그 임시 키는 서버의 공개키로 암호화 되어 서버로 보내진다. 양쪽에서 일련의 과정을 거쳐 동일한 대칭키가 만들어지는 것.

<br/>

## SSL의 원리

SSL의 원리를 간략하게 설명하면, 대칭키와 공개키 방식 두 암호화 방식 모두를 사용하는데, 먼저 클라이언트가 서버에게 HELLO 메세지를 보내면, 서버가 클라이언트에게 HELLO 메세지를 보내면서, 서버 암호화 된 인증서와 랜덤 데이터를 넘겨주게 된다.

HELLO 과정에서 어떤 암호화 프로토콜을 사용할 것인지 협상한다. 클라이언트는 받은 인증서를 CA 리스트에서 조회 후 CA 공개키를 사용해 인증서를 복호화 한다. 복호화에 성공하면 이 서버는 신뢰할 수 있는 서버이다.

서버가 보낸 랜덤 데이터와 클라이언트의 랜덤 데이터를 조합해 대칭키를 생성한다. 서버로부터 받은 공개키(인증서)를 사용하여 대칭키를 암호화 후, 서버에게 보내게 된다. 서버는 암호화된 대칭키를 받고, 비밀키로 복호화 함으로 서버와 클라이언트가 서로 대칭키를 가지게 된다. 이 대칭키로 통신을 암호화 함.
