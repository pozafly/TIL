# 페이징 - 게시글 개수

<img width="701" alt="Image" src="https://github.com/user-attachments/assets/c15bab49-c555-4f75-836e-79df8ee4ab78" />
- 게시글의 개수는,
	- 데이터 유무에 따라서 몇 페이지까지 활성화할지 결정하기 위해 필요하다.
- 페이지 당 30개의 게시글을, 페이지 이동 버튼을 10개씩 노출한다면,
	- 게시글 50개 있다면, 2번 페이지까지 활성화
	- 게시글 301개 이상 있다면, 다음 버튼까지 활성화(11페이지가 있음을 의미)

 데이터베이스에서 데이터의 카운트 조회 방법은 간단하다.
- count 쿼리를 이용할 수 있다.

`select count(*) from article where board_id = 1;`

<img width="213" alt="Image" src="https://github.com/user-attachments/assets/decbd1f5-05c8-4127-94e4-94e360a43830" />

idx_board_id_article_id 인덱스를 사용하고, 개수만 카운트하면 되므로 커버링 인덱스로 동작했다.
하지만 게시판의 모든 게시글 수를 확인해야하므로, 실행 시간은 약 1.3초나 소요되었다.

그런데 이러한 사용처에서 모든 게시글의 개수가 필요할지는 의문
- 우리는 전체 게시글 수가 필요한 것이 아니다.
- 이동 가능한 페이지 번호 활성화에 필요한 것이다.
페이지 당 30개의 게시글이 노출되고, 10 페이지씩 이동 가능한 상황에서 사용자에게 노출되는 화면을 살펴보자.

<img width="1190" alt="Image" src="https://github.com/user-attachments/assets/b410985b-608d-4ad5-a8cb-698fb371c3ca" />

사용자가 1~10번 페이지에 있을 때에는, 301개의 게시글 유무만 알면 된다. 301개면 다음 버튼까지 활성화, 301개 미만이면 개수만큼 페이지 버튼 활성화.

- 공식 = `(((n–1) / k) + 1) * m * k + 1`
	- 현재 페이지(n)
		- n > 0
	- 페이지 당 게시글 개수(m)
	- 이동 가능한 페이지 개수(k)
	- ((n - 1) / k)의 나머지는 버림
- n=7, m=30, k=10
	- (((7 - 1) / 10) + 1) * 30 * 10 + 1 = 301
- n=12, m=30, k=10
	- (((12 - 1) / 10) + 1) * 30 * 10 + 1 = 601

count 쿼리를 일부만 조회하도록 다시 만들어보자!

```sql
select count(*)  
from (select article_id  
      from article  
      where board_id = 1  
      limit 300301) t;
```

- count query에서 limit은 동작하지 않고 전체 개수를 반환하므로,
- sub query에서 Covering Index로 limit 만큼 조회하고 count하는 방식
`0.07s` 소요됨.

- 물론, 게시글 개수를 조회 시점에 실시간으로 쿼리할 필요는 없다.
- 게시글 개수를 하나의 데이터로 미리 만들어둘 수도 있다.
	- 게시글 생성/삭제 시점마다 게시글 개수를 업데이트하는 방식
- 하지만 이를 위해,
	- 동시 요청이 발생하는 상황에서 안전하고 정확하게 처리하기 위한 방법 필요
		- 게시글이 100개 작성되었는데, 카운트는 98개로 저장?
