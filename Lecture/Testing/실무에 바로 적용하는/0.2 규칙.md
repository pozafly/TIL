# 규칙

## 1. 인터페이스를 기준으로 테스트를 작성하자

※ 인터페이스: 서로 다른 클래스 또는 모듈이 상호작용하는 시스템.

내부 구현에 대한 테스트는 캡슐화를 위반하며, 깨지기 쉬운 테스트다.

```js
// 💩
it('isShowModal 상태를 true로 변경했을 때 ModalComponent의 display 스타일이 block이며, "안녕하세요!" 텍스트가 노출된다.', () => {
  // 구현에 종속적인 코드와 복잡한 상태 변경 코드들이 발생할 수 있다.
  SpecificComponent.setState({ isShowModal: true });
});
```

react의 경우, 내부 state를 직접 변경하는 것이 아니라, 외부 인터페이스를 통해 변경되는지를 검증하는게 좋은 테스트다.

1. 변경되는 상태가 많은 경우, 테스트 코드 상에서 일일이 직접 변경해야 하며 어떤 상황에서 변경되는 것인지 드러내지 않음.
2. 내부 상태나 변수 값을 기준으로 검증하다 보니 어떤 것을 검증하는지 테스트 코드만 보고 한 눈에 파악하기 어려움.
3. 내부 구현을 검증하려다 보니 구현에 종속적인 테스트 코드가 양산된다. 상태나 변수 명이 하나라도 바뀌면 테스트 코드 모두를 바꿔야 함. 즉, 캡슐화를 위반하는 코드가 된다.

그렇다면, 컴포넌트에서 상태를 변경시킬 수 있는 인터페이스는? -> DOM event Handler다.

```js
// 😄
it('버튼을 누르면 모달을 띄운다.', () => {
  // 유저의 동작과 비슷하도록 클릭 이벤트를 발생
  user.click(screen.getByRole('button'));
  
  // ...
});
```

- 재부 구현과 종속성이 없으며 캡슐화에 위반되지 않음.
- 어떤 행위를 하는지 명확해짐.
- 테스트를 설명하기 위한 불필요한 주석이나 설명 또한 없음.

<br/>

## 2. 커버리지 보다는 의미있는 테스트인지 고민하자

실수 중 하나는 테스트 커버리지를 100% 검증하려는 것이다.

※ 커버리지: 테스트 코드가 프로덕션 코드의 몇 %를 검증하고 있는지 나타낸 지표. 구문(statements), 분기(branches), 함수(Functions), 줄(Lines) 등을 기준으로 함.

- 테스트 작성, 실행, 유지보수 측면에서 너무 많은 비용이 발생
- 100% 커버리지로 테스트를 작성했어도 잘못된 검증 때문에 문제가 발생할 수 있음.

<img width="1173" alt="image" src="https://github.com/pozafly/TIL/assets/59427983/166b7932-c593-4ec1-a28b-19c17ad94be7">

```jsx
export default function List ({ items = [] }) {
  return (
  	<ul>
    	{items.map((data) => {
        return (
        	<li key={data}>{data}</li>
        );
      })}
    </ul>
  );
}
```

위와 같은 단순한 UI 렌더링 컴포넌트를 테스트할 필요가 있을까? 아니다.

```js
export const isNumber = (value) => typeof value === 'number';
export const isString = (value) => typeof value === 'string';
```

위와 같은 유틸 함수도 마찬가지다. 검증할 필요가 없다. 너무 간단하기 때문임.

즉, 커버리지만을 위한 검증은 의미없는 테스트가 될 가능성이 높다.

<br/>

## 3. 테스트 코드도 유지 보수의 대상! 가독성을 높이자

1. 테스트 하고자 하는 내용을 명확하게 적자.

검증 기능: **리스트에서 체크된 항목들을 삭제**

```js
// 💩
it('리스트에서 항목이 제대로 삭제된다.', () => {});

// 😄
it('항목들을 체크한 후 삭제 버튼을 누르면 리스트에서 체크된 항목들이 삭제된다.', () => {});
```

1. 하나의 테스트에서는 가급적 하나의 동작만 검증하자.

단일 책임 원칙(`SRP`, Single Responsibility Principle): 모든 클래스는 하나의 책임을 갖고 그와 관련된 책임을 캡슐화하여 변경에 견고한 코드를 만들어야 한다.

```js
// 💩
it('장바구니에 담긴 상품들이 정상적으로 노출되고, 수량을 변경하면 가격이 재계산된다. 그리고 삭제 버튼을 누르면 상품이 삭제된다.', () => {});

// 😄
it('장바구니에 담긴 상품들을 정상적으로 렌더링 한다.', () => {});
it('장바구니에 담긴 상품의 수량을 수정하면 가격이 재계산된다.', () => {});
it('장바구니에 담긴 항목의 삭제 버튼을 누르면 리스트에서 삭제된다.', () => {});
```
