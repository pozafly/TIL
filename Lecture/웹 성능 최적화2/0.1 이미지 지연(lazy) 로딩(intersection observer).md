# 이미지 지연(lazy) 로딩(intersection observer)

![[assets/images/ead6e8aad81c8e75bbcd6770a3f60fb6_MD5.png]]

네트워크 탭에서 슬로우를 걸어보자.

Fast 3G, Slow 3G는 너무 느려서 2000단위로 커스텀 세팅해 사용하는 것을 추천한다.

- 4000
- 6000
- 8000

![[assets/images/25838a1b7779bba4589fd2828e6f93bb_MD5.png]]

보통은 `6000` 으로 사용하도록 하자.

![[assets/images/0fd89009625036d5f0e1696fa91f982b_MD5.png]]

이렇게 느리게 불러오는 것을 볼 수 있다.

![[assets/images/5e487432c6731dcb552990face2a2e79_MD5.png]]

사진에 보면, 이미지는 불러오고 있지만, 비디오는 pending 되어 있는 것을 볼 수있음. 가장 먼저 보여야할 비디오이다.

크게 2가지를 생각해볼 수 있다.

- 이미지 빠르게 다운로드 하는 방법
  - 이미지를 빠르게 하면, 동영상이 이어 다운로드 되니 동영상도 비교적 빠르게 보일 것이다.
- 이미지는 나중에 보이니까 나중에 다운로드 받고, 동영상을 먼저 다운로드 받는 방법.

첫번째 방법은 좋지 않음. 두번째 방법이 좋은 방법이다.

---

그럼 언제 이미지를 다운로드 시작해야 할까? 스크롤을 내리기 시작하면, 그 직전에 다운로드를 시작하면 된다.

![[assets/images/96ace4830ef0e512acda0737d8b36b3f_MD5.png]]

하지만, 이 방식에는 단점이 있다. 스크롤 할 때마다 이벤트에 걸린 함수가 실행된다는 점임. 그럼, `intersection observer` 를 사용하면 된다. 이벤트 핸들러보다 성능적으로 훨씬 뛰어나다.
```jsx
function Card(props) {
  const imgRef = useRef(null);

  useEffect(() => {
    const options = {};
    const callback = (entries, observer) => {
      entries.forEach((entry) => {
        // 화면에 보이는 DOM 요소가 감지 된다면
        if (entry.isIntersecting) {
          console.log('is intersecting');
        }
      });
    };

    const observer = new IntersectionObserver(callback, options);
    observer.observe(imgRef.current);
  }, []);

  return (
    <div className="Card text-center">
      <img src={props.image} ref={imgRef} />
      <div className="p-5 font-semibold text-gray-700 text-xl md:text-lg lg:text-xl keep-all">
        {props.children}
      </div>
    </div>
  );
}
```
원랜 return 문 밖에 없었지만, ref와 intersection observer 코드를 넣어준 모습이다.

`if (entry.isIntersecting)` 은, DOM이 스크롤해서 감지 되면 아래를 실행하라는 뜻이다. 하지만, 이제 어떻게 이미지를 lazy 로딩할 수 있을까? lazy 로딩을 하려면, `data-src` 옵션을 사용할 수 있다.
```jsx
<img ref={imgRef} src={props.image} />
<img ref={imgRef} data-src={props.image} />
```
src를 `data-src` 옵션으로 바꾸어준다. 그러면 img 태그는 어떤 이미지도 로드하지 않게 된다. 그리고 intersection observer에서 src로 넣어주면 된다.
```javascript
if (entry.isIntersecting) {
  entry.target.src = entry.target.dataset.src;
}
```
이렇게 하면 레이지 로딩이 적용되었다. 하지만, observer가 살아 있기 때문에 이미지가 화면에 벗어난 후, 다시 뷰포트에 들어오게 되면 다시 callback을 실행하게 되는데 이 때 `unobserve` 를 해주어야만 함수가 재실행되지 않는다.
```javascript
if (entry.isIntersecting) {
  entry.target.src = entry.target.dataset.src;
  observer.unobserve(entry.target); // 한번 로드 했으니 unobserve로 옵저버를 제거함.
}
```