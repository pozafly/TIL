# 엔티티 개발

> - 예제에서는 설명 때문에 Getter, Setter 모두 열고 단순 설계.
> - 하지만, 실무에서는 Getter는 열고 Setter는 필요한 부분만 넣기.

> 📌 이론적으로는 Getter, Setter 모두 제공하지 않고 꼭 필요한 별도 메서드를 제공하는게 가장 이상적.
> 하지만 실무에서 엔티티 데이터는 조회할 일이 너무 많으므로 Getter의 경우 열어두는 것이 편리. Getter는 아무리 호출햏도 호출 만으로 사이드 이펙트 발생 X. 하지만 Setter를 호출하면 데이터가 변경됨. Setter를 막 열어두면 미래에 엔티티가 도대체 왜 변경되는지 추적하기 어려워짐. 엔티티를 변경할 때는 Setter 대신 변경 지점이 명확하도록 변경을 위한 비즈니스 메서드를 별도로 제공해야 함.

## ID

엔티티의 식별자는 `id` 를 사용하고 PK 컬럼명은 `member_id` 를 사용함. 엔티티는 타입(여기서는 `Member`) 이 있으므로 `id` 필드만 쉽게 구분할 수 있다. 테이블은 타입이 없으므로 구분이 어렵다. 그리고 테이블은 관례상 `테이블명 + id` 를 많이 사용함. 참고로 객체에서 `id` 대신 `memberId` 를 사용해도 된다. 중요한 것은 일관성.

## @ManyToMany

실무에서는 `@ManyToMany` 사용하지말자. 편리할 것 같지만 중간 테이블(`CATEGORY_ITEM`)에 칼럼을 추가할 수 없고, 세밀하게 퀴리를 실행하기 어렵기 때문에 실무에서 사용하기에는 한계가 있음. 중간 엔티티(`CategoryItem`)를 만들고 `@ManyToOne`, `@OneToMany` 로 매핑해 사용하자. 정리하면 다대다 매핑을 일대다, 다대일 매핑으로 풀어내자.

## 값 타입

```java
@Embeddable  
@Getter  
public class Address {  
  
    private String city;  
    private String street;  
    private String zipcode;  
  
    protected Address() {  
    }  
  
    public Address(String city, String street, String zipcode) {  
        this.city = city;  
        this.street = street;  
        this.zipcode = zipcode;  
    }  
}
```

값 타입은 변경 불가능하게 해야 함. `@Setter` 제거하고 생성자에서 값을 모두 초기화해 변경 불가능한 클래스를 만들자. JPA 스팩 상 엔티티나 임베디드 타입(`@Embeddeable`)은 자바 기본 생성자(default constructor) 를 `public` 또는 `protected`로 설정해야 함. `public`으로 두는 것보다는 `protected`로 설정하는 것이 그나마 더 안전 함.
JPA가 이런 제약을 두는 이유는 JPA 구현 라이브러리가 객체를 생성할 때 리플렉션 같은 기술을 사용할 수 있도록 지원해야 하기 때문임.
