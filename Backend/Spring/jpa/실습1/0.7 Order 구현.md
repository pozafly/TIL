# Order 구현

```java
@Entity
public class Order {  
    //...
    
    //==생성 메서드==//  
    public static Order createOrder(Member member, Delivery delivery, OrderItem… orderItems) {  
        Order order = new Order();  
        order.setMember(member);  
        order.setDelivery(delivery);  
  
        for (OrderItem orderItem : orderItems) {  
            order.addOrderItem(orderItem);  
        }  
        order.setStatus(OrderStatus.ORDER);  
        order.setOrderDate(LocalDateTime.now());  
        return order;  
    }
}
```

이렇게 생성 메서드를 `Entity` 에 넣어준다.
이유는, 엔티티를 여러 곳에서 생성할 텐데, 그 때마다 위 코드를 직접 쳐야하고 만약 Order 생성 로직이 변경되었을 때 여기만 변경해주면 되기 때문이다.

```java
//==비즈니스 로직==//  
/**  
 * 주문 취소  
 */  
public void cancel() {  
    if (delivery.getStatus() == DeliveryStatus.COMP) {  
        throw new IllegalStateException("이미 배송완료된 상품은 취소가 불가능합니다.");  
    }  
  
    this.setStatus(OrderStatus.CANCEL);  
    for (OrderItem orderItem : orderItems) {  
        orderItem.cancel();  
    }  
}  
  
//==조회 로직==//   
/**  
 * 전체 주문 가격 조회  
 */  
public int getTotalPrice() {  
    int totalPrice = 0;  
    for (OrderItem orderItem : orderItems) {  
        totalPrice += orderItem.getTotalPrice();  
    }  
    return totalPrice;  
}
```

이렇게 비즈니스 로직도 해당 Entity에 필요한 녀석들을 넣어준다.
이렇게 원개 서비스 단에 넣어주었던 Entity에 반드시 필요한 녀석들을 Entity에 넣어두면 service에서 반복적으로 사용했던 코드를 더 깔끔하게 유지시켜줄 수 있다.
또한, 반복 제거 뿐 아니라, Entity의 응집도도 높아지는 것을 볼 수 있음.
