# 즉시 로딩과 지연 로딩

## 지연 로딩 LAZY를 사용해 프록시로 조회

```java
@Entity
public class Member {
	@Id
	@GeneratedValue
	private Long id;
	
	@Column(name = "USERNAME")
	private String name;
	
	@ManyToOne(fetch = FetchType.LAZY) //**
	@JoinColumn(name = "TEAM_ID")
	private Team team;
}
```

쿼리문은 `team.getName()` 으로 직접 사용할 때 나감.
<img width="926" alt="Image" src="https://github.com/user-attachments/assets/33bd239e-f2ec-4745-914b-e60e0293a9dc" />

### 즉시 로딩 EAGER를 사용해 함께 조회

```java
@Entity
public class Member {
	@Id
	@GeneratedValue
	private Long id;
	
	@Column(name = "USERNAME")
	private String name;
	
	@ManyToOne(fetch = FetchType.EAGER) //**
	@JoinColumn(name = "TEAM_ID")
	private Team team;
}
```

애초에 Member를 조회할 때부터 team을 가져오기 위해 쿼리가 먼저 나감. 이 때는 `left outer join` 으로 두 개의 것을 한 번에 조회함.
이 때는 프록시를 사용하지 않음.

<img width="785" alt="Image" src="https://github.com/user-attachments/assets/c8a5ba11-a9d9-4994-bc52-2b44e3808d89" />

## 📌 프록시와 즉시로딩 주의

- **가급적 지연 로딩만 사용(특히 실무에서)**
- 즉시 로딩을 적용하면 예상치 못한 SQL 발생
- **즉시 로딩은 JPQL에서 N + 1 문제를 일으킴**
- `@ManyToOne`, `@OneToOne` 은 기본이 즉시 로딩
	- **-> LAZY로 설정**
- @OneToMany, @ManyToMany는 기본이 지연 로딩
