# 프로토타입 스코프

싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환.
반면 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 반환함.

## 싱글톤 빈 요청

![[assets/images/f00b7c50f4858dc325d7c46cfdc9407d_MD5.png]]
1. 싱글톤 스코프의 빈을 스프링 컨테이너에 요청
2. 스프링 컨테이너는 관리하는 스프링 빈을 반환
3. 이후 스프링 컨테이너에 같은 요청이 와도 같은 객체 인스턴스의 스프링 빈을 반환

## 프로토타입 빈 요청1

![[assets/images/dc41d80320632f753697374c27260ce9_MD5.png]]
1. 프로토타입 스코프의 빈을 스프링 컨테이너에 요청
2. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성, 필요한 의존 관계를 주입

## 프로토타입 빈 요청2

![[assets/images/e98fe72de0032760d0171b16cce3cdf7_MD5.png]]
3. 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환
4. 이후 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환

## 정리

**핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것.** 클라이언트에 빈은 반환하고, 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않음. 프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있다. 그래서 `@PreDestory` 같은 종료 메서드가 호출되지 않음.

## 코드

### singleton
```java {11}
public class SingletonTest {  
  
    @Test  
    void singletonBeanFind() {  
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SingletonBean.class);  
        SingletonBean singletonBean1 = ac.getBean(SingletonBean.class);  
        SingletonBean singletonBean2 = ac.getBean(SingletonBean.class);  
  
        System.out.println("singletonBean1 = " + singletonBean1);  
        System.out.println("singletonBean2 = " + singletonBean2);  
        assertThat(singletonBean1).isSameAs(singletonBean2);  
  
        ac.close();  
    }  
  
    @Scope("singleton")  
    static class SingletonBean {  
        @PostConstruct  
        public void init() {  
            System.out.println("SingletonBean init");  
        }  
  
        @PreDestroy  
        public void destroy() {  
            System.out.println("SingletonBean destroy");  
        }  
    }  
}
```
== 비교. 즉, 동일함.

### prototype
```java {14}
public class PrototypeTest {  
  
    @Test  
    void prototypeBeanFind() {  
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(PrototypeBean.class);  
        System.out.println("find prototypeBean1");  
        PrototypeBean prototypeBean1 = ac.getBean(PrototypeBean.class);  
        System.out.println("find prototypeBean2");  
        PrototypeBean prototypeBean2 = ac.getBean(PrototypeBean.class);  
  
        System.out.println("prototypeBean1 = " + prototypeBean1);  
        System.out.println("prototypeBean2 = " + prototypeBean2);  
  
        assertThat(prototypeBean1).isNotSameAs(prototypeBean2);  
  
        ac.close();  
    }  
  
    @Scope("prototype")  
    static class PrototypeBean {  
        @PostConstruct  
        public void init() {  
            System.out.println("PrototypeBean init");  
        }  
  
        @PreDestroy  
        public void destroy() {  
            System.out.println("PrototypeBean destroy");  
        }  
    }  
}
``````
find prototypeBean1
PrototypeBean init
find prototypeBean2
PrototypeBean init
prototypeBean1 = hello.core.scope.PrototypeTest$PrototypeBean@13d4992d
prototypeBean2 = hello.core.scope.PrototypeTest$PrototypeBean@302f7971
org.springframework.context.annotation.AnnotationConfigApplicationContext - Closing
```
근데 웃긴건 `destory` 가 로그에 찍히지 않았음.
- 싱글톤 빈은 스프링 컨테이너 생성 시점에 초기화 메서드가 실행되지만, 프로토타입 스코프의 빈은 스프링 컨테이너에서 빈을 조회할 때 생성되고, 초기화 메서드도 실행됨.
- 프로토타입 빈을 2번조회했으므로 완전히 다른 스프링 빈이 생성, 초기화도 2번.
- 싱글톤 빈은 스프링 컨테이너가 관리하기 때문에 스프링 컨테이너가 종료될 때 빈의 종료 메서드가 실행되지만, 프로토타입 빈은 스프링 컨테이너가 생성과 의존관계 주입 그리고 초기화 까지만 관여하고, 더는 관리하지 않는다. 따라서 프로토타입 빈은 **스프링 컨테이너가 종료될 때 `@PreDestory` 같은 종료 메서드가 전혀 실행되지 않음**.

## 정리

- 스프링 컨테이너에 요청할 때 마다 새로 생성된다.
- 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다.
- 종료 메서드가 호출되지 않는다.
- 그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다. 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.
