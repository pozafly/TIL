# 제약 조건 활용

예제를 실행하기 전에 먼저 기존 테이블을 초기화.

```sql
SET FOREIGN_KEY_CHECKS = 0; -- 비활성화
truncate table products;
truncate table customers;
truncate table orders;
SET FOREIGN_KEY_CHECKS = 1; -- 활성화
```

## 1. NOT NULL 제약 조건 위반: "필수 항목을 입력해주세요."

`NULL` 은 값이 없다는 뜻이다. `NOT NULL` 은 '`NULL` 을 허용하지 않는다'는 뜻으로, 필수 입력 항목을 지정할 때 사용한
다.

```sql
-- `name` 열을 빼고 INSERT를 시도한다.
INSERT INTO customers (email, password, address)
VALUES ('noname@example.com', 'password123', '서울시 마포구');
```

```
Error Code: 1364. Field 'name' doesn't have a default value
```

데이터베이스는 "`name` 필드에 기본값이 없다"라는 오류를 반환하며 INSERT를 거부.
`name` 열은 `NOT NULL` 인데 값을 주지 않았고, `DEFAULT` 로 지정된 값도 없으므로 어떤 데이터를 넣어야 할지 알 수 없기 때문이다. 이처럼 `NOT NULL` 제약 조건은 데이터의 완전성을 보장하는 첫 번째 방어선이다.

## 2. UNIQUE 제약 조건 위반: "이미 사용 중인 이메일입니다."

가장 흔하게 마주치는 제약 조건 오류 중 하나는 `UNIQUE` 키 위반이다.

```sql
INSERT INTO customers (name, email, password, address)
VALUES ('강감찬', 'kang@example.com', 'new_password_789', '서울시 강남구');

-- 'kang@example.com'은 이미 '강감찬' 고객이 사용 중인 이메일이다.
INSERT INTO customers (name, email, password, address)
VALUES ('홍길동', 'kang@example.com', 'new_password_123', '서울시 송파구');
```

```
Error Code: 1062. Duplicate entry 'kang@example.com' for key 'customers.email'
```

홍길동 회원을 저장할 때 데이터베이스는 "`customers.email` 키에 중복된 값 `kang@example.com` 이 있습니다"라는 명확한 오류 메시지를 반환하며 `INSERT` 요청을 거부.
이처럼 `UNIQUE` 제약 조건은 데이터의 고유성을 보장하는 중요한 역할을 한다.

## 3. 외래 키(FK) 제약 조건: 관계의 무결성 지키기

`orders` 테이블은 `customers` 테이블과 `products` 테이블에 의존하는 '자식 테이블'이다. 즉, `orders` 테이블에 데이터를 추가하려면, 그 주문을 한
고객(`customer_id`)과 주문된 상품(`product_id`)이 반드시 `customers` 와 `products` 테이블에 실제로 존재 해야 한다.

**먼저, 정상적인 주문 데이터를 입력해 보자.**
`customers` 테이블에 `customer_id` 가 1인 고객이 있고, `products` 테이블에 `product_id` 가 1인 '베이직 반팔 티셔츠'가 있다고 가정하자.

```sql
INSERT INTO products (name, price, stock_quantity)
VALUES ('베이직 반팔 티셔츠', 19900, 200);
```

만약 실패한다면 `customers` 테이블에 `customer_id` 가 없거나, `products` 테이블에 `product_id` 가 존재하지 않을 것이다.

## 4. 외래 키(FK) 제약 조건 위반: "존재하지 않는 고객의 주문입니다."

이번에는 **존재하지 않는 고객**의 주문을 넣어보자. `customers` 테이블에는 `customer_id` 가 999인 고객이 없다.

```sql
-- 존재하지 않는 999번 고객이 1번 상품을 1개 주문하려고 시도한다.
INSERT INTO orders (customer_id, product_id, quantity)
VALUES (999, 1, 1);
```

```
Error Code: 1452. Cannot add or update a child row: a foreign key constraint
fails (`my_shop`.`orders`, CONSTRAINT `fk_orders_customers` FOREIGN KEY
(`customer_id`) REFERENCES `customers` (`customer_id`))
```

데이터베이스는 "자식 행을 추가하거나 업데이트할 수 없습니다: `fk_orders_customers` 외래 키 제약 조건이 실패 했습니다"라는 오류를 뱉어낸다.

이 메시지는 `orders` 테이블에 `INSERT` 하려던 값 `999` 가 부모 테이블인 `customers` 의 `customer_id` 에 존재하지 않아서 외래 키 제약조건을 위반했다는 뜻이다.

이처럼 외래 키 제약 조건은 **데이터의 정합성**과 **무결성**을 지키는 핵심 장치다.

> 외래 키 제약조건을 포함한 제약조건들은 INSERT 뿐만 아니라 UPDATE, DELETE 등 모든 상황의 데이터 불일치를 원천 방지한다.
