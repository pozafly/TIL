# GROUP BY

"어떤 상품 카테고리가 가장 인기가 많을까? **카테고리별 주문 건수**를 알려줘, 그리고 **카테고리별로 매출액이 얼마나 되는지** 알려줘."
"전체 실적은 알겠는데, **어떤 고객이 우리 쇼핑몰의 진짜 VIP지?** 즉, 고객별로 총 얼마를 썼고 몇 개의 상품을 구매했는지 순서대로 보고 싶어."

이런 질문들은 `SUM()` 이나 `COUNT()` 같은 집계 함수만으로는 해결할 수 없다. 왜냐하면 '전체'가 아닌 **'상품 카테고리별로'**, **'고객 별로'** 묶어서 집계해야 하기 때문.

## 그룹화의 첫걸음: `GROUP BY` 기본

`GROUP BY` 는 이름 그대로, 특정 컬럼의 값이 같은 행들을 하나의 그룹으로 묶어주는 역할.

- **개념 설명**: `GROUP BY` 절에 그룹화의 기준이 될 컬럼을 지정. 이렇게 그룹화된 결과에 집계 함수를 적용하면, 전체에 대한 통계가 아닌 '각 그룹에 대한 통계'를 낼 수 있음.

```sql

SELECT
	category,
	COUNT(*) AS `카테고리별 주문 건수`
FROM
	order_stat
GROUP BY
	category;
```

<img width="406" height="165" alt="Image" src="https://github.com/user-attachments/assets/87feb787-740b-40e7-bc6d-961fef433851" />
주목할 점은 `category` 가 `NULL` 인 데이터도 하나의 그룹으로 묶여서 결과에 포함되었다는 것이다. `GROUP BY` 는 `NULL` 값 또한 하나의 독립된 그룹으로 취급하여 집계.

예제: 고객별로 총 몇 번이나 주문했을까?

```sql
SELECT
	customer_name,
	COUNT(*) AS `주문 횟수`
FROM
	order_stat
GROUP BY
	customer_name;
```

## **그룹별로** **심층** **분석하기**: `GROUP BY` **와** **집계** **함수**

고객별로 총 주문 횟수, 총 구매 수량, 그리고 총 구매 금액을 함께 계산해 보자. 이를 통해 어떤 고객이 우리 쇼핑몰의 진정한 VIP인지 찾아낼 수 있다.

```sql
SELECT
	customer_name,
	COUNT(*) AS `총 주문 횟수`,
	SUM(quantity) AS `총 구매 수량`,
	SUM(price * quantity) AS `총 구매 금액`
FROM
	order_stat
GROUP BY
	customer_name
ORDER BY
	`총 구매 금액` DESC; -- 백틱 사용 주의!
```

<img width="888" height="171" alt="Image" src="https://github.com/user-attachments/assets/991aaafa-2720-499f-a21f-fba8eead689f" />

## 더 세분화된 그룹으로 분석하기: 여러 컬럼 기준 그룹화

"고객별 분석은 알겠는데, 그럼 **어떤 고객이 어떤 카테고리의 상품을** 주로 구매 하는지 보고 싶다."

```sql
SELECT
	customer_name,
	category,
	SUM(price * quantity) AS `카테고리별 구매 금액`
FROM
	order_stat
GROUP BY
	customer_name, category
ORDER BY
	customer_name, `카테고리별 구매 금액` DESC;
```

<img width="710" height="303" alt="Image" src="https://github.com/user-attachments/assets/d802cae3-78b5-4f10-a8b4-d147e4ed7bcf" />

## GROUP BY - **주의사항**

`GROUP BY` 를 사용할 때 `SELECT` 절에는 ** `GROUP BY` 에 사용된 **컬럼**과 **집계 함수**만 사용할 수 있다.

데이터를 어떤 기준으로 그룹화했는데, 그 그룹에 속한 개별 데이터 중 하나를 불쑥 달라고 하면 데이터베이스는 어떤 것을 줘야 할까? 그룹에는 여러 데이터가 섞여 있으니, 그중 하나의 값을 특정할 수 없기 때문.
