# 데이터 타입

## 숫자 타입

### 정확한 숫자 타입 (Exact Value Numeric Types)

소수점 이하까지 정확한 값을 저장해야 할 때 사용된다. 주로 정수나 고정 소수점 숫자를 다룰 때 유용하다.

| 타입                   | 저장 공간 (Bytes) | 설명                                                                                                                 |
| -------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------ |
| `INTEGER`, `INT`     | 4             | 가장 일반적으로 사용되는 정수 타입 (-2,147,483,648 ~ 2,147,483,647)                                                               |
| `TINYINT`            | 1             | 매우 작은 정수를 저장할 때 사용 (-128 ~ 127)                                                                                    |
| `SMALLINT`           | 2             | 작은 정수를 저장할 때 사용 (-32,768 ~ 32,767)                                                                                 |
| `MEDIUMINT`          | 3             | 중간 크기의 정수를 저장할 때 사용 (-8,388,608 ~ 8,388,607)                                                                       |
| `BIGINT`             | 8             | 매우 큰 정수를 저장할 때 사용<br>(-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)                                      |
| `DECIMAL`, `NUMERIC` | 가변            | 고정 소수점 숫자를 정확하게 저장할 때 사용.  금융 데이터와 같이 정확한 계산이 필요할 때 사용. <br>`DECIMAL(M, D)` 형태로 사용하며, M은 총 자릿수, D는 소수점 이하 자릿수를 의미. |
| `BIT`                | 가변            | 하나 이상의 비트 값을 저장. `BIT(M)` 형태로 사용하며, M은 1에서 64까지의 비트 수를 지정.                                                         |
| `FLOAT`              | 4             | 단정밀도 부동 소수점 숫자. 정밀도가 아주 중요하지 않은 실수 값에 사용된다.                                                                        |
| `DOUBLE`             | 8             | 배정밀도 부동 소수점 숫자. `FLOAT` 보다 더 큰 범위와 높은 정밀도를 가진다. <br>과학 계산이나 공학 데이터에 주로 사용된다.                                       |

**참고:** `UNSIGNED` 속성을 추가하면, 각 정수 타입은 0부터 시작하여 양수 범위만 저장하게 되며 저장할 수 있는 양수 값
의 범위가 두 배로 늘어난다. 예를 들어 `UNSIGNED INT` 는 0부터 4,294,967,295까지 저장할 수 있다.

**근사치 숫자 타입 (Approximate Value Numeric Types)**
이 타입들은 부동 소수점 숫자를 저장하며, 매우 크거나 매우 작은 숫자를 표현할 수 있지만 약간의 오차가 발생할 수 있다.

## 문자열 타입

`VARCHAR(n)`: 최대 `n` 글자까지 저장되는 **가변 길이** 문자열.
- 이름, 주소처럼 길이가 제각각인 데이터에 사용하면 저장 공간을 효율적으로 쓸 수 있다.
- '홍길동'(3글자)을 `VARCHAR(10)` 에 저장하면 실제 데이터 길이인 3글자만큼의 공간만 차지한다.
- '김네이트'(4글자)을 `VARCHAR(10)` 에 저장하면 실제 데이터 길이인 4글자만큼의 공간만 차지한다.

`CHAR(n)`: 항상 `n` 글자 길이를 차지하는 **고정 길이** 문자열.
- '남' (1글자)을 `CHAR(2)` 에 저장하면, 나머지 1글자는 공백으로 채워져 무조건 2글자의 공간을 차지한다.
- 성별 코드('M'/'F')나 우편번호, 국가 코드('KR'/'US')처럼 **항상 길이가 정해져 있는 데이터**에 사용하면,
- `VARCHAR` 보다 아주 약간의 이점을 가질 수 있다. 길이가 항상 같으니, 데이터를 찾기 위해 길이를 확인할 필요가 없기 때문이다.

`TEXT`: 매우 긴 텍스트를 저장할 때 사용한다.
- `TEXT` 는 주로 상품의 상세 설명, 장문의 리뷰, 블로그 게시글 본문처럼 긴 글 작성에 적합하다.
- 자주 사용하지는 않지만 더 긴 텍스트를 보관할 수 있는 `MEDIUMTEXT`, `LONGTEXT` 등도 있다.

**VARCHAR vs CHAR 핵심 차이점**

| 구분     | VARCHAR (Variable Character)                                                       | CHAR (Character)                                                               |
| ------ | ---------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| 저장 공간  | **가변 길이**로, 입력된 데이터의 실제 크기만큼만 공간을 차지. (데이터의 길이 확인을 위해 추가로 1~2바이트의 길이 정보 저장 공간 필요)  | **고정 길이**로, 선언한 길이만큼의 차지한다. 입력된 데이터가 선언된 길이보다 짧으면 나머지를 공백으로 채운다.               |
| 최대 길이  | 최대 길이 `65,535` 자 (UTF-8과 같은 멀티바이트 문<br>자셋 사용 시 실제 저장 가능 글자 수는 줄어듦)                 | `255` 자                                                                        |
| 공간 효율성 | 효율성 데이터 길이가 다양할 때 공간을 효율적으로 사용.                                                    | 데이터 길이가 모두 동일할 때 효율적이며, 가변 길이를 저장하면 공간 낭비가 발생.                                 |
| 성능     | 데이터 길이가 자주 변경되면, 행의 크기가 변해 데이터 단편화(fragmentation)나 페이지 분할이 발생하여 성능 저하의 원인이 될 수 있음. | 데이터 길이가 고정되어 있어 업데이트 시에도 행의 크기가 변하지 않으므로, 데이터 수정이 빈번할 때 `VARCHAR` 보다 유리할 수 있다. |

**실무에서의 선택 방향**: `VARCHAR` 의 보편적 사용. 과거에는 "길이가 고정적이면 `CHAR`, 가변적이면 `VARCHAR`는 다음과 같은 이유로 `VARCHAR` 를 우선적으로 고려하는 경우가 많다.

## 날짜와 시간 타입

- `DATE`: 날짜 정보('YYYY-MM-DD')만 저장한다.
- `DATETIME`: 날짜와 시간 정보('YYYY-MM-DD HH:MM:SS')를 함께 저장한다. 입력된 값을 그대로 저장한다.
- `TIMESTAMP`: `DATETIME` 과 유사하게 날짜와 시간을 저장하지만, 특별한 기능이 있다.
	- **타임존(Timezone) 자동 변환**: `TIMESTAMP` 는 데이터를 저장할 때 현재 서버의 타임존을 기준으로 UTC(협정 세계시)로 변환하여 저장하고, 데이터를 조회할 때는 현재 서버의 타임존에 맞춰 다시 변환해서 보여준다.

| 타입          | 저장 형식                 | 저장 공간 | 값의 범위                                                  | 주요 특징 및 사용 사례                                                                                                                                                 |
| ----------- | --------------------- | ----- | ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `DATE`      | `YYYY-MM-DD`          | 3 바이트 | `'1000-01-01'` ~ <br>`'9999-12-31'`                    | **날짜만 저장**. 시간 정보가 필요 없을 때 사<br>용.<br>**사용 사례**: 생년월일, 제품 출시일, 기념일                                                                                            |
| `TIME`      | `HH:MM:SS`            | 3 바이트 | '-838:59:59' ~ '838:59:59'                             | **시간 정보 또는 경과 시간을 저장**.<br>매우 넓은 범위를 지원하여 단순한 시각 외에 시간의 양을 저장.<br>**사용 사례**: 영업 시작/종료 시각, 비디오 재생 시간                                                           |
| `DATETIME`  | `YYYY-MM-DD HH:MM:SS` | 5 바이트 | '1000-01-01 00:00:00' <br>~ '9999-12-31 23:59:59'      | **날짜와 시간을 함께 저장**. 지정된 값을 그대로 저장하며, 타임존(Time Zone) 정보의 영향을 받지 않는다.<br>**사용 사례**: 이벤트 예약 시간, 특정 시점의 로그                                                         |
| `TIMESTAMP` | `YYYY-MM-DD HH:MM:SS` | 4 바이트 | 1970-01-01 00:00:01 UTC ~<br>'2038-01-19 03:14:07' UTC | **날짜와 시간을 함께 저장하며 타임존을 자동 변환**. 저장 시 서버 타임존을 기준으로 UTC로 변환하여 저장하고,<br>조회 시 현재 세션의 타임존에 맞춰 다시 변환해 준다.<br>**사용 사례**: 게시물 작성일(`created_at`), 최종 수정일(`updated_at`) |
| `YEAR`      | `YYYY`                | 1 바이트 | `1901` ~ `2155`                                        | **연도만 저장**. 4자리 연도를 저장하는 데 사<br>용된다.<br>**사용 사례**: 졸업 연도, 제조 연도                                                                                               |

### `DATETIME` vs `TIMESTAMP`

두 타입은 날짜와 시간을 모두 저장하지만, 결정적인 차이가 있어 구분해서 사용해야 한다.

| 구분                | `DATETIME`                                                                 | `TIMESTAMP`                                                                                    |
| ----------------- | -------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| 타임존(Time Zone) 처리 | **처리 안 함**. <br>입력된 값을 그대로 저장하고 그대로 보여준다. 서버의 타임존 설정이 바뀌어도 저장된 값은 변하지 않는다. | **자동 변환 처리**<br>값을 UTC(협정 세계시)로 변환하여 저장한다. 조회하는 사용자의 타임존 설정에 따라 시간이 자동으로 변환되어 보인다.             |
| 저장 가능 범위          | `1000년` ~ `9999년` (넓음)                                                     | `1970년` ~ `2038년` (제한적)                                                                        |
| 저장 공간             | 5 바이트 + α                                                                  | 4 바이트 + α                                                                                      |
| 자동 초기화/업데이트       | 기능이 없었으나 MySQL 5.6.5부터<br>지원한다.                                            | `DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` 기능을 통해 행 생성/수정 시 자동으로 현재 시간을 기록할 수 있다. |

현대의 애플리케이션 개발에서는 `TIMESTAMP` 보다는 `DATETIME` 사용을 권장한다.

- `TIMESTAMP` 는 2038년까지의 데이터만 보관할 수 있는 문제가 있다.
- `TIMESTAMP` 의 행의 생성/수정 시 자동으로 현재 시간을 기록해주는 기능을 이제는 `DATETIME` 도 지원한다.
- `TIMESTAMP` 의 저장공간이 약간 작지만 현대의 하드웨어와 DB에서는 미미한 차이
- 글로벌 서비스를 운영하는 경우 애플리케이션에서 `DATETIME` 에 데이터를 보관할 때 UTC 시간을 기준으로 변경해서 보관하면 된다.

## 기타 타입

- `BLOB`: 이미지, 오디오, 비디오 같은 ****이진**(Binary) **대용량**** 데이터를 저장한다.
- `ENUM`: 단일 선택 타입. 미리 정의한 값 목록 중 하나만 선택하여 저장할 수 있다.
- `SET`: 다중 선택 타입. 미리 정의한 값 목록 중 여러 개를 동시에 선택하여 저장할 수 있다.
실무에서 ENUM, SET 타입은 잘 사용하지 않는다.
