# DDL - 테이블 생성

```sql
CREATE TABLE customers (
	customer_id INT AUTO_INCREMENT PRIMARY KEY,
	name VARCHAR(50) NOT NULL,
	email VARCHAR(100) NOT NULL UNIQUE,
	password VARCHAR(255) NOT NULL,
	address VARCHAR(255) NOT NULL,
	join_date DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

- `customer_id`: 고객을 식별하는 기본 키(`PRIMARY KEY`). `AUTO_INCREMENT` 로 자동 번호가 부여된다.
	- `AUTO_INCREMENT` 덕분에 데이터를 저장할 때마다 값이 1씩 자동으로 증가한다. 따라서 모든 행을 구분할 수 있다.
- `name`, `email`, `password`, `address`: 모두 필수 값이므로 `NOT NULL` 을 설정했다.
- `email`: 고객마다 유일해야 하므로 `UNIQUE` 제약 조건을 추가했다.
- `join_date`: 가입 시각. 값을 따로 넣지 않으면 `DEFAULT` 설정에 따라 현재 시각(`CURRENT_TIMESTAMP`)이 자동으로 기록된다.

**날짜와 기본값 설정 옵션**

```sql
CREATE TABLE test (
	…
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
	updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

- `DEFAULT CURRENT_TIMESTAMP`: 새로운 데이터가 추가될 때, 해당 컬럼에 별도의 값을 지정하지 않으면 현재의 날짜와 시간이 자동으로 입력.
- `DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP`: 새로운 데이터가 추가될 때는 물론이고, 같은 행의 컬럼 값이 변경되어 업데이트될 때, 이 컬럼의 값은 현재 날짜와 시간으로 자동 갱신.

## 왜래키 제약 조건

```sql
CREATE TABLE orders (
	order_id INT AUTO_INCREMENT PRIMARY KEY,
	customer_id INT NOT NULL,
	product_id INT NOT NULL,
	quantity INT NOT NULL,
	order_date DATETIME DEFAULT CURRENT_TIMESTAMP,
	status VARCHAR(20) NOT NULL DEFAULT '주문접수',
	
	CONSTRAINT fk_orders_customers FOREIGN KEY (customer_id)
		REFERENCES customers(customer_id),
	CONSTRAINT fk_orders_products FOREIGN KEY (product_id)
		REFERENCES products(product_id)
);
```

- `order_id`: 주문을 식별하는 기본 키. `AUTO_INCREMENT` 를 사용했다.
- `customer_id`: 가장 중요한 부분. 이 주문을 한 고객이 누구인지를 나타낸다. 이 값은 `customers` 테이블의 `customer_id` 를 참조한다. 이곳을 확인하면 고객의 이름을 찾을 수 있다.
- `product_id`: 가장 중요한 부분. 어떤 상품을 주문했는지 나타낸다. 이 값은 `products` 테이블의 `product_id` 를 참조한다. 이곳을 확인하면 상품명을 찾을 수 있다.

`constraint fk_orders_customers foreign key (customer_id) references customers(customer_id)`
- `orders` 테이블의 `customer_id` 를 `customers` 테이블의 `customer_id` 와 연결하는 외래 키 설정이다. 이로써 두 테이블 사이에 '관계'가 형성된다. 이제 존재하지 않는 **고객 ID** 로 주문을 넣으려는 시도는 데이터베이스 단에서 차단된다.
- 외래 키 제약조건의 이름에는 관계 있는 테이블의 참조 순서와 이름을 사용했다. `orders -> customers` 이렇게 하면 이름으로 관계를 쉽게 파악할 수 있다.

## 테이블과 컬럼 이름 규칙

### 기본 규칙 (백틱 미사용)

백틱으로 감싸지 않는 이름은 가장 일반적이며 권장되는 방식이다. 예) `product_name`

- **허용 문자**
	- 영문 대소문자 (`a-z`, `A-Z`)
	- 숫자 (`0-9`)
	- **밑줄 (`_`)**
	- **달러 기호 (`$`)**
	- UTF-8과 같은 다국어 문자 (예: **한글**)
- **제한 사항**
	- 이름이 **숫자로 시작할 수 없다.**
	- MySQL **예약어** (예: `SELECT`, `TABLE`, `ORDER`)는 사용할 수 없다.
	- **총 길이는 64자**를 넘을 수 없다.

### 확장 규칙 (백틱 사용)

이름을 백틱(`` ` ``)으로 감싸면 훨씬 더 자유로운 이름 생성이 가능하다.
- **허용 문자**: **거의 모든 문자**가 허용된다.
	- **공백** (예: \`user name\`)
	- **하이픈** (`-`) 및 기타 특수문자 (예: \`item-code\`, \`@email\`)
	- **숫자로 시작**하는 이름 (예: \`2025_report\`)
	- **MySQL 예약어** (예: \`order\`, \`select\`)

### 권장되는 명명 규칙 (Best Practice)

기술적인 규칙을 넘어, 실무에서는 다음과 같은 규칙을 따르는 것이 좋다.
- **영문 소문자와 밑줄 사용**: `user_orders`, `product_name` 처럼 영문 소문자와 단어를 구분하는 밑줄(`_`)을 사용하는 것이 가장 일반적이다. (스네이크 케이스, snake_case)
- **일관성 유지**: 프로젝트 내에서 명명 규칙을 하나로 정하고 일관되게 적용하는 것이 중요하다.
- **예약어 피하기**: 백틱을 사용하면 예약어도 이름으로 쓸 수 있지만, 혼란을 피하기 위해 사용하지 않는 것이 좋다.
- **간결하고 명확하게**: 이름만 보고도 데이터의 의미를 파악할 수 있도록 만든다. (예: `prdct_nm` 보다는 `product_name`)
- **다국어 이름 피하기**: 한글 이름도 기술적으로는 가능하지만, 호환성 및 인코딩 문제를 예방하기 위해 영문으로 작성하는 것을 권장한다.
