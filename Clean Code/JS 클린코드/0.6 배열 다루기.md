# 배열 다루기

## Javascript의 배열은 객체다

```js
const arr = [1, 2, 3];

arr[3] = 'test';
arr['property'] = 'string value';
arr['obj'] = {};
arr[{}] = [1,2,3];
arr['func'] = function() {
  return 'hello';
};

for(let i = 0; i < arr.length; i++) {
  console.log(arr[i]);  // 1, 2, 3, test
}
```

새로운 값(property, func 등) 은 콘솔에 찍히지 않았다.

<img width="876" alt="image" src="https://user-images.githubusercontent.com/59427983/158042048-53d7b34d-2932-40da-92ea-bf9d3027913f.png">

찍어보면 오른쪽과 같이 모두 배열안에 값이 들어있는 모습을 볼 수 있음. 하지만 배열의 length는 4다. 따라서 for문에서 4번만 돌아 아래와 같은 결과가 나온 것임.

배열 index에 string, 함수 등을 집어 넣어도 가능했다. 마치 Object랑 비슷한 모습을 볼 수 있음. 그럼 객체로 만들어보자.

```js
const obj = {
  arr: [1, 2, 3],
  3: 'test',
  property: 'string value',
  obj: {},
  '{}': [1, 2, 3],
  func: function() {
    return 'hello';
  },
}
```

<img width="874" alt="image" src="https://user-images.githubusercontent.com/59427983/158042181-e9db7782-7cff-4728-bbbe-60262c1af29b.png">

맨 첫째줄을 빼고는 바뀐 것이 없다. 즉, 자바스크립트에서 배열은 **객체**다. 

```js
const arr = [1, 2, 3];

if (arr.length) {
  console.log('배열 확인');  // 배열 확인
}

if (typeof arr === 'object') {
  console.log('배열 확인');  // 배열 확인
}
```

typeof로 배열이 나오지 않고 object로 나오게 됨. 따라서 array인지를 검사하기 위해서는 반드시 `Array.isArray()` 빌트인 메서드를 사용하기 바람.

<br/>

<br/>

## Array.length

```js
const arr = [1, 2, 3];
console.log(arr.length);  // 3

arr.length = 10;
console.log(arr.length);  // 10

console.log(arr);  // [1, 2, 3, , , , , , , ]
```

배열의 length에 값을 할당할 수 있다. 하지만 마지막 console을 보면 배열 안에 빈 값이 추가된 것을 볼 수 있음. 객체처럼 존재하기 때문에 큰 문제를 발생시킬 수 있음. `length` 는 길이라고 생각하지 말고 **마지막 index** 라고 생각하자.

```js
const arr = [1, 2, 3];
arr[3] = 4;
console.log(arr.length);  // 4

arr[9] = 10;
console.log(arr.length);  // 10

console.log(arr);  // [ 1, 2, 3, 4, , , , , , 10 ]
```

index 9번째에 값을 집어 넣고 length를 찍어보면 10개라고 나온다.

그렇다면, 위의 특성을 사용해서 배열을 초기화 하는 방법을 알아보자.

```js
Array.prototype.clear = function() {
  this.length = 0;
}

function clearArray(array) {
  array.length = 0;

  return array;
}

const arr = [1, 2, 3];
arr.clear();

// console.log(arr);  // []
console.log(clearArray(arr));  // []
```

clear(), clearArray() 둘 다 써도 배열이 초기화 되는 모습을 볼 수 있음.

<br/>

<br/>

## 배열 요소에 접근하기

요소는 배열의 index에 들어가 있는 **값** 자체를 말한다. 아래와 같이 `[0]` 번방에 접근하는 방식은 위험하다고 볼 수 있다.

```js
function operateTime(inputs, operators, is) {
  inputs[0].split('').forEach((num) => {
    cy.get('.digit').contains(num).click();
  });

  inputs[1].split('').forEach((num) => {
    cy.get('.digit').contains(num).click();
  })
}
```

왜냐하면, 무었이 들어가 있는지 알 수 없기 때문임. 그렇다면 안전하게 바꾸는 방법에 대해서 알아보자.

```js
function operateTime(inputs, operators, is) {
  const [firstInput, secondInput] = inputs;
  
  firstInput.split('').forEach((num) => {
    cy.get('.digit').contains(num).click();
  });

  secondInput.split('').forEach((num) => {
    cy.get('.digit').contains(num).click();
  });
}
```

이렇게 구조분해 할당으로 이름을 부여해주고 만들어진 이름으로 [0], [1]을 대신했다. 훨씬 어떤 값이 들어오는지 알기 쉽게 만들어졌다. 한번 더 좋게 만들어보자.

```js
function operateTime([firstInput, secondInput], operators, is) {  // 여기
  firstInput.split('').forEach((num) => {
    cy.get('.digit').contains(num).click();
  });

  secondInput.split('').forEach((num) => {
    cy.get('.digit').contains(num).click();
  });
}
```

인자로 받을 때부터 분해를 해버리면 된다. 다른 녀석을 보자.

```js
function formatDate(targetDate) {
  const date = targetDate.toISOString().split('T')[0];
  const [year, month, day] = date.split('-');
  return `${year}년 ${month}월 ${day}일`;
}
```

여기서는 문제가 없어보이지만, `split('T')[0]` 이녀석이 명시적이지 못하다. 그럼 아래와 같이 사용할 수 있다.

```js
const [date] = targetDate.toISOString().split('T');
```

<br/>

<br/>

## 유사 배역 객체

```js
const arrayLikeObject = {
  0: 'HELLO',
  1: 'WORLD',
  length: 2,
};

const arr = Array.from(arrayLikeObject);
console.log(arr);  // [ 'HELLO', 'WORLD' ]

console.log(Array.isArray(arrayLikeObject));  // false
console.log(Array.isArray(arr));  // true
```

여기서 length라는 프로퍼티를 지우면 arr는 `[]` 빈 배열이 된다. 아래 콘솔은 동일. 즉, 배열은 객체다라는 것이 증명된다. 유사 배열 객체는 복잡한 녀석임. NodeList도 유사 배열 객체이고, function 안에 `arguments` 라는 녀석도 유사 배열 객체다.

```js
function generatePriceList() {
  for(let i = 0; i < arguments.length; i++) {
    const element = arguments[i];
    console.log(element); // 100, 200, 300, 400
  }
  console.log(Array.isArray(arguments));  // false
}
generatePriceList(100, 200, 300, 400);
```

즉, **arguments** 는 가변인자로, 어떤 인자가 들어올지 모를 때 사용할 수 있는 것임. arguments는 for 문으로 돌릴 수 있기 때문에 배열이라고 생각하기 쉽지만, **유사 배열 객체**다. `Array.isArray(arguments)` 를 찍어보면 **false** 가 나오는 것을 볼 수 있음.

따라서 고차함수를 사용하면 동작하지 않는다.

```js
function generatePriceList() {
  return arguments.map(arg => arg + '원');  // arguments.map is not a function
}
```

그러면 유사 배열 객체를 배열로 만들어주면 사용할 수 있다.

```js
return Array.from(arguments).map(arg => arg + '원');
```

<br/>

<br/>

## 불변성(immutable)

변하지 않는다.

```js
const originArray = ['123', '456', '789'];

const newArray = originArray;

originArray.push(10);
originArray.push(11);
originArray.push(12);
originArray.unshift(0);

newArray  // [ 0, '123', '456', '789', 10, 11, 12 ]
```

새로운 배열도 바뀌어 있다. 왜냐하면 바라보는 메모리 주소가 같기 때문이다.

```js
const newArray = [...originArray];
```

이런 식으로 복사해준다면 